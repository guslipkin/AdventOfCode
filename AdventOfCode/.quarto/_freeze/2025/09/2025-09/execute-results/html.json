{
  "hash": "5ec068f1cbc82feded2c29d99d2887d4",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Movie Theater\"\nformat: html\ndate: \"2025-12-09\"\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(mistlecode)\n\noptions(scipen = 999)\n```\n:::\n\n\n\n\n## Part 1\n\nOff by one errors and pesky zeroes.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npoints <-\n  'input.txt' |>\n  readLines() |>\n  stringr::str_split(',') |>\n  purrr::map(as.numeric)\n\npoints |>\n  seq_along() |>\n  utils::head(-1) |>\n  purrr::map(\\(i) {\n    i:length(points) |>\n      purrr::map_dbl(\\(j) {\n        if (i == j) return(0L)\n        width <- abs(points[[i]][1] - points[[j]][1]) + 1\n        height <- abs(points[[i]][2] - points[[j]][2]) + 1\n        if (width == 0) width <- 1\n        if (height == 0) height <- 1\n        (width * height)\n      })\n  }) |>\n  unlist() |>\n  max()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4739623064\n```\n\n\n:::\n:::\n\n\n\n\n## Part 2\n\nVery pleased with this one. I had this whole convoluted solution actually plotting out the green tiles but then was like \"how do I check if something is in a polygon?\" and realized I do know how to do that. `geos` is great for stuff like this. It's super fast and easy to work with unlike `sf`. Unfortunately `geos::geos_area()` didn't work because these are points on a grid and not a lat/long. There's probably a CRS I could've used but I didn't.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npoints <-\n  'input.txt' |>\n  readLines() |>\n  stringr::str_split(',') |>\n  purrr::map(as.numeric)\n\npolygon_points <-\n  points |>\n  append(points[1]) |>\n  do.call(rbind, args = _)\n\npolygon <- \n  geos::geos_make_polygon(x = polygon_points[,1], y = polygon_points[,2])\n\nchosen_one <-\n  expand.grid(\n    'i' = seq_along(points),\n    'j' = seq_along(points)\n  ) |>\n  dplyr::filter(.data$j > .data$i) |>\n  dplyr::mutate(\n    'rectangle' = purrr::map2_vec(.data$i, .data$j, \\(i, j) {\n      geos::geos_create_rectangle(\n        points[[i]][1], points[[i]][2], \n        points[[j]][1], points[[j]][2]\n      )\n    }),\n    'covers' = geos::geos_contains(.env$polygon, .data$rectangle)\n  ) |>\n  dplyr::filter(.data$covers) |>\n  dplyr::mutate(\n    'area' = purrr::map2_dbl(.data$i, .data$j, \\(i, j) {\n      width <- abs(points[[i]][1] - points[[j]][1]) + 1\n      height <- abs(points[[i]][2] - points[[j]][2]) + 1\n      if (width == 0) width <- 1\n      if (height == 0) height <- 1\n      (width * height)\n    })\n  ) |>\n  dplyr::filter(.data$area == max(.data$area))\nplot(c(polygon, chosen_one$rectangle))\n```\n\n::: {.cell-output-display}\n![](2025-09_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n\n```{.r .cell-code}\nchosen_one$area\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1654141440\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}