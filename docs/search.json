[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Gus Lipkin’s Awesome Code",
    "section": "",
    "text": "Star Chart\nWelcome to my Advent of Code book! All of my solutions are in R with varying degrees of complexity and documentation.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Welcome!</span>"
    ]
  },
  {
    "objectID": "index.html#my-favorite-solutions",
    "href": "index.html#my-favorite-solutions",
    "title": "Gus Lipkin’s Awesome Code",
    "section": "My Favorite Solutions",
    "text": "My Favorite Solutions\n\n\n2016-12 and 2017-08: I created a small assembly style computer that solves the problems for me given a set of registers and instructions.\n\n2021-09: I used the dbscan clustering method to solve a path finding issue.\n\n2022-04: While not my fastest part 1, part 2 took me just 38 seconds!\n\n2022-11: I used S3 Classes and function factories for the first time, and got just a little bit better at recursion.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Welcome!</span>"
    ]
  },
  {
    "objectID": "2024/01/2024-01.html",
    "href": "2024/01/2024-01.html",
    "title": "01: Historian Hysteria",
    "section": "",
    "text": "Part 1\nThis was nice and quick. I’m pretty happy with my global rank 518.\ndt1 &lt;- dt$X1 |&gt; sort()\ndt2 &lt;- dt$X2 |&gt; sort()\n\nabs(dt1 - dt2) |&gt; sum()\n\n[1] 1151792",
    "crumbs": [
      "2024",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>01: Historian Hysteria</span>"
    ]
  },
  {
    "objectID": "2024/01/2024-01.html#part-2",
    "href": "2024/01/2024-01.html#part-2",
    "title": "01: Historian Hysteria",
    "section": "Part 2",
    "text": "Part 2\nThis took way too long for me. I was really struggling with the counting portion for some reason and it took a long time for me to internalize that x %in% y and which don’t actually count things. Might need to add that to mistlecode…\n\ndt |&gt;\n  dplyr::mutate('count' = purrr::map_int(.data$X1, \\(x) {\n    which(.data$X2 == x) |&gt; length()\n  })) |&gt;\n  dplyr::mutate('count' = .data$X1 * .data$count) |&gt;\n  dplyr::pull(.data$count) |&gt;\n  sum()\n\n[1] 21790168",
    "crumbs": [
      "2024",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>01: Historian Hysteria</span>"
    ]
  },
  {
    "objectID": "2023/01/2023-01.html",
    "href": "2023/01/2023-01.html",
    "title": "01: Trebuchet?!",
    "section": "",
    "text": "Part 1\nThis wasn’t too bad. Just forgot to unlist initially.\ndt |&gt;\n   sapply(\\(x) {\n     x |&gt;\n      str_extract_all('[0-9]') |&gt;\n      unlist() -&gt; y\n    glue::glue('{head(y, 1)}{tail(y, 1)}')\n  }) |&gt;\n  as.numeric() |&gt;\n  sum()\n\n[1] 56397",
    "crumbs": [
      "2023",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>01: Trebuchet?!</span>"
    ]
  },
  {
    "objectID": "2023/01/2023-01.html#part-2",
    "href": "2023/01/2023-01.html#part-2",
    "title": "01: Trebuchet?!",
    "section": "Part 2",
    "text": "Part 2\nThis took way too long and I hate incomplete examples. Absolutely no indication that oneight flips for both 1 and 8.\n\nnumbers &lt;-\n  c(\n    'one' = 1,\n    'two' = 2,\n    'three' = 3,\n    'four' = 4,\n    'five' = 5,\n    'six' = 6,\n    'seven' = 7,\n    'eight' = 8,\n    'nine' = 9\n  )\ndt |&gt;\n  sapply(\\(x) {\n    n &lt;- c(names(numbers), '[1-9]')\n    i &lt;-\n      x |&gt;\n      stringi::stri_locate_all_regex(n, omit_no_match = TRUE) |&gt;\n      lapply(data.frame) |&gt;\n      purrr::list_rbind() |&gt;\n      dplyr::pull(start) |&gt;\n      order()\n    x &lt;-\n      stringi::stri_match_all_regex(x, n) |&gt;\n      unlist() |&gt;\n      purrr::discard(is.na)\n    y &lt;- ifelse(x %in% names(numbers), numbers[x], x)[i]\n    glue::glue('{head(y, 1)}{tail(y, 1)}')\n  }) |&gt;\n  as.numeric() |&gt;\n  sum()\n\n[1] 55701",
    "crumbs": [
      "2023",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>01: Trebuchet?!</span>"
    ]
  },
  {
    "objectID": "2023/02/2023-02.html",
    "href": "2023/02/2023-02.html",
    "title": "02: Cube Conundrum",
    "section": "",
    "text": "Part 1\nI’m pretty pleased overall. I got a bit hung up on the if statements because y was originally all the colors, not one color at a time so I had to add the second (actually third) map statement.\nred &lt;- 12; green &lt;- 13; blue &lt;- 14;\n\ndt |&gt;\n  purrr::map_lgl(\\(x) {\n    x &lt;-\n      x |&gt;\n      purrr::map(\\(x2) {\n        x2 |&gt;\n          stringr::str_split(\" \") |&gt;\n          purrr::map(\\(y) {\n            r &lt;- 1\n            if ((y[2] == 'red' & as.numeric(y[1]) &gt; red) |\n                (y[2] == 'green' & as.numeric(y[1]) &gt; green) |\n                (y[2] == 'blue' & as.numeric(y[1]) &gt; blue)) {\n              r &lt;- 0\n            }\n            return(r)\n          })\n    }) |&gt;\n      unlist()\n    all(x == 1)\n  }) |&gt;\n  which() |&gt;\n  sum()\n\n[1] 2006",
    "crumbs": [
      "2023",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>02: Cube Conundrum</span>"
    ]
  },
  {
    "objectID": "2023/02/2023-02.html#part-2",
    "href": "2023/02/2023-02.html#part-2",
    "title": "02: Cube Conundrum",
    "section": "Part 2",
    "text": "Part 2\nPretty happy with this too. I got pretty stuck on X1 being character because I was casting later but that meant I was finding the max of a character not a numeric. Moved the cast and it works like a dream.\n\ndt |&gt;\n  purrr::map_int(\\(x) {\n    x |&gt;\n    purrr::map(\\(y) {\n      y |&gt;\n        stringr::str_split_fixed(\" \", 2) |&gt;\n        data.frame() |&gt;\n        dplyr::arrange(X2)\n    }) |&gt;\n      purrr::list_rbind() |&gt;\n      dplyr::summarise(count = max(as.numeric(X1)), .by = X2) |&gt;\n      dplyr::pull(count) |&gt;\n      as.numeric() |&gt;\n      prod()\n  }) |&gt;\n  sum()\n\n[1] 84911",
    "crumbs": [
      "2023",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>02: Cube Conundrum</span>"
    ]
  },
  {
    "objectID": "2023/03/2023-03.html",
    "href": "2023/03/2023-03.html",
    "title": "03: Gear Ratios",
    "section": "",
    "text": "Part 1\nThis was so much fun! I love dbscan with all my heart. I also did something really stupid and submitted the test input then had to wait the longest minute of my life to submit the real answer.\ndt &lt;- mistlecode::matrix_to_coords(m)\nclust &lt;-\n  dt |&gt;\n  dplyr::filter(data != \".\") |&gt;\n  dplyr::select(-data) |&gt;\n  dbscan::dbscan(sqrt(2), minPts = 2)\ndt &lt;- \n  dt |&gt;\n  dplyr::filter(data != \".\") |&gt;\n  dplyr::mutate(clust = clust$cluster) |&gt;\n  dplyr::filter(any(!grepl('[0-9]', data)), .by = 'clust')\nnumbers &lt;-\n  mistlecode::coords_to_matrix(dt$data, dt$row, dt$col) |&gt;\n  t() |&gt;\n  as.vector() |&gt;\n  paste0(collapse = \"\") |&gt;\n  stringr::str_replace_all('[^0-9]', ' ') |&gt;\n  stringr::str_split(' ') |&gt;\n  unlist() |&gt;\n  as.numeric() |&gt;\n  purrr::discard(is.na)\nsum(numbers, na.rm = TRUE)\n\n[1] 520019",
    "crumbs": [
      "2023",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>03: Gear Ratios</span>"
    ]
  },
  {
    "objectID": "2023/03/2023-03.html#part-2",
    "href": "2023/03/2023-03.html#part-2",
    "title": "03: Gear Ratios",
    "section": "Part 2",
    "text": "Part 2\nThis is really long-winded. I’m sure it could be better functionalized. The hard part wasn’t as much figuring out what goes in a group as much as figuring out what goes in which group.\n\ndt &lt;- mistlecode::matrix_to_coords(m)\nnumber_clust &lt;-\n  dt |&gt;\n  dplyr::filter(grepl('[0-9]', data)) |&gt;\n  dplyr::select(-data) |&gt;\n  dbscan::dbscan(1, minPts = 1)\nnumber_dt &lt;-\n  dt |&gt;\n  dplyr::filter(grepl('[0-9]', data)) |&gt;\n  dplyr::mutate(number_clust = number_clust$cluster)\nclust_dt &lt;- \n  dt |&gt;\n  dplyr::filter(data != \".\") |&gt;\n  dplyr::mutate(clust = clust$cluster) |&gt;\n  dplyr::left_join(number_dt, by = dplyr::join_by(data, row, col)) |&gt;\n  dplyr::filter(any(!grepl('[0-9]', data)), .by = 'clust') |&gt;\n  dplyr::mutate(\n    has_prod = any(data == '*') & length(unique(number_clust[!is.na(number_clust)])) == 2,\n    prod_group = dplyr::cur_group_id(),\n    .by = 'clust'\n  ) |&gt;\n  dplyr::filter(grepl('[0-9]', data))\nhas_prod &lt;-\n  mistlecode::coords_to_matrix(clust_dt$prod_group, clust_dt$row, clust_dt$col) |&gt;\n  t() |&gt;\n  as.vector() |&gt;\n  data.frame() |&gt;\n  `colnames&lt;-`('has_prod') |&gt;\n  dplyr::mutate(t = cumsum(is.na(has_prod))) |&gt;\n  dplyr::filter(dplyr::row_number() == dplyr::n() & !is.na(has_prod), .by = 't') |&gt;\n  dplyr::pull(has_prod)\n\ndata.frame(\n  has_prod,\n  numbers\n) |&gt;\n  dplyr::filter(dplyr::n() &gt;= 2, .by = has_prod) |&gt;\n  dplyr::summarise(val = prod(numbers), .by = has_prod) |&gt;\n  dplyr::pull(val) |&gt;\n  sum()\n\n[1] 75519888",
    "crumbs": [
      "2023",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>03: Gear Ratios</span>"
    ]
  },
  {
    "objectID": "2023/04/2023-04.html",
    "href": "2023/04/2023-04.html",
    "title": "04: Scratchcards",
    "section": "",
    "text": "Part 1\nThis took me longer than it should’ve, mostly because of the multiplication factor. I’m happy with my code, but disappointed in how long it took.\nbreak_line &lt;- function(x) {\n  x |&gt;\n    stringr::str_split(\" +\") |&gt; \n    unlist() |&gt; \n    as.numeric() |&gt; \n    purrr::discard(is.na)\n}\ndt |&gt;\n  purrr::map(\\(x) {\n    x1 &lt;- break_line(x[1]); x2 &lt;- break_line(x[2]);\n    x &lt;- sum(x1 %in% x2)\n    floor(2^(x-1))\n  }) |&gt;\n  unlist() |&gt;\n  sum()\n\n[1] 21105",
    "crumbs": [
      "2023",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>04: Scratchcards</span>"
    ]
  },
  {
    "objectID": "2023/04/2023-04.html#part-2",
    "href": "2023/04/2023-04.html#part-2",
    "title": "04: Scratchcards",
    "section": "Part 2",
    "text": "Part 2\nPart 2 follows the same theme as part 1. I’m ultimately really pleased with my code, but it took way too long and in this case could be faster too. The almost recursion but not quite was quite confusing to figure out and I’m sure my code makes even less sense than the problem does.\n\ndt2 &lt;- list()\ndt |&gt;\n  purrr::iwalk(\\(x, idx) {\n    x1 &lt;- break_line(x[1]); x2 &lt;- break_line(x[2]);\n    i &lt;- if (length(dt2) == 0) 1 else (unname(table(unlist(dt2))[idx]) + 1)\n    i &lt;- if (is.na(i)) 1 else i\n    dt2[[idx]] &lt;&lt;- c(idx, rep((idx:(idx + sum(x1 %in% x2)))[-1], i))\n  })\ndt2 |&gt; \n  unlist() |&gt; \n  length()\n\n[1] 5329815",
    "crumbs": [
      "2023",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>04: Scratchcards</span>"
    ]
  },
  {
    "objectID": "2023/07/2023-07.html",
    "href": "2023/07/2023-07.html",
    "title": "07: Camel Cards",
    "section": "",
    "text": "Part 1\nThis wasn’t too bad, but I originally used a dplyr::case_when instead of my if...else chain and because dplyr::case_when is vectorized, that wouldn’t work. However, when I swapped to my if...else chain, I accidentally marked three of a kind as the same value as a full house. Quite annoying, but an easy fix.\nrank &lt;- c('A', 'K', 'Q', 'J', 'T', 9:2) |&gt; rev()\ndt |&gt;\n  dplyr::mutate(\n    '.nest' = purrr::map(.data$cards, \\(x) {\n      # x &lt;- 'QJJQ2'\n      h &lt;-\n        x |&gt;\n        stringr::str_split_1('') |&gt;\n        table() |&gt;\n        sort(decreasing = TRUE)\n      hand &lt;-\n        if (length(h) == 1 && all(h %in% 5)) 7\n        else if (length(h) == 2 && all(h %in% c(4, 1))) 6\n        else if (length(h) == 2 && all(h %in% c(3, 2))) 5\n        else if (length(h) == 3 && max(h) == 3) 4\n        else if (length(h[h == 2]) == 2 && max(h) == 2) 3\n        else if (length(h[h == 2]) == 1 && max(h) == 2) 2\n        else 1\n      high &lt;-\n        x |&gt; \n        stringr::str_split_1('') |&gt;\n        purrr::map_int(\\(y) which(rank == y)) |&gt;\n        stringr::str_pad(2, pad = '0') |&gt;\n        paste0(collapse = '') |&gt;\n        as.integer()\n      list('hand' = hand, 'high' = high)\n    })\n  ) |&gt;\n  tidyr::unnest_wider('.nest') |&gt;\n  dplyr::arrange(.data$hand, .data$high) |&gt;\n  dplyr::mutate('bid' = as.integer(.data$bet) * dplyr::row_number()) |&gt;\n  dplyr::pull(.data$bid) |&gt;\n  sum()\n\n[1] 250120186",
    "crumbs": [
      "2023",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>07: Camel Cards</span>"
    ]
  },
  {
    "objectID": "2023/07/2023-07.html#part-2",
    "href": "2023/07/2023-07.html#part-2",
    "title": "07: Camel Cards",
    "section": "Part 2",
    "text": "Part 2\nThis took longer than it should’ve. I had the concept down quick, but was assigning the Joker to the highest available card rather than the card with the most occurrences. This is quickly apparent with the example KTJJT which with my original method would’ve become KTKKT, a full house, instead of KTTTT, four of a kind.\n\nrank &lt;- c('A', 'K', 'Q', 'T', 9:2, 'J') |&gt; rev()\ndt |&gt;\n  dplyr::mutate(\n    '.nest' = purrr::map(.data$cards, \\(x) {\n      # x &lt;- 'KTJJT'\n      x &lt;- stringr::str_split_1(x, '')\n      h &lt;-\n        x |&gt;\n        table() |&gt;\n        sort(decreasing = TRUE)\n      if (any(names(h) == 'J') & !all(names(h) == 'J')) {\n        r &lt;- which(rank == names(h[names(h) != 'J'])[1])\n        h[rank[r]] &lt;- h[rank[r]] + h['J']\n      } else if (length(h) == 1 & all(names(h) == 'J')) {\n        h &lt;- c('A' = 5)\n      }\n      h &lt;- h[names(h) != 'J']\n      hand &lt;- {\n        if (length(h) == 1 && all(h %in% 5)) 7\n        else if (length(h) == 2 && all(h %in% c(4, 1))) 6\n        else if (length(h) == 2 && all(h %in% c(3, 2))) 5\n        else if (length(h) == 3 && max(h) == 3) 4\n        else if (length(h[h == 2]) == 2 && max(h) == 2) 3\n        else if (length(h[h == 2]) == 1 && max(h) == 2) 2\n        else 1\n      }\n      high &lt;-\n        x |&gt; \n        purrr::map_int(\\(y) which(rank == y)) |&gt;\n        stringr::str_pad(2, pad = '0') |&gt;\n        paste0(collapse = '') |&gt;\n        as.integer()\n      list('hand' = hand, 'high' = high)\n    })\n  ) |&gt;\n  tidyr::unnest_wider('.nest') |&gt;\n  dplyr::arrange(.data$hand, .data$high) |&gt;\n  dplyr::mutate('bid' = as.integer(.data$bet) * dplyr::row_number()) |&gt;\n  dplyr::pull(.data$bid) |&gt;\n  sum()\n\n[1] 250665248",
    "crumbs": [
      "2023",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>07: Camel Cards</span>"
    ]
  },
  {
    "objectID": "2023/08/2023-08.html",
    "href": "2023/08/2023-08.html",
    "title": "08: Haunted Wasteland",
    "section": "",
    "text": "Part 1\nI have evidence that I struggled some other time, but I have no recollection. This was pretty easy, just had an off-by-one to deal with to get around the modulo of length sometimes being zero.\nstart &lt;- function(end, dir) {\n  dt[[dir]][dt$start == end]\n}\n\ncount &lt;- 0\nend &lt;- 'AAA'\nrepeat {\n  end &lt;- start(end, dir[(count %% length(dir)) + 1])\n  if (end == 'ZZZ') break else count &lt;- count + 1\n}\ncount + 1\n\n[1] 17141",
    "crumbs": [
      "2023",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>08: Haunted Wasteland</span>"
    ]
  },
  {
    "objectID": "2023/08/2023-08.html#part-2",
    "href": "2023/08/2023-08.html#part-2",
    "title": "08: Haunted Wasteland",
    "section": "Part 2",
    "text": "Part 2\nI hate when there’s a fancy math way. It’s just least common multiples this time and I’m super dumb for not thinking of this sooner. I did have to be careful with match instead of %in% because that would return the indices in the incorrect order and cause everything to fail.\n\nstart &lt;- function(end, dir) {\n  dt[[dir]][match(end, dt$start)]\n}\n\ncount &lt;- 0\nend &lt;-\n  dt |&gt;\n    dplyr::filter(grepl('A$', .data$start)) |&gt;\n    dplyr::pull(.data$start)\ntargets &lt;-\n  dt |&gt;\n    dplyr::filter(grepl('Z$', .data$start)) |&gt;\n    dplyr::pull(.data$start)\ntarget_pos &lt;- integer(length(end))\nrepeat {\n  end &lt;- start(end, dir[(count %% length(dir)) + 1])\n  if (any(end %in% targets)) {\n    target_pos[end %in% targets] &lt;- count\n    if (!any(target_pos == 0)) break\n  }\n  count &lt;- count + 1\n}\ncheapr::scm(target_pos + 1)\n\n[1] 10818234074807",
    "crumbs": [
      "2023",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>08: Haunted Wasteland</span>"
    ]
  },
  {
    "objectID": "2023/13/2023-13.html",
    "href": "2023/13/2023-13.html",
    "title": "13: Point of Incidence",
    "section": "",
    "text": "Part 1\nOkay okay. Not too bad. Just need to make sure I get the line of reflection right.\nget_up_down &lt;- function(up, down) {\n  l &lt;- min(c(length(up), length(down)))\n  up &lt;- rev(rev(up)[seq_len(l)]); down &lt;- down[rev(seq_len(l))];\n  list('up' = up, 'down' = down)\n}\nget_seq &lt;- function(s) { s |&gt; seq_len() |&gt; head(-1) }\ncheck_row &lt;- function(x) {\n  x |&gt;\n    nrow() |&gt;\n    get_seq() |&gt;\n    purrr::map_int(\\(r) {\n      up &lt;- seq_len(r); down &lt;- min(c(r+1,nrow(x))):nrow(x)\n      updown &lt;- get_up_down(up, down)\n      up &lt;- x[updown$up,]; down &lt;- x[updown$down,];\n      if (all(up == down)) r * 100 else 0\n    })\n}\ncheck_col &lt;- function(x) {\n  x |&gt;\n    ncol() |&gt;\n    get_seq() |&gt;\n    purrr::map_int(\\(r) {\n      up &lt;- seq_len(r); down &lt;- min(c(r+1,ncol(x))):ncol(x)\n      updown &lt;- get_up_down(up, down)\n      up &lt;- x[,updown$up]; down &lt;- x[,updown$down];\n      if (all(up == down)) r else 0\n    })\n}\ndt |&gt;\n  purrr::map(\\(x) {\n    c(check_row(x), check_col(x))\n  }) |&gt;\n  unlist() |&gt;\n  sum()\n\n[1] 37718",
    "crumbs": [
      "2023",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>13: Point of Incidence</span>"
    ]
  },
  {
    "objectID": "2023/13/2023-13.html#part-2",
    "href": "2023/13/2023-13.html#part-2",
    "title": "13: Point of Incidence",
    "section": "Part 2",
    "text": "Part 2\nomg. This is gonna be easy. I just need to check if all but one are equal instead of all. I got this in well under two minutes!\n\ncheck_row &lt;- function(x) {\n  x |&gt;\n    nrow() |&gt;\n    get_seq() |&gt;\n    purrr::map_int(\\(r) {\n      up &lt;- seq_len(r); down &lt;- min(c(r+1,nrow(x))):nrow(x)\n      updown &lt;- get_up_down(up, down)\n      up &lt;- x[updown$up,]; down &lt;- x[updown$down,];\n      if (sum(up == down) == length(up) - 1) r * 100 else 0\n    })\n}\ncheck_col &lt;- function(x) {\n  x |&gt;\n    ncol() |&gt;\n    get_seq() |&gt;\n    purrr::map_int(\\(r) {\n      up &lt;- seq_len(r); down &lt;- min(c(r+1,ncol(x))):ncol(x)\n      updown &lt;- get_up_down(up, down)\n      up &lt;- x[,updown$up]; down &lt;- x[,updown$down];\n      if (sum(up == down) == length(up) - 1) r else 0\n    })\n}\ndt |&gt;\n  purrr::map(\\(x) {\n    c(check_row(x), check_col(x))\n  }) |&gt;\n  unlist() |&gt;\n  sum()\n\n[1] 40995",
    "crumbs": [
      "2023",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>13: Point of Incidence</span>"
    ]
  },
  {
    "objectID": "2022/01/2022-01.html",
    "href": "2022/01/2022-01.html",
    "title": "2022-01: Calorie Counting",
    "section": "",
    "text": "Part 1\nMy initial thought was to use data.table::fread but that skipped the spaces in the input by default. readLines keeps the spaces so I switched to that right away.\nThis was just a matter of getting a loop with a maximum value counter going. I knew from the get-go that I would need to use the global assignment operator inside the loop. For reasons I thought that naming my variable sum would work but got an error since that’s a reserved word in R (duh!). Find+replace helped get that sorted but my inner loop logic was still wrong. I realized that I was missing an else case to catch any time the maximum hadn’t changed, but the sum needed to be reset.\nsm &lt;- 0\nmaxsm &lt;- 0\nfor (x in dt) {\n  x &lt;- as.numeric(x)\n  if (!is.na(x)) {\n    sm &lt;&lt;- sm + x\n  } else if (sm &gt; maxsm) {\n    maxsm &lt;&lt;- sm\n    sm &lt;&lt;- 0\n  } else {\n    sm &lt;&lt;- 0\n  }\n}\nmaxsm\n\n[1] 68923",
    "crumbs": [
      "2022",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>2022-01: Calorie Counting</span>"
    ]
  },
  {
    "objectID": "2022/01/2022-01.html#part-2",
    "href": "2022/01/2022-01.html#part-2",
    "title": "2022-01: Calorie Counting",
    "section": "Part 2",
    "text": "Part 2\nComing out of Part 1 was really strong, especially on Day 1. Instead of saving just the max sum, I made it a vector to record all sums. Then I just need to sort it, get the top three values, and sum those.\n\nsm &lt;- 0\nmaxsm &lt;- c()\nfor (x in dt) {\n  x &lt;- as.numeric(x)\n  if (!is.na(x)) {\n    sm &lt;&lt;- sm + x\n  } else  {\n    maxsm &lt;&lt;- c(maxsm, sm)\n    sm &lt;&lt;- 0\n  }\n}\nsum(sort(maxsm, decreasing = TRUE)[1:3])\n\n[1] 200044",
    "crumbs": [
      "2022",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>2022-01: Calorie Counting</span>"
    ]
  },
  {
    "objectID": "2022/02/2022-02.html",
    "href": "2022/02/2022-02.html",
    "title": "2022-02: Rock Paper Scissors",
    "section": "",
    "text": "Part 1\nThis isn’t so bad, just rock, paper, scissors.\nI initially did V1 == V2 but that doesn’t work with ABC and XYZ, but a quick fix put me at 549 on the leaderboard so I’m really pleased.\ndt %&gt;%\n  mutate(\"my_score\" = case_when(\n    V2 == \"X\" ~ 1,\n    V2 == \"Y\" ~ 2,\n    V2 == \"Z\" ~ 3\n  )) %&gt;%\n  mutate(\"win_score\" = case_when(\n    (V1 == \"A\" & V2 == \"X\") | (V1 == \"B\" & V2 == \"Y\") | (V1 == \"C\" & V2 == \"Z\") ~ 3,\n    V1 == \"A\" & V2 == \"Y\" ~ 6,\n    V1 == \"A\" & V2 == \"Z\" ~ 0,\n    V1 == \"B\" & V2 == \"X\" ~ 0,\n    V1 == \"B\" & V2 == \"Z\" ~ 6,\n    V1 == \"C\" & V2 == \"X\" ~ 6,\n    V1 == \"C\" & V2 == \"Y\" ~ 0\n  )) %&gt;%\n  mutate(\"score\" = my_score + win_score) %&gt;%\n  pull(\"score\") %&gt;%\n  sum()\n\n[1] 14163",
    "crumbs": [
      "2022",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>2022-02: Rock Paper Scissors</span>"
    ]
  },
  {
    "objectID": "2022/02/2022-02.html#part-2",
    "href": "2022/02/2022-02.html#part-2",
    "title": "2022-02: Rock Paper Scissors",
    "section": "Part 2",
    "text": "Part 2\nI had this one pretty quick, just a bit of logic to get the play column right. Of course, I then had to remember to change all the right V2 references which took me a minute to figure out when I missed the second mutate.\n\ndt %&gt;%\n  mutate(\"play\" = case_when(\n    V2 == \"X\" & V1 == \"A\" ~ \"Z\",\n    V2 == \"X\" & V1 == \"B\" ~ \"X\",\n    V2 == \"X\" & V1 == \"C\" ~ \"Y\",\n    V2 == \"Y\" & V1 == \"A\" ~ \"X\",\n    V2 == \"Y\" & V1 == \"B\" ~ \"Y\",\n    V2 == \"Y\" & V1 == \"C\" ~ \"Z\",\n    V2 == \"Z\" & V1 == \"A\" ~ \"Y\",\n    V2 == \"Z\" & V1 == \"B\" ~ \"Z\",\n    V2 == \"Z\" & V1 == \"C\" ~ \"X\",\n  )) %&gt;%\n  mutate(\"my_score\" = case_when(\n    play == \"X\" ~ 1,\n    play == \"Y\" ~ 2,\n    play == \"Z\" ~ 3\n  )) %&gt;%\n  mutate(\"win_score\" = case_when(\n    (V1 == \"A\" & play == \"X\") | (V1 == \"B\" & play == \"Y\") | (V1 == \"C\" & play == \"Z\") ~ 3,\n    V1 == \"A\" & play == \"Y\" ~ 6,\n    V1 == \"A\" & play == \"Z\" ~ 0,\n    V1 == \"B\" & play == \"X\" ~ 0,\n    V1 == \"B\" & play == \"Z\" ~ 6,\n    V1 == \"C\" & play == \"X\" ~ 6,\n    V1 == \"C\" & play == \"Y\" ~ 0\n  )) %&gt;%\n  mutate(\"score\" = my_score + win_score) %&gt;%\n  pull(\"score\") %&gt;%\n  sum()\n\n[1] 12091",
    "crumbs": [
      "2022",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>2022-02: Rock Paper Scissors</span>"
    ]
  },
  {
    "objectID": "2022/03/2022-03.html",
    "href": "2022/03/2022-03.html",
    "title": "2022-03: Rucksack Reorganization",
    "section": "",
    "text": "Part 1\nThis already looks rough. readLines because it’s strings.\nUltimately not too bad. I got to make use of \\(x) for an anonymous function. I messed up the second half of the string and had it started at the end of the first half. I got docked a minute for the bad answer but then was able to fix it in time for resubmission.\ndata.frame(\"input\" = dt) %&gt;%\n  mutate(V1 = substr(input, 1, nchar(input) / 2),\n         V2 = substr(input, nchar(input) / 2 + 1, nchar(input))) %&gt;%\n  apply(1, \\(x) {\n    v1 &lt;- unlist(strsplit(x[\"V1\"], \"\"))\n    v2 &lt;- unlist(strsplit(x[\"V2\"], \"\"))\n    \n    return(v1[v1 %in% v2])\n  }) %&gt;%\n  sapply(\\(x) {\n    x &lt;- unique(x)\n    sum(which(letters == x), (which(LETTERS == x) + 26), na.rm = TRUE)\n  }) %&gt;%\n  sum()\n\n[1] 7811",
    "crumbs": [
      "2022",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>2022-03: Rucksack Reorganization</span>"
    ]
  },
  {
    "objectID": "2022/03/2022-03.html#part-2",
    "href": "2022/03/2022-03.html#part-2",
    "title": "2022-03: Rucksack Reorganization",
    "section": "Part 2",
    "text": "Part 2\nI struggled with creating the groups for some reason. Once I had that going, the rest was pretty easy.\n\ndata.frame(\"input\" = dt) %&gt;%\n  mutate(\"group\" = rep(1:(nrow(.) / 3), each = 3)) -&gt; dt2\n\nd2 &lt;- c()\nfor(g in unique(dt2$group)) {\n  d &lt;- dt2$input[dt2$group == g]\n  \n  v1 &lt;- unlist(strsplit(d[1], \"\"))\n  v2 &lt;- unlist(strsplit(d[2], \"\"))\n  v3 &lt;- unlist(strsplit(d[3], \"\"))\n    \n  d2 &lt;&lt;- c(d2, unique(v3[v3 %in% v1[v1 %in% v2]]))\n}\n\nsapply(d2, \\(x) {\n    x &lt;- unique(x)\n    sum(which(letters == x), (which(LETTERS == x) + 26), na.rm = TRUE)\n  }) %&gt;%\n  sum()\n\n[1] 2639",
    "crumbs": [
      "2022",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>2022-03: Rucksack Reorganization</span>"
    ]
  },
  {
    "objectID": "2022/04/2022-04.html",
    "href": "2022/04/2022-04.html",
    "title": "2022-04: Camp Cleanup",
    "section": "",
    "text": "Part 1\nThis looks bad at first, but it’s not.\nIt took me a minute to figure out how I wanted to work with the data ranges. I started with mutate then lapply then quickly switched to mapply. From there it wrote itself. I then second-guessed my answer and divided by two because I thought I was double reporting the ranges. I cost myself a minute :(\nmapply(\\(x, y) {\n  x &lt;- as.numeric(unlist(strsplit(x, \"-\")))\n  y &lt;- as.numeric(unlist(strsplit(y, \"-\")))\n  \n  all(x[1]:x[2] %in% y[1]:y[2]) | all(y[1]:y[2] %in% x[1]:x[2])\n}, dt$V1, dt$V2) |&gt;\n  unlist() |&gt;\n  table() %&gt;%\n  .[\"TRUE\"]\n\nTRUE \n 532",
    "crumbs": [
      "2022",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>2022-04: Camp Cleanup</span>"
    ]
  },
  {
    "objectID": "2022/04/2022-04.html#part-2",
    "href": "2022/04/2022-04.html#part-2",
    "title": "2022-04: Camp Cleanup",
    "section": "Part 2",
    "text": "Part 2\n38 seconds for part 2! I just had to change all to any.\n\nmapply(\\(x, y) {\n  x &lt;- as.numeric(unlist(strsplit(x, \"-\")))\n  y &lt;- as.numeric(unlist(strsplit(y, \"-\")))\n  \n  any(x[1]:x[2] %in% y[1]:y[2]) | any(y[1]:y[2] %in% x[1]:x[2])\n}, dt$V1, dt$V2) |&gt;\n  unlist() |&gt;\n  table() %&gt;%\n  .[\"TRUE\"]\n\nTRUE \n 854",
    "crumbs": [
      "2022",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>2022-04: Camp Cleanup</span>"
    ]
  },
  {
    "objectID": "2022/05/2022-05.html",
    "href": "2022/05/2022-05.html",
    "title": "2022-05: Supply Stacks",
    "section": "",
    "text": "Part 1\nThis was a big mess. It took me forever to read in the input and I eventually stumbled upon reaf_fwf because I couldn’t remember what a fixed-width file was. I kept looking for delimited readers and tried all sorts of crazy things.\nOnce I had the input in, it was relatively smooth sailing. I missed the part in part 1 where the boxes move one by one (oh part 2, how I wish I knew you then…) but once I had that fixed, I was looking pretty good. I got the test input working but then the real input wasn’t working. I eventually realized that my regex \\\\d was missing any numbers greater than 9 once that was fixed, everything else was pretty easy.\ndo_part(1)\n\nRows: 8 Columns: 9\n── Column specification ────────────────────────────────────────────────────────\n\nchr (9): X1, X2, X3, X4, X5, X6, X7, X8, X9\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nWarning in lapply(data.frame(str_match_all(tail(readLines(file_name),\n-(which(dt == : NAs introduced by coercion\n\n\n[1] \"ZBDRNPMVH\"",
    "crumbs": [
      "2022",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>2022-05: Supply Stacks</span>"
    ]
  },
  {
    "objectID": "2022/05/2022-05.html#part-2",
    "href": "2022/05/2022-05.html#part-2",
    "title": "2022-05: Supply Stacks",
    "section": "Part 2",
    "text": "Part 2\nAfter firing off a celebratory text message, I read part 2, deleted my rev and was done in 52 seconds!\n\ndo_part(2)\n\nRows: 8 Columns: 9\n── Column specification ────────────────────────────────────────────────────────\n\nchr (9): X1, X2, X3, X4, X5, X6, X7, X8, X9\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nWarning in lapply(data.frame(str_match_all(tail(readLines(file_name),\n-(which(dt == : NAs introduced by coercion\n\n\n[1] \"WDLPFNNNB\"",
    "crumbs": [
      "2022",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>2022-05: Supply Stacks</span>"
    ]
  },
  {
    "objectID": "2022/06/2022-06.html",
    "href": "2022/06/2022-06.html",
    "title": "2022-06: Tuning Trouble",
    "section": "",
    "text": "Part 1\nThis looks easy. Oh wait. I totally misread the problem…\nHardcoding everything will bite me in the butt later probably. Ultimately not too bad in hindsight.",
    "crumbs": [
      "2022",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>2022-06: Tuning Trouble</span>"
    ]
  },
  {
    "objectID": "2022/06/2022-06.html#part-1",
    "href": "2022/06/2022-06.html#part-1",
    "title": "2022-06: Tuning Trouble",
    "section": "",
    "text": "New\nOriginal\n\n\n\n\ndo_part(4)\n\nbdjq \n1578 \n\n\n\n\n\ndata.frame(\"w\" = dt,\n           \"x\" = c(dt[-1], NA),\n           \"y\" = c(dt[-1:-2], NA, NA),\n           \"z\" = c(dt[-1:-3], NA, NA, NA)) |&gt;\n  mutate(marker = paste0(w, x, y, z, sep = \"\")) |&gt;\n  apply(1, function(x) {\n    max(table(strsplit(x[\"marker\"], \"\")))\n  }) -&gt; tmp\n(which(tmp == 1) + 3)[1]\n\n[1] 1578",
    "crumbs": [
      "2022",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>2022-06: Tuning Trouble</span>"
    ]
  },
  {
    "objectID": "2022/06/2022-06.html#part-2",
    "href": "2022/06/2022-06.html#part-2",
    "title": "2022-06: Tuning Trouble",
    "section": "Part 2",
    "text": "Part 2\nWell, well, well. Hardcoding is never a good move. Took a bit of time to get it figured out, but I got there in the end.\n\n\nNew\nOriginal\n\n\n\n\ndo_part(14)\n\nmdcbnwqgshpvfj \n          2178 \n\n\n\n\n\nget_vec &lt;- function(vec, place) {\n  if (place == 0) { return(vec) }\n  c(vec[-1:(-place)], rep(NA, place))\n}\n\nlapply(0:13, function(x) {\n  get_vec(dt, x)\n}) |&gt;\n  data.frame() |&gt;\n  `colnames&lt;-`(paste0(\"X\", 1:14)) %&gt;%\n  apply(1, function(x) {\n    paste0(x, collapse = \"\")\n  }) |&gt;\n  sapply(function(x) {\n    max(table(strsplit(x, \"\")))\n  }) -&gt; tmp\n(which(tmp == 1) + 13)[1]\n\nmdcbnwqgshpvfj \n          2178",
    "crumbs": [
      "2022",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>2022-06: Tuning Trouble</span>"
    ]
  },
  {
    "objectID": "2022/07/2022-07.html",
    "href": "2022/07/2022-07.html",
    "title": "2022-07: No Space Left On Device",
    "section": "",
    "text": "Part 1\nOh no. This will probably use recursion.\nMy first attempt I just kinda hoped I wouldn’t need recursion. It was silly, but a guy can dream. My next idea was to just create the file system and so that’s what I did. Rather than making the files the size it says, I just filled them with one line holding the size so that I could read it in later. Getting the instructions fleshed out wasn’t too bad. It reminds me a lot of my Cat Simulator 2019 project from Intro to UNIX.\ndir.create(\"here_we_go\")\n\nWarning in dir.create(\"here_we_go\"): 'here_we_go' already exists\n\nsetwd(paste0(wd, \"/here_we_go\"))\n\ninvisible(sapply(dt, \\(x) {\n  if(grepl(\"dir \", x)) {\n    d &lt;- str_remove(x, \"dir \")\n    if (!dir.exists(d)) { dir.create(d) }\n  } else if (grepl(\"[0-9]+\", x)) {\n    f &lt;- paste0(str_remove_all(x, \"[0-9 \\\\.]\"), \".txt\")\n    if (!file.exists(f)) {\n      f &lt;- file(f)\n      content &lt;-\n        paste0(as.numeric(paste0(\n          str_extract_all(x, \"\\\\d\", simplify = TRUE), collapse = \"\"\n        )), \"\\n\")\n      cat(content, file = f)\n      close(f)\n    }\n  } else if (grepl(\"\\\\$ cd \\\\.\\\\.\", x)) {\n    setwd(\"../\")\n  } else if (grepl(\"\\\\$ cd \\\\w\", x)) {\n    d &lt;- str_remove(x, \"\\\\$ cd \")\n    if (!dir.exists(d)) { dir.create(d) }\n    setwd(d)\n  } else if (grepl(\"\\\\$ cd /\", x)) {\n    setwd(paste0(wd, \"/here_we_go\")) \n  } else if (!grepl(\"\\\\$ ls|\\\\$ cd /\", x)) { print(x) }\n}))\nsetwd(wd)\nGetting this bit working was a pain, but I’m really pleased with it. I had it working on the test input for a while before the real input which was excruciating, but I eventually tracked the problem down to my regex where I remove any file paths. In my earlier step where I repeated file paths then unlisted, any duplicates are assigned a trailing number. In the test input, this number was never more than one digit. In my regex, I was only looking for one digit and so any paths with no digits or more than one digit were missed. With that out of the way, it still doesn’t work. Eventually I realized I was collapsing my paths backwards so all my folder sizes were reversed. Fixing that eventually got me where I needed to be.\nv &lt;- \npaste0(\"here_we_go/\", list.files(\"here_we_go\", recursive = TRUE)) |&gt;\n  sapply(\\(x) {\n    count &lt;- str_count(x, \"/\") - 1\n    count &lt;- ifelse(count == 0, 1, count)\n    rep(x, count)\n  }) \npaths &lt;-\n  v |&gt;\n  lapply(\\(x) {\n    xx &lt;- str_remove(x, \"here_we_go/\")\n    sapply(0:(length(x) - 1), \\(x) {\n      if (x == 0) { return(xx) }\n      m &lt;- str_split(xx, \"/\")[[1]]\n      m &lt;- m[-(length(m) - (1:x))]\n      m &lt;- paste0(m, collapse = \"/\")\n      return(m)\n    }) |&gt;\n      unlist() |&gt;\n      unique()\n  }) |&gt;\n  unlist() |&gt;\n  unname()\n\nfiles &lt;- \n  v |&gt;\n  unlist() |&gt;\n  sapply(\\(x) {\n    x &lt;- as.numeric(readLines(x))\n  }) |&gt;\n  data.frame() |&gt;\n  rownames_to_column(var = \"path\") |&gt;\n  `colnames&lt;-`(c(\"full_path\", \"size\")) |&gt;\n  cbind(paths) |&gt;\n  mutate(path = str_remove(paths, \"/\\\\w*\\\\.txt\\\\d*\"))\n  # filter(grepl(\"\\\\.txt\", path)) |&gt;\n  # mutate(path = str_remove(path, \"/\\\\w*\\\\.txt[0-9]?\"))\nfiles |&gt;\n  group_by(path) |&gt;\n    summarise(size = sum(size)) |&gt;\n    arrange(path, .by_group = TRUE) |&gt;\n  ungroup() |&gt;\n  filter(size &lt;= 100000) |&gt;\n  pull(size) |&gt;\n  sum()\n\n[1] 1297683",
    "crumbs": [
      "2022",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>2022-07: No Space Left On Device</span>"
    ]
  },
  {
    "objectID": "2022/07/2022-07.html#part-2",
    "href": "2022/07/2022-07.html#part-2",
    "title": "2022-07: No Space Left On Device",
    "section": "Part 2",
    "text": "Part 2\nThis wasn’t too bad. Just took a bit to make the changes needed from part 1. I was briefly stuck when just grouping by path in the second pipeline, but adding the level grouping took care of it and I was good to go!\n\nf &lt;- \n  files |&gt;\n  select(paths, size) |&gt;\n  mutate(path = str_remove(paths, \"/\\\\w*\\\\.txt\\\\d*\")) |&gt;\n  select(-paths) |&gt;\n  unique() |&gt;\n  group_by(path) |&gt;\n    summarise(size = sum(size)) |&gt;\n    ungroup() |&gt;\n  mutate(level = str_count(path, \"/\"))\nhome &lt;- sum(f$size[f$level == 0])\n\nf |&gt;\n  group_by(path, level) |&gt;\n    summarise(size = sum(size), .groups = \"keep\") |&gt;\n    arrange(path, .by_group = TRUE) |&gt;\n    ungroup() |&gt;\n  mutate(free = 70000000 - home,\n         sort = size + free) |&gt;\n  arrange(desc(sort), size) |&gt;\n  filter(sort &gt; 30000000) |&gt;\n  tail(1) |&gt;\n  pull(size)\n\n[1] 5756764",
    "crumbs": [
      "2022",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>2022-07: No Space Left On Device</span>"
    ]
  },
  {
    "objectID": "2022/08/2022-08.html",
    "href": "2022/08/2022-08.html",
    "title": "2022-08: Treetop Tree House",
    "section": "",
    "text": "Part 1\nOh no. I always do hate grid based ones.\nThis was a weird one. I’m writing this the day after I wrote the code, and I have no clue what my thought process was. I did it reasonably quickly so I’m not too unhappy with it.\nmm &lt;- \n  dt |&gt;\n  as.matrix() |&gt;\n  as.character() |&gt;\n  str_split(\"\", simplify = TRUE) |&gt;\n  apply(c(1, 2), as.numeric)\n\ngrid &lt;- expand.grid(\"col\" = 1:ncol(mm), \"row\" = 1:nrow(mm))\n\nm &lt;-\n  mapply(\\(x, y) {\n    tree &lt;- mm[y, x]\n    \n    if (x == 1 | x == ncol(mm) | y == 1 | y == nrow(mm)) { return(c(x, y)) }\n    \n    if (all(mm[(y + 1):nrow(mm), x] &lt; tree, na.rm = TRUE) |\n        all(mm[1:(y - 1), x] &lt; tree, na.rm = TRUE) |\n        all(mm[y, 1:(x - 1)] &lt; tree, na.rm = TRUE) |\n        all(mm[y, (x + 1):ncol(mm)] &lt; tree, na.rm = TRUE)) {\n      return(c(x, y))\n    }\n  }, grid$col, grid$row)\n\nm[!sapply(m, is.null)] %&gt;%\n  do.call(rbind, .) |&gt;\n  data.frame() |&gt;\n  `colnames&lt;-`(c(\"col\", \"row\")) -&gt; mi\nnrow(mi)\n\n[1] 1717",
    "crumbs": [
      "2022",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>2022-08: Treetop Tree House</span>"
    ]
  },
  {
    "objectID": "2022/08/2022-08.html#part-2",
    "href": "2022/08/2022-08.html#part-2",
    "title": "2022-08: Treetop Tree House",
    "section": "Part 2",
    "text": "Part 2\nThis was a mess. I kept trying to be smart about it and wasted so much time. I mostly had trouble working with patterns like [5050] where the first five can see both the zero and the second five, but not the second zero. This meant that x &lt; 5 ignored the five, and x &lt;= 5 would keep going and read over the remaining zero. Even though I ended up hard-coding everything, I’m rather pleased with how neat it is. I’m sure I could move more of it to functions, but it wouldn’t be too much prettier, if any.\n\nscenic &lt;- matrix(NA, nrow(mm), ncol(mm))\n\nchecker &lt;- function(vec, i, tree, dir) {\n  vec &lt;- detect_index(vec, \\(.x) { .x &gt;= tree }) \n  if (dir == -1) { vec &lt;- ifelse(vec == 0, i - 1, vec) }\n  else { vec &lt;- ifelse(vec == 0, ncol(mm) - i, vec) }\n  vec\n}\n\nmapply(\\(y, x) {\n  tree &lt;- mm[y, x]\n  up &lt;- NA; down &lt;- NA; left &lt;- NA; right &lt;- NA\n  if (y == 1) { up &lt;- 0 }; if (y == nrow(mm)) { down &lt;- 0 }\n  if (x == 1) { left &lt;- 0}; if (x == ncol(mm)) { right &lt;- 0 }\n  \n  rowMin &lt;- ifelse(y - 1 &lt; 1, 1, y - 1); rowMax &lt;- ifelse(y + 1 &gt; nrow(mm), nrow(mm), y + 1)\n  colMin &lt;- ifelse(x - 1 &lt; 1, 1, x - 1); colMax &lt;- ifelse(x + 1 &gt; ncol(mm), ncol(mm), x + 1)\n  \n  yMin &lt;- ifelse(y - 1 &lt; 1, 1, y - 1); yMax &lt;- ifelse(y + 1 &gt; nrow(mm), nrow(mm), y + 1)\n  xMin &lt;- ifelse(x - 1 &lt; 1, 1, x - 1); xMax &lt;- ifelse(x + 1 &gt; ncol(mm), ncol(mm), x + 1)\n  \n  if (is.na(up)) { up &lt;- checker(rev(mm[1:yMin, x]), y, tree, -1) }\n  if (is.na(left)) { left &lt;- checker(rev(mm[y, 1:xMin]), x, tree, -1) }\n  if (is.na(right)) { right &lt;- checker(mm[y, xMax:ncol(mm)], x, tree, 1) }\n  if (is.na(down)) { down &lt;- checker(mm[rowMax:nrow(mm), x], y, tree, 1) }\n  \n  scene &lt;- c(up, left, right, down)\n  scenic[y, x] &lt;&lt;- prod(scene[scene != 0])\n}, grid$row, grid$col) |&gt; invisible()\nmax(scenic)\n\n[1] 321975",
    "crumbs": [
      "2022",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>2022-08: Treetop Tree House</span>"
    ]
  },
  {
    "objectID": "2022/10/2022-10.html",
    "href": "2022/10/2022-10.html",
    "title": "2022-10: Cathode-Ray Tube",
    "section": "",
    "text": "Part 1\nOh. This looks a lot like last year’s day one.\nPart 1 wasn’t too bad. I was a really big dummy and forgot to download the test input then was trying to check my real input as the test input which didn’t work. Other than that, I’m really happy I got to use mistlecode::expand_directions which I only wrote a few hours prior. I did have to make some live modifications, but nothing crazy. Once everything was mostly right, I had a problem where the first five signals were correct, but the last wasn’t. I eventually realized that I needed to lead the add values and that got everything sorted.\ndt &lt;-\n  dt |&gt;\n  mutate(\"mag\" = ifelse(X1 == \"noop\", 1, 2)) |&gt;\n  select(\"dir\" = \"X1\", \"mag\", \"X2\") |&gt;\n  mutate(ins = row_number()) |&gt;\n  expand_directions(preserve_data = TRUE) |&gt;\n  data.table()\n\ndt$dup = duplicated(dt$ins, fromLast = TRUE)\ndt$X2 = ifelse(dt$dup, NA, dt$X2)\n\ndt$X3 &lt;- lead(dt$X2, 1)\n\nsapply(c(20, 60, 100, 140, 180, 220), \\(x) {\n  sum(1, sum(dt[1:x, \"X3\"], na.rm = TRUE)) * x\n}) |&gt;\n  sum()\n\n[1] 14260",
    "crumbs": [
      "2022",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>2022-10: Cathode-Ray Tube</span>"
    ]
  },
  {
    "objectID": "2022/10/2022-10.html#part-2",
    "href": "2022/10/2022-10.html#part-2",
    "title": "2022-10: Cathode-Ray Tube",
    "section": "Part 2",
    "text": "Part 2\nThis was an absolute mess. I didn’t understand the question at all and still don’t really get it. The difference between what I had and what I thought I should have made the solution relatively clear, but only after struggling with it for hours. I do like ggplot-able solutions though. Those are always nice.\n\nm &lt;- matrix(\" \", 6, 40)\n\ndt$X2 &lt;- ifelse(is.na(dt$X2), 0, dt$X2)\ndt$cumsum &lt;- sapply(1:240, \\(x) { sum(1, sum(dt[1:x, \"X2\"], na.rm = TRUE)) })\n\nm &lt;-\n  sapply(1:240, \\(x) {\n    forty &lt;- (x %/% 40)\n    cumsum &lt;- c(dt$cumsum[x] - 1, dt$cumsum[x], dt$cumsum[x] + 1)\n    sprite_pos &lt;- cumsum[!is.na(cumsum)]\n    if (any((sprite_pos + (40 * forty)) == x)) {\n      sprite_pos &lt;- suppressWarnings(min(which(sprite_pos == x), na.rm = TRUE))\n      if (sprite_pos == 1) { sprite_pos &lt;- cumsum[1] }\n      else if (sprite_pos == 3) { sprite_pos &lt;- cumsum[3] }\n      else { sprite_pos &lt;- cumsum[2] }\n      return(sprite_pos + (40 * forty))\n    }\n    return(NA)\n  })\n\nm[240] &lt;- 0\n\nmatrix_to_coords(matrix(m, 6, 40, byrow = TRUE)) |&gt;\n  data.frame() |&gt;\n  filter(!is.na(data)) |&gt;\n  mutate(col = ifelse(col == 40, 0, col)) |&gt;\n  ggplot() +\n  geom_point(aes(x = col, y = -row), size = 5, shape = 15) +\n  coord_fixed()",
    "crumbs": [
      "2022",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>2022-10: Cathode-Ray Tube</span>"
    ]
  },
  {
    "objectID": "2022/11/2022-11.html",
    "href": "2022/11/2022-11.html",
    "title": "2022-11: Monkey in the Middle",
    "section": "",
    "text": "Part 1\nOh no. I’m going to bed.\nThis was so much fun! I dipped my toes into S3 classes, made a useful function factory, and did some recursion. I had a bit of trouble making sure my list of monkeys was getting passed around properly and returned because loops can’t change objects in the global environment. That said, I have a bad feeling about part 2.\noperation &lt;- function(op, val) {\n  function(old) {\n    if (val == \"old\") { val &lt;- as.integer(old) } \n    else { val &lt;- as.integer(val) }\n    \n    if (op == \"*\") { val &lt;- old * val }\n    else if (op == \"+\") { val &lt;- old + val }\n    \n    return(val)\n  }\n}\n\nnew_monkey &lt;- function(dt, x) {\n  name &lt;- str_extract(dt[1,\"dt\"], \"\\\\d+\")\n  items &lt;- \n    str_split(dt[2,\"dt\"], \":|,\", simplify = TRUE)[1,-1] |&gt; as.numeric()\n  opp &lt;- \n    str_split(dt[3, \"dt\"], \"=\", simplify = TRUE)[1,2] |&gt;\n    str_match(\" (new|old) (\\\\+|\\\\-|\\\\*|\\\\/) (old|\\\\d+)\")\n  op_op &lt;- opp[1,3]\n  op_num &lt;- ifelse(opp[1,4])\n  op &lt;- operation(op = opp[1,3], val = opp[1,4])\n  test &lt;- str_extract(dt[4,\"dt\"], \"\\\\d+\") |&gt; as.integer()\n  case_true &lt;- str_extract(dt[5,\"dt\"], \"\\\\d+\")\n  case_false &lt;- str_extract(dt[6,\"dt\"], \"\\\\d+\")\n  x &lt;- list(\n    \"name\" = name,\n    \"items\" = items,\n    \"operation\" = op,\n    \"test\" = test,\n    \"case_true\" = case_true,\n    \"case_false\" = case_false,\n    \"inspections\" = 0\n  )\n  structure(x, class = \"monkey\")\n}\n\nmonkeys &lt;- \n  lapply(unique(dt$monkey), \\(m) { \n    new_monkey(dt[dt$monkey == m,], m) \n  })\nnames(monkeys) &lt;- sapply(monkeys, \\(m) m$name)\n\nprocess_items &lt;- function(item, monkey, these_monkeys) {\n  if (is.na(monkey$items[item]) | \n      item &gt; length(monkey$items)) { return(these_monkeys) }\n  worry_level &lt;- monkey$operation(monkey$items[item])\n  worry_level &lt;- floor(worry_level / 3)\n  if (worry_level %% monkey$test == 0) {\n    case_true &lt;- \n      c(these_monkeys[[monkey$case_true]]$items, worry_level)\n    these_monkeys[[monkey$case_true]]$items &lt;- \n      case_true[!is.na(case_true)]\n  } else {\n    case_false &lt;- \n      c(these_monkeys[[monkey$case_false]]$items, worry_level)\n    these_monkeys[[monkey$case_false]]$items &lt;- \n      case_false[!is.na(case_false)]\n  }\n  process_items(item + 1, monkey, these_monkeys)\n}\n\nprocess_monkey &lt;- function(i, these_monkeys) {\n  if (i == length(monkeys) + 1) { return(these_monkeys) }\n  monkey &lt;- these_monkeys[[i]]\n  these_monkeys &lt;- process_items(1, monkey, these_monkeys)\n  monkey$inspections &lt;- \n    sum(monkey$inspections, length(monkey$items), na.rm = TRUE)\n  monkey$items &lt;- as.numeric(NA)\n  these_monkeys[[i]] &lt;- monkey\n  process_monkey(i + 1, these_monkeys)\n}\n\nround &lt;- function(these_monkeys, round) {\n  if (round == round_max + 1) { return(these_monkeys) }\n  these_monkeys &lt;- process_monkey(1, these_monkeys)\n  round(these_monkeys, round + 1)\n}\nround_max &lt;- 20\nm &lt;- round(monkeys, 1)\nsapply(m, \\(m) m$inspections) |&gt;\n  sort(decreasing = TRUE) |&gt;\n  head(2) |&gt;\n  prod()\n\n[1] 316888",
    "crumbs": [
      "2022",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>2022-11: Monkey in the Middle</span>"
    ]
  },
  {
    "objectID": "2022/11/2022-11.html#part-2",
    "href": "2022/11/2022-11.html#part-2",
    "title": "2022-11: Monkey in the Middle",
    "section": "Part 2",
    "text": "Part 2\nI want to scream. I submitted my answer just to see and it’s right, even though the test input was wrong. I could’ve submitted yesterday 😭 So many hours devoted to these monkeys for nothing…\nI figured out the worry_level %% prod(tests) thing pretty quick after part 1, but it took a full day because the test input never lined up, even if I got super close. I still want to figure out why that is, but for now I’m just happy to have the star.\n\nprocess_items &lt;- function(item, monkey, these_monkeys) {\n  if (is.na(monkey$items[item]) | \n      item &gt; length(monkey$items)) { return(these_monkeys) }\n  worry_level &lt;- monkey$operation(monkey$items[item])\n  case &lt;- (worry_level %% monkey$test) == 0\n  worry_level &lt;- worry_level %% prod(tests)\n  if (case) {\n    case_true &lt;- \n      c(these_monkeys[[monkey$case_true]]$items, worry_level)\n    these_monkeys[[monkey$case_true]]$items &lt;- \n      case_true[!is.na(case_true)]\n  } else {\n    case_false &lt;- \n      c(these_monkeys[[monkey$case_false]]$items, worry_level)\n    these_monkeys[[monkey$case_false]]$items &lt;- \n      case_false[!is.na(case_false)]\n  }\n  process_items(item + 1, monkey, these_monkeys)\n}\n\nm &lt;- monkeys\ntests &lt;- sapply(m, \\(m) m$test)\n\nround_max &lt;- 1\ni &lt;- 1\nwhile (i &lt;= 10000) {\n  m &lt;- process_monkey(1, m)\n  i &lt;- i + 1\n}\n\nsapply(m, \\(m) m$inspections) |&gt;\n  sort(decreasing = TRUE) |&gt;\n  head(2) |&gt;\n  prod()\n\n[1] 35270398814",
    "crumbs": [
      "2022",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>2022-11: Monkey in the Middle</span>"
    ]
  },
  {
    "objectID": "2022/14/2022-14.html",
    "href": "2022/14/2022-14.html",
    "title": "2022-14: Regolith Reservoir",
    "section": "",
    "text": "Part 1\nThis doesn’t actually look too terrible.\nThis was a standalone in Part 1, but I moved it to a function for Part 2.\nFirst step is always making the matrix way bigger than it needs to be and filling it. Because everything’s a straight line, I can just match the current pair to the next pair and draw a line, essentially. Super easy with matrices. I want to check the bottom row for sand and if there isn’t sand, drop a new one from (1,500) (hooray for R being y,x and non-zero indexed!). Instead of iterating through the whole drop, I can just get the index of the last row in column 500 where there isn’t anything. This saves some computation. If I’m at the bottom, write a piece of sand. From there it’s just iterating over everything just like the instructions say. Lastly, get the amount of sand in the cave then subtract one to account for the last piece of sand that trips the loop.\nmaxCol &lt;-\n  dt |&gt;\n  str_extract_all(\"[0-9]{1,3},\") |&gt;\n  suppressWarnings() |&gt;\n  unlist() |&gt;\n  str_remove_all(\",\") |&gt;\n  as.numeric() |&gt;\n  max()\ncave &lt;- createCave(maxCol, maxCol)\nwhile(!any(cave[nrow(cave),] == \"o\")) {\n  col &lt;- 500\n  row &lt;- which(cave[,col] != \" \")[1] - 1\n  breakFlag &lt;- FALSE\n  repeat {\n    if (row + 1 &gt; nrow(cave)) { breakFlag &lt;- TRUE }\n    else {\n      if (cave[row + 1, col] == \" \") {\n        row &lt;- row + 1\n      } else if (col &gt;= 2 & cave[row + 1, col - 1] == \" \") {\n        row &lt;- row + 1; col &lt;- col - 1\n      } else if (col &lt; ncol(cave) & cave[row + 1, col + 1] == \" \") {\n        row &lt;- row + 1; col &lt;- col + 1\n      } else { breakFlag &lt;- TRUE }\n    }\n    if (breakFlag) {\n      cave[row, col] &lt;- \"o\"\n      break\n    }\n  }\n}\nwhich(cave == \"o\") |&gt;\n  length() |&gt;\n  sum(-1)\n\n[1] 961\nmatrix_to_coords(cave) |&gt;\n  data.frame() |&gt;\n  filter(data != \" \") |&gt;\n  mutate(row = as.integer(row), col = as.integer(col)) |&gt;\n  filter(row &lt;= 200) |&gt;\n  ggplot() +\n  geom_tile(aes(x = col, y = -row, fill = data))",
    "crumbs": [
      "2022",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>2022-14: Regolith Reservoir</span>"
    ]
  },
  {
    "objectID": "2022/14/2022-14.html#part-2",
    "href": "2022/14/2022-14.html#part-2",
    "title": "2022-14: Regolith Reservoir",
    "section": "Part 2",
    "text": "Part 2\nOkay. I need to get the highest row, I can’t just make a massive matrix. Then add another row on top of where everything was drawn that will capture the top of the pyramid. Also, make a new column placeholder that can be added if I need to expand to the left or right. Because of that, I also need to track where column 500 is. If I’m going to have a column collision, I need to expand in that direction. Then, it’s business as usual, but now I’m checking to see if that original start point is full, no matter where it is. Lastly, don’t subtract one because the top grain does count now.\n\nmaxRow &lt;-\n  dt |&gt;\n  str_extract_all(\",[0-9]{1,3}\") |&gt;\n  suppressWarnings() |&gt;\n  unlist() |&gt;\n  str_remove_all(\",\") |&gt;\n  as.numeric() |&gt;\n  max()\ncave &lt;- createCave(maxRow + 1, maxCol)\ncave &lt;- rbind(matrix(\" \", 1, ncol(cave)), cave)\nnewCol &lt;- matrix(\" \", nrow(cave), 1)\nstartCol &lt;- 500\nwhile (cave[1,startCol] != \"o\") {\n  col &lt;- startCol\n  row &lt;- which(cave[,col] != \" \")[1] - 1\n  breakFlag &lt;- FALSE\n  repeat {\n    if (col == 2) { \n      cave &lt;- cbind(newCol, cave)\n      startCol &lt;- startCol + 1\n    } else if (col == ncol(cave) - 1) { cave &lt;- cbind(cave, newCol) }\n    \n    if (row + 1 &gt; nrow(cave)) { \n      breakFlag &lt;- TRUE \n    } else {\n      if (cave[row + 1, col] == \" \") {\n        row &lt;- row + 1\n      } else if (col &gt;= 2 & cave[row + 1, col - 1] == \" \") {\n        row &lt;- row + 1; col &lt;- col - 1\n      } else if (col &lt; ncol(cave) & cave[row + 1, col + 1] == \" \") {\n        row &lt;- row + 1; col &lt;- col + 1\n      } else { breakFlag &lt;- TRUE }\n    }\n    if (breakFlag) {\n      cave[row, col] &lt;- \"o\"\n      break\n    }\n  }\n}\nwhich(cave == \"o\") |&gt;\n  length()\n\n[1] 26375\n\n\n\nmatrix_to_coords(cave) |&gt;\n  data.frame() |&gt;\n  filter(data != \" \") |&gt;\n  mutate(row = as.integer(row), col = as.integer(col)) |&gt;\n  filter(row &lt;= maxRow) |&gt;\n  ggplot() +\n  geom_tile(aes(x = col, y = -row, fill = data))",
    "crumbs": [
      "2022",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>2022-14: Regolith Reservoir</span>"
    ]
  },
  {
    "objectID": "2022/20/2022-20.html",
    "href": "2022/20/2022-20.html",
    "title": "2022-20: Grove Positioning System",
    "section": "",
    "text": "Part 1\nThis looks too good to be true!\nPretty straightforward, all things considered. Getting vectors to wrap is always a pain. I also missed the bit about the numbers being after zero, but a quick which took care of that.\npos &lt;- 1:length(dt)\n\nshift &lt;- function(pos, x, shift) {\n  if (x == 0) { return(pos) }\n  p &lt;- which(pos == x)\n  pos &lt;- pos[-p]\n  after &lt;- (p - 1 + shift) %% length(pos)\n  after &lt;- ifelse(after == 0, length(pos), after)\n  append(pos, x, after = after)\n}\n\nfor(i in 1:length(dt)) { pos &lt;- shift(pos, i, dt[i]) }\n\nget_sum &lt;- function(dt, pos) {\n  zero &lt;- which(dt[pos] == 0)\n  sapply(c(1e3, 2e3, 3e3), \\(x) {\n    x &lt;- (x + zero) %% length(pos)\n    x &lt;- ifelse(x == 0, length(pos), x)\n    dt[pos[x]]\n  }) |&gt;\n    sum()\n}\n\nget_sum(dt, pos)\n\n[1] 4151",
    "crumbs": [
      "2022",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>2022-20: Grove Positioning System</span>"
    ]
  },
  {
    "objectID": "2022/20/2022-20.html#part-2",
    "href": "2022/20/2022-20.html#part-2",
    "title": "2022-20: Grove Positioning System",
    "section": "Part 2",
    "text": "Part 2\nBasically the same as Part 1. I was blessed with no integer overflows so that’s nice. Just multiply the vector by a constant, nest the for loop, then get the sum using the function from Part 1.\n\nkey &lt;- 811589153\ndt2 &lt;- dt * key\npos2 &lt;- 1:length(dt)\n\nfor(j in 1:10) {\n  for (i in 1:length(dt2)) { pos2 &lt;- shift(pos2, i, dt2[i]) }\n}\n\nget_sum(dt2, pos2)\n\n[1] 7848878698663",
    "crumbs": [
      "2022",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>2022-20: Grove Positioning System</span>"
    ]
  },
  {
    "objectID": "2022/21/2022-21.html",
    "href": "2022/21/2022-21.html",
    "title": "2022-21: Monkey Math",
    "section": "",
    "text": "Part 1\nThis…doesn’t actually look too bad. Part 2 will probably be a nightmare.\nLet’s take a chance to use S7 for the first time! I can build on the bits I learned with S3 in 2022-11. The idea to use a vector of monkey names (index) made it really easy to make sure I was pulling info from the right monkeys, rather than needing to iterate over the entire list. There’s probably a better approach overall with a more recursive solution, but this seems to work fine for Part 1, although I’m worried about Part 2.\nNote (2023-04-23): I just updated to R 4.3 and the latest version of R7 which is now S7 and I was unable to run the previous version which used recursion due to a C-stack error. I swapped over to a while loop based version and that seems to be working fine.\nmonkey &lt;- new_class(\n  name = \"monkey\",\n  properties = list(\n    name = class_character,\n    val = class_any,\n    op = class_character\n  )\n)\n\nnew_monkey &lt;- function(x) {\n  if (!is.na(suppressWarnings(as.numeric(x[2])))) {\n    val &lt;- as.numeric(x[2])\n    op &lt;- NA_character_\n  } else {\n    val &lt;- NA\n    op &lt;- x[2]\n  }\n  monkey(\n    name = x[1],\n    val = val,\n    op = op\n  )\n}\n\nmonkeys &lt;- lapply(dt, new_monkey)\nmasterMonkeys &lt;- monkeys\nindex &lt;- sapply(monkeys, \\(x) x@name)\n\nmonkey_math &lt;- function(monkeys, op) {\n  m1 &lt;- monkeys[[which(index == op[1])]]@val\n  m2 &lt;- monkeys[[which(index == op[3])]]@val\n  \n  if (!is.na(m1) & !is.na(m2)) {\n    if (op[2] == \"+\") { m1 + m2 }\n    else if (op[2] == \"-\") { m1 - m2 }\n    else if (op[2] == \"*\") { m1 * m2 }\n    else if (op[2] == \"/\") { m1 / m2 }\n  } else { return(NA_integer_) }\n}\n\nm &lt;- monkeys\nbreakFlag &lt;- FALSE\nwhile(!breakFlag) {\n  n &lt;- 1\n  while (n &lt;= length(monkeys)) {\n    if (is.na(monkeys[[n]]@val)) {\n      val &lt;- str_split_1(monkeys[[n]]@op, \" \")\n      monkeys[[n]]@val &lt;- monkey_math(monkeys, val)\n    }\n    if (monkeys[[n]]@name == \"root\" & !is.na(monkeys[[n]]@val)) {\n      breakFlag &lt;- TRUE\n      break\n    }\n    n &lt;- n + 1\n  }\n}\nmonkeys[[n]]@val\n\n[1] 93813115694560",
    "crumbs": [
      "2022",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>2022-21: Monkey Math</span>"
    ]
  },
  {
    "objectID": "2022/21/2022-21.html#part-2",
    "href": "2022/21/2022-21.html#part-2",
    "title": "2022-21: Monkey Math",
    "section": "Part 2",
    "text": "Part 2\nI tried brute-forcing it… It took a while to fully figure out what I wanted to do, but the idea behind just making a giant equation then solving for humn was there early on. I started by expanding the input by replacing monkeys with their value if they had one or operation if they didn’t. I then replaced all the monkeys with their values, just like in Part 1. This left me with a giant expression where the only variable was humn. I just wasn’t sure how to actually solve equations in R so I kept trying to brute-force it, which kept on not working. I eventually found the Ryacas package which made quick work of everything.\n\nmonkeys &lt;- lapply(dt, new_monkey)\n\nroot_op &lt;- \n  str_extract(monkeys[[which(index == \"root\")]]@op, \"(\\\\+|\\\\-|\\\\*|\\\\/)\")\nmonkeys[[which(index == \"root\")]]@op &lt;- \n  gsub(paste0(\"\\\\\", root_op), \"=\", monkeys[[which(index == \"root\")]]@op)\n\nm1 &lt;- str_split_1(monkeys[[which(index == \"root\")]]@op, \" = \")\nm2 &lt;- m1[2]\nm1 &lt;- m1[1]\n\nreplace_monkey &lt;- function(m) {\n  w &lt;- which(index == m)\n  if (length(w) == 0) { return(m) }\n  v &lt;- monkeys[[w]]@val\n  if (is.na(v)) { return(paste0(\"( \", monkeys[[which(index == m)]]@op, \" )\")) }\n  return(paste0(\"( \", v, \" )\"))\n}\n\n# https://stackoverflow.com/a/14838753\nquotemeta &lt;- function(string) { str_replace_all(string, \"(\\\\W)\", \"\\\\\\\\\\\\1\") }\n\nreduce_string &lt;- function(mm, pattern) {\n  r &lt;-\n    str_extract_all(mm, pattern) |&gt;\n    unlist() |&gt;\n    sapply(\\(r) {\n      if (grepl(\"h\", r)) { return(r) }\n      else { eval(parse(text = r)) }\n    })\n  \n  for (i in 1:length(r)) {\n    mm &lt;- str_replace_all(mm, quotemeta(names(r)[i]), as.character(r[i]))\n  }\n  return(mm)\n}\n\nprocess_string &lt;- function(m) {\n  while (any(grepl(\"([^(h)][a-z])\", m))) {\n    m &lt;- \n      sapply(m, \\(mm) { replace_monkey(mm) }) |&gt;\n      paste0(collapse = \" \") |&gt;\n      str_split_1(\" \")\n  }\n  m &lt;- paste0(m, collapse = \"\")\n  oldM &lt;- 0\n  while (length(m) == 1 && oldM != m) {\n    oldM &lt;- m\n    m &lt;- reduce_string(m, \"\\\\((\\\\d+|h)\\\\)[\\\\+|\\\\-|\\\\*|\\\\/]\\\\((\\\\d+|h)\\\\)\")\n  }\n  return(oldM)\n}\n\nmonkeys[[which(index == \"humn\")]]@val &lt;- \"h\"\nmm1 &lt;- process_string(m1)\nmm2 &lt;- process_string(m2)\n\npaste(\n    reduce_string(mm1, \"\\\\((\\\\d+|h)\\\\)\"), \n    \"==\", \n    reduce_string(mm2, \"\\\\((\\\\d+|h)\\\\)\")\n  ) %&gt;%\n  Ryacas::y_fn(\"Solve\", \"h\") |&gt;\n  Ryacas::yac_str() |&gt;\n  str_extract(\"\\\\d+\") |&gt;\n  as.numeric()\n\n[1] 3910938071092",
    "crumbs": [
      "2022",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>2022-21: Monkey Math</span>"
    ]
  },
  {
    "objectID": "2022/25/2022-25.html",
    "href": "2022/25/2022-25.html",
    "title": "2022-25: Full of Hot Air",
    "section": "",
    "text": "Part 1\nThis doesn’t look too terrible. The numbering system is weird, but I can work with it. It seems too easy for Day 25.\nI was able to get Bob’s number pretty quickly. Then I realized I hadn’t fully read the question and I had to translate Bob’s number back into SNAFU. I had a few ideas on how to do it, but really struggled for some reason. I tried a recursive method first, but quickly hit C stack limits and couldn’t quite wrap my mind around how to brute-force it. I did realize that I could jump start the guessing by finding the smallest number greater than Bob’s that’s made entirely out of 2s. By starting there, I could subtract towards my goal, rather than trying to add, which would have been much more difficult. It was then just a matter of getting the code straight in my head, and using the un_snafu function to check my values every cycle.\nun_snafu &lt;- function(x) {\n  x &lt;- \n    x |&gt;\n    str_split_1(\"\") |&gt;\n    rev()\n\n  x &lt;- case_when(\n    x == \"-\" ~ -1,\n    x == \"=\" ~ -2,\n    TRUE ~ as.numeric(x)\n  )\n\n  sum((5 ^ (0:(length(x)-1))) * x)\n}\n\nbob &lt;- \n  dt |&gt;\n  sapply(un_snafu) |&gt;\n  suppressWarnings() |&gt;\n  sum()\n\nsubtract &lt;- function(x) {\n  case_when(\n    x == \"2\" ~ \"1\",\n    x == \"1\" ~ \"0\",\n    x == \"0\" ~ \"-\",\n    x == \"-\" ~ \"=\"\n  )\n}\n\nmax_places &lt;-\n  sapply(1:100, \\(x) paste0(rep(\"2\", x), collapse = \"\")) |&gt;\n  sapply(un_snafu)\nx &lt;- names(which(max_places &gt; bob)[1])\nplace &lt;- 1\n\nrepeat {\n  x2 &lt;- x\n  \n  s &lt;- substr(x2, place, place)\n  if (s != \"=\") { substr(x2, place, place) &lt;- subtract(s) } \n  else { place &lt;- place + 1 }\n  \n  u &lt;- un_snafu(x2)\n  if (u &gt; bob) { x &lt;- x2 }\n  else if (u &lt; bob) { place &lt;- place + 1 }\n  else { print(x2); break }\n} |&gt;\n  suppressWarnings()\n\n[1] \"2-02===-21---2002==0\"",
    "crumbs": [
      "2022",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>2022-25: Full of Hot Air</span>"
    ]
  },
  {
    "objectID": "2022/25/2022-25.html#part-2",
    "href": "2022/25/2022-25.html#part-2",
    "title": "2022-25: Full of Hot Air",
    "section": "Part 2",
    "text": "Part 2\n\n\n\n\n\n\nCaution\n\n\n\nThis puzzle does not unlock until you have completed the rest of the year. I’ll be back one day…",
    "crumbs": [
      "2022",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>2022-25: Full of Hot Air</span>"
    ]
  },
  {
    "objectID": "2021/01/2021-01.html",
    "href": "2021/01/2021-01.html",
    "title": "2021-01: Sonar Sweep",
    "section": "",
    "text": "Part 1\ndt$diff &lt;- c(0, diff(dt$V1))\ndt %&gt;%\n  filter(diff &gt; 0) %&gt;%\n  nrow()\n\n[1] 1374",
    "crumbs": [
      "2021",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>2021-01: Sonar Sweep</span>"
    ]
  },
  {
    "objectID": "2021/01/2021-01.html#part-2",
    "href": "2021/01/2021-01.html#part-2",
    "title": "2021-01: Sonar Sweep",
    "section": "Part 2",
    "text": "Part 2\n\ndt$diff &lt;- c(0, 0, 0, diff(dt$V1, lag = 3))\ndt %&gt;%\n  filter(diff &gt; 0) %&gt;%\n  nrow()\n\n[1] 1418",
    "crumbs": [
      "2021",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>2021-01: Sonar Sweep</span>"
    ]
  },
  {
    "objectID": "2021/01/2021-01.html#speed-edition",
    "href": "2021/01/2021-01.html#speed-edition",
    "title": "2021-01: Sonar Sweep",
    "section": "Speed Edition",
    "text": "Speed Edition\nFastest Solution\n\n# fastest solution\n# data.table was faster until I turned on warn=FALSE in readLines for Base R\ndt &lt;- as.numeric(readLines(\"input.txt\", warn = FALSE))\n# part 1\nsum(diff(dt, lag = 1) &gt; 0)\n\n[1] 1374\n\n# part 2\nsum(diff(dt, lag = 3) &gt; 0)\n\n[1] 1418\n\n\nBenchmarks\n\nrbenchmark::benchmark(\n  \"First try\" = {\n    library(tidyverse)\n    library(data.table)\n    dt &lt;- data.table(read.table(\"input.txt\", sep = \"\\n\"))\n    # part 1\n    dt$diff &lt;- c(0, diff(dt$V1))\n    dt %&gt;% filter(diff &gt; 0) %&gt;% nrow()\n    # part 2\n    dt$diff &lt;- c(0, 0, 0, diff(dt$V1, lag = 3))\n    dt %&gt;% filter(diff &gt; 0) %&gt;% nrow()\n    },\n  \"Base R\" = {\n    dt &lt;- as.numeric(readLines(\"input.txt\", warn = FALSE))\n    # part 1\n    sum(diff(dt, lag = 1) &gt; 0)\n    # part 2\n    sum(diff(dt, lag = 3) &gt; 0)\n    },\n  \"data.table\" = {\n    # part 1 and 2\n    data.table::fread(\"input.txt\", \n                      sep = \"\\n\")[, .(diff1 = sum(diff(V1, lag = 1) &gt; 0),\n                                      diff3 = sum(diff(V1, lag = 3) &gt; 0))]\n  },\n  replications = 100, columns = c(1:5), order = \"user.self\")\n\n        test replications user.self sys.self elapsed\n2     Base R          100     0.046    0.008   0.057\n3 data.table          100     0.149    0.011   0.187\n1  First try          100     0.592    0.031   0.866",
    "crumbs": [
      "2021",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>2021-01: Sonar Sweep</span>"
    ]
  },
  {
    "objectID": "2021/02/2021-02.html",
    "href": "2021/02/2021-02.html",
    "title": "2021-02: Dive!",
    "section": "",
    "text": "Part 1\ndt &lt;- data.table(read.table(\"input.txt\", sep = \"\\n\"))\ndt &lt;- separate(dt, \"V1\", c(\"d\", \"n\"), sep = \" \", convert = TRUE)\ndt$n &lt;- ifelse(dt$d == \"down\", dt$n * -1, dt$n)\n\nabs(dt[d == \"forward\", .(sum = sum(n))] * \n  as.numeric(dt[d != \"forward\", .(sum = sum(n))]))\n\n       sum\n1: 1635930",
    "crumbs": [
      "2021",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2021-02: Dive!</span>"
    ]
  },
  {
    "objectID": "2021/02/2021-02.html#part-2",
    "href": "2021/02/2021-02.html#part-2",
    "title": "2021-02: Dive!",
    "section": "Part 2",
    "text": "Part 2\n\ndt &lt;- data.table(read.table(\"input.txt\", sep = \"\\n\"))\ndt &lt;- separate(dt, \"V1\", c(\"d\", \"n\"), sep = \" \", convert = TRUE)\n\ndt$aim &lt;- ifelse(dt$d == \"up\" & dt$d != \"forward\", dt$n * -1, dt$n)\ndt$aim &lt;- ifelse(dt$d == \"forward\", 0, dt$aim)\ndt$aim &lt;- cumsum(dt$aim)\n\ndt$h &lt;- ifelse(dt$d == \"forward\", dt$n, 0)\ndt$depth &lt;- ifelse(dt$d == \"forward\", dt$aim * dt$n, 0)\n\nsum(dt$h, na.rm = TRUE) * sum(dt$depth, na.rm = TRUE)\n\n[1] 1781819478",
    "crumbs": [
      "2021",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2021-02: Dive!</span>"
    ]
  },
  {
    "objectID": "2021/02/2021-02.html#speed-edition",
    "href": "2021/02/2021-02.html#speed-edition",
    "title": "2021-02: Dive!",
    "section": "Speed Edition",
    "text": "Speed Edition\nBase R once again beats out data.table by just a little bit. The big difference here was moving from colSums to sum, although readLines instead of fread does play a part.\nFastest solution\n\ndtM &lt;- data.frame(\"V1\" = readLines(\"input.txt\"))\ndtM &lt;- tidyr::separate(dtM, \"V1\", c(\"d\", \"n\"), sep = \" \", convert = TRUE)\n\n# part 1\ndt &lt;- dtM\ndt$n &lt;- ifelse(dt$d == \"down\", dt$n * -1, dt$n)\nabs(sum(dt$n[dt$d == \"forward\"]) * sum(dt$n[dt$d != \"forward\"]))\n\n[1] 1635930\n\n# part 2\ndt &lt;- dtM\ndt$aim &lt;- cumsum(ifelse(dt$d == \"up\", dt$n * -1, \n                        ifelse(dt$d == \"forward\", 0, dt$n)))\nsum(ifelse(dt$d == \"forward\", dt$n, 0), na.rm = TRUE) *\n  sum(ifelse(dt$d == \"forward\", dt$aim * dt$n, 0), na.rm = TRUE)\n\n[1] 1781819478\n\n\nBenchmarks\n\nrbenchmark::benchmark(\n  \"First try\" = {\n    library(data.table)\n    # part 1\n    dt &lt;- data.table(read.table(\"input.txt\", sep = \"\\n\"))\n    dt &lt;- tidyr::separate(dt, \"V1\", c(\"d\", \"n\"), sep = \" \", convert = TRUE)\n    dt$n &lt;- ifelse(dt$d == \"down\", dt$n * -1, dt$n)\n\n    abs(dt[d == \"forward\", .(sum = sum(n))] * \n          as.numeric(dt[d != \"forward\", .(sum = sum(n))]))\n    \n    # part 2\n    dt &lt;- data.table(read.table(\"input.txt\", sep = \"\\n\"))\n    dt &lt;- tidyr::separate(dt, \"V1\", c(\"d\", \"n\"), sep = \" \", convert = TRUE)\n\n    dt$aim &lt;- ifelse(dt$d == \"up\" & dt$d != \"forward\", dt$n * -1, dt$n)\n    dt$aim &lt;- ifelse(dt$d == \"forward\", 0, dt$aim)\n    dt$aim &lt;- cumsum(dt$aim)\n\n    dt$h &lt;- ifelse(dt$d == \"forward\", dt$n, 0)\n    dt$depth &lt;- ifelse(dt$d == \"forward\", dt$aim * dt$n, 0)\n    \n    sum(dt$h, na.rm = TRUE) * sum(dt$depth, na.rm = TRUE)\n    },\n  \"Base R\" = {\n    dtM &lt;- data.frame(\"V1\" = readLines(\"input.txt\"))\n    dtM$n &lt;- na.omit(as.numeric(unlist(strsplit(dtM$V1, \" \"))))\n    dtM$d &lt;- as.character(unlist(strsplit(dtM$V1, \" \")))[\n      is.na(as.numeric(unlist(strsplit(dtM$V1, \" \"))))]\n    \n    # part 1\n    dt &lt;- dtM\n    dt$n &lt;- ifelse(dt$d == \"down\", dt$n * -1, dt$n)\n    abs(sum(dt$n[dt$d == \"forward\"]) * sum(dt$n[dt$d != \"forward\"]))\n    \n    # part 2\n    dt &lt;- dtM\n    dt$aim &lt;- cumsum(ifelse(dt$d == \"up\", dt$n * -1, \n                            ifelse(dt$d == \"forward\", 0, dt$n)))\n    sum(ifelse(dt$d == \"forward\", dt$n, 0), na.rm = TRUE) * \n      sum(ifelse(dt$d == \"forward\", dt$aim * dt$n, 0), na.rm = TRUE)\n    },\n  \"data.table\" = {\n    library(data.table)\n    dtM &lt;- fread(\"input.txt\", sep = \"\\n\", header = FALSE)\n    dtM &lt;- tidyr::separate(dtM, \"V1\", c(\"d\", \"n\"), sep = \" \", convert = TRUE)\n\n    # part 1\n    dt &lt;- dtM\n    dt$n &lt;- ifelse(dt$d == \"down\", dt$n * -1, dt$n)\n    abs(colSums(dt[d == \"forward\", .(n)]) * colSums(dt[d != \"forward\", .(n)]))\n    \n    # part 2\n    dt &lt;- dtM\n    dt$aim &lt;- cumsum(ifelse(dt$d == \"up\", dt$n * -1, \n                            ifelse(dt$d == \"forward\", 0, dt$n)))\n    sum(ifelse(dt$d == \"forward\", dt$n, 0), na.rm = TRUE) * \n      sum(ifelse(dt$d == \"forward\", dt$aim * dt$n, 0), na.rm = TRUE)\n    },\n  replications = 100, columns = c(1:5), order = \"user.self\")\n\n        test replications user.self sys.self elapsed\n2     Base R          100     0.228    0.007   0.234\n3 data.table          100     0.829    0.056   0.885\n1  First try          100     1.588    0.117   1.706",
    "crumbs": [
      "2021",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>2021-02: Dive!</span>"
    ]
  },
  {
    "objectID": "2021/03/2021-03.html",
    "href": "2021/03/2021-03.html",
    "title": "2021-03: Binary Diagnostic",
    "section": "",
    "text": "Part 1\n# part 1\ndt &lt;- data.frame(fread(\"input.txt\", sep = \"\\n\", colClasses = c(\"character\")))\ndt &lt;- tidyr::separate(dt, \"V1\", paste0(\"V\", 1:13), sep = \"\", convert = TRUE)\n\nget_mode &lt;- function(x)\n  return(names(sort(table(x), decreasing = T, na.last = T)[1]))\no &lt;- c()\nfor(i in 2:13)\n  o &lt;- append(o, get_mode(dt[,i]))\n\no &lt;- unbinary(paste(o, collapse = \"\"))\n\nget_mode &lt;- function(x)\n  return(names(sort(table(x), na.last = T)[1]))\nc &lt;- c()\nfor(i in 2:13)\n  c &lt;- append(c, get_mode(dt[,i]))\nc &lt;- unbinary(paste(c, collapse = \"\"))\n\no * c\n\n[1] 4174964",
    "crumbs": [
      "2021",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>2021-03: Binary Diagnostic</span>"
    ]
  },
  {
    "objectID": "2021/03/2021-03.html#part-2",
    "href": "2021/03/2021-03.html#part-2",
    "title": "2021-03: Binary Diagnostic",
    "section": "Part 2",
    "text": "Part 2\n\n# part 2\ndtM &lt;- data.frame(fread(\"input.txt\", sep = \"\\n\", colClasses = c(\"character\")))\ndtM &lt;- tidyr::separate(dtM, \"V1\", paste0(\"V\", 1:13), sep = \"\", convert = TRUE)\ndtM &lt;- dtM %&gt;% select(-\"V1\")\ndt &lt;- dtM\n\nget_modeMax &lt;- function(x){\n  temp &lt;- sort(table(x), decreasing = T, na.last = T)\n  ifelse(temp[1] == temp[2], return(1), names(temp[1]))\n}\no &lt;- c()\n\nfor(i in 1:12) {\n  dt &lt;- dt %&gt;%\n    filter_at(i, all_vars(.==get_modeMax(dt[,i])))\n  if(nrow(dt) == 1) {\n    oxygen &lt;- paste(as.character(dt[1,]), collapse = \"\")\n    break\n  }\n}\n\ndt &lt;- dtM\nget_modeMin &lt;- function(x){\n  temp &lt;- sort(table(x), na.last = T)\n  ifelse(temp[1] == temp[2], return(0), names(temp[1]))\n}\nc &lt;- c()\n\nfor(i in 1:12) {\n  dt &lt;- dt %&gt;%\n    filter_at(i, all_vars(.==get_modeMin(dt[,i])))\n  if(nrow(dt) == 1) {\n    co2 &lt;- paste(as.character(dt[1,]), collapse = \"\")\n    break\n  }\n}\n\nunbinary(oxygen) * unbinary(co2)\n\n[1] 4474944",
    "crumbs": [
      "2021",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>2021-03: Binary Diagnostic</span>"
    ]
  },
  {
    "objectID": "2021/03/2021-03.html#speed-edition",
    "href": "2021/03/2021-03.html#speed-edition",
    "title": "2021-03: Binary Diagnostic",
    "section": "Speed Edition",
    "text": "Speed Edition\nToday was bad. I misread the instructions, forgot a bunch of basic functions, and so much more. I couldn’t get any of the base reading functions to read my input properly so I ended up with fread from data.table. I also haven’t been able to make any significant speed improvements from my initial solution.\nI’m not sure why readLines wasn’t working last night but I also switched to str_split_fixed from stringr and it’s so much faster now.\nFastest solution\n\nlibrary(dplyr)\n# part 1\ndt &lt;- stringr::str_split_fixed(readLines(\"input.txt\"), pattern = \"\", n = 12)\ndt &lt;- data.frame(apply(dt, 2, as.integer))\n\ngetModeMin &lt;- function(x)\n  return(ifelse(mean(x) &gt; .5, 0, 1))\ngetModeMax &lt;- function(x)\n  return(ifelse(mean(x) &gt; .5, 1, 0))\n\nstrtoi(paste(apply(dt, 2, getModeMax), collapse = \"\"), base = 2) *\n  strtoi(paste(apply(dt, 2, getModeMin), collapse = \"\"), base = 2)\n\n[1] 4174964\n\n# part 2\ndto &lt;- dt\ndtc &lt;- dt\n\nfor (i in 1:12) {\n  if (nrow(dto) &gt; 1)\n    dto &lt;- dto |&gt;\n      filter_at(i, all_vars(. == ifelse(mean(dto[, i]) &gt;= .5, 1, 0)))\n  if (nrow(dtc) &gt; 1)\n    dtc &lt;- dtc |&gt;\n      filter_at(i, all_vars(. == ifelse(mean(dtc[, i]) &lt; .5, 1, 0)))\n}\n\nstrtoi(paste(as.character(dto[1,]), collapse = \"\"), base = 2) *\n  strtoi(paste(as.character(dtc[1,]), collapse = \"\"), base = 2)\n\n[1] 4474944\n\n\nBenchmarks\n\nrbenchmark::benchmark(\n  \"First try\" = {\n    library(tidyverse)\n    library(data.table)\n    library(compositions)\n    \n    # part 1\n    dt &lt;- data.frame(fread(\"input.txt\", sep = \"\\n\", \n                           colClasses = c(\"character\")))\n    dt &lt;- tidyr::separate(dt, \"V1\", paste0(\"V\", 1:13), \n                          sep = \"\", convert = TRUE)\n    \n    get_mode &lt;- function(x)\n      return(names(sort(table(x), decreasing = T, na.last = T)[1]))\n    o &lt;- c()\n    for (i in 2:13)\n      o &lt;- append(o, get_mode(dt[, i]))\n    o &lt;- unbinary(paste(o, collapse = \"\"))\n    \n    get_mode &lt;- function(x)\n      return(names(sort(table(x), na.last = T)[1]))\n    c &lt;- c()\n    for (i in 2:13)\n      c &lt;- append(c, get_mode(dt[, i]))\n    c &lt;- unbinary(paste(c, collapse = \"\"))\n    \n    o * c\n    \n    # part 2\n    dtM &lt;- data.frame(fread(\"input.txt\", sep = \"\\n\",\n                            colClasses = c(\"character\")))\n    dtM &lt;- tidyr::separate(dtM, \"V1\", paste0(\"V\", 1:13),\n                           sep = \"\", convert = TRUE)\n    dtM &lt;- dtM %&gt;% select(-\"V1\")\n    dt &lt;- dtM\n\n    get_modeMax &lt;- function(x) {\n      temp &lt;- sort(table(x), decreasing = T, na.last = T)\n      ifelse(temp[1] == temp[2], return(1), names(temp[1]))\n    }\n    o &lt;- c()\n    for (i in 1:12) {\n      dt &lt;- dt %&gt;% filter_at(i, all_vars(. == get_modeMax(dt[, i])))\n      if (nrow(dt) == 1) {\n        oxygen &lt;- paste(as.character(dt[1, ]), collapse = \"\")\n        break\n      }\n    }\n\n    dt &lt;- dtM\n    get_modeMin &lt;- function(x) {\n      temp &lt;- sort(table(x), na.last = T)\n      ifelse(temp[1] == temp[2], return(0), names(temp[1]))\n    }\n    c &lt;- c()\n    for (i in 1:12) {\n      dt &lt;- dt %&gt;% filter_at(i, all_vars(. == get_modeMin(dt[, i])))\n      if (nrow(dt) == 1) {\n        co2 &lt;- paste(as.character(dt[1, ]), collapse = \"\")\n        break\n      }\n    }\n\n    unbinary(oxygen) * unbinary(co2)\n    },\n    \"Second try\" = {\n      library(tidyverse)\n      library(data.table)\n      library(compositions)\n      \n      # part 1\n      dt &lt;- fread(\"input.txt\", sep = \"\\n\", colClasses = c(\"character\")) %&gt;%\n        as.data.frame() %&gt;%\n        tidyr::separate(\"V1\", paste0(\"V\", 1:13), sep = \"\", convert = TRUE) %&gt;%\n        select(-\"V1\")\n      \n      getModeMin &lt;- function(x)\n        return(names(sort(table(x), na.last = T)[1]))\n      getModeMax &lt;- function(x)\n        return(names(sort(\n          table(x), decreasing = T, na.last = T\n        )[1]))\n      \n      o &lt;- unbinary(paste(apply(dt, 2, getModeMax), collapse = \"\"))\n      \n      c &lt;- unbinary(paste(apply(dt, 2, getModeMin), collapse = \"\"))\n      \n      o * c\n      \n      # part 2\n      dtM &lt;-\n        fread(\"input.txt\", sep = \"\\n\", colClasses = c(\"character\")) %&gt;%\n        as.data.frame() %&gt;%\n        tidyr::separate(\"V1\", paste0(\"V\", 1:13), sep = \"\", convert = TRUE) %&gt;%\n        select(-\"V1\")\n      dto &lt;- dtM\n      dtc &lt;- dtM\n      \n      getModeMin &lt;- function(x) {\n        temp &lt;- sort(table(x), na.last = T)\n        ifelse(temp[1] == temp[2], return(0), names(temp[1]))\n      }\n      getModeMax &lt;- function(x) {\n        temp &lt;- sort(table(x), decreasing = T, na.last = T)\n        ifelse(temp[1] == temp[2], return(1), names(temp[1]))\n      }\n      \n      for (i in 1:12) {\n        if (nrow(dto) &gt; 1)\n          dto &lt;-\n            dto %&gt;% filter_at(i, all_vars(. == getModeMax(dto[, i])))\n        if (nrow(dtc) &gt; 1)\n          dtc &lt;-\n            dtc %&gt;% filter_at(i, all_vars(. == getModeMin(dtc[, i])))\n        if (nrow(dto) == 1 & nrow(dtc) == 1) {\n          oxygen &lt;- paste(as.character(dto[1,]), collapse = \"\")\n          co2 &lt;- paste(as.character(dtc[1,]), collapse = \"\")\n          break\n        }\n      }\n      \n      unbinary(oxygen) * unbinary(co2)\n    }, \n  \"Third try\" = {\n    library(dplyr)\n    # part 1\n    dt &lt;- \n      stringr::str_split_fixed(readLines(\"input.txt\"), pattern = \"\", n = 12)\n    dt &lt;- data.frame(apply(dt, 2, as.integer))\n    \n    getModeMin &lt;- function(x)\n      return(ifelse(mean(x) &gt; .5, 0, 1))\n    getModeMax &lt;- function(x)\n      return(ifelse(mean(x) &gt; .5, 1, 0))\n    \n    strtoi(paste(apply(dt, 2, getModeMax), collapse = \"\"), base = 2) *\n      strtoi(paste(apply(dt, 2, getModeMin), collapse = \"\"), base = 2)\n    \n    # part 2\n    dto &lt;- dt\n    dtc &lt;- dt\n    \n    for (i in 1:12) {\n      if (nrow(dto) &gt; 1)\n        dto &lt;- dto |&gt;\n          filter_at(i, all_vars(. == ifelse(mean(dto[, i]) &gt;= .5, 1, 0)))\n      if (nrow(dtc) &gt; 1)\n        dtc &lt;- dtc |&gt;\n          filter_at(i, all_vars(. == ifelse(mean(dtc[, i]) &lt; .5, 1, 0)))\n    }\n    \n    strtoi(paste(as.character(dto[1, ]), collapse = \"\"), base = 2) *\n      strtoi(paste(as.character(dtc[1, ]), collapse = \"\"), base = 2)\n  }, \n  replications = 100, columns = c(1:5), order = \"user.self\")\n\n        test replications user.self sys.self elapsed\n2 Second try          100    16.956    0.346  17.304\n1  First try          100    17.130    0.360  17.492\n3  Third try          100    20.403    0.318  20.740",
    "crumbs": [
      "2021",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>2021-03: Binary Diagnostic</span>"
    ]
  },
  {
    "objectID": "2021/04/2021-04.html",
    "href": "2021/04/2021-04.html",
    "title": "2021-04: Giant Squid",
    "section": "",
    "text": "Part 1\n# part 1\ndt &lt;- data.frame(fread(\"input2.txt\"))\ncall &lt;- c(84,28,29,75,58,71,26,6,73,74,41,39,87,37,16,79,55,60,62,80,64,95,46,15,5,47,2,35,32,78,89,90,96,33,4,69,42,30,54,85,65,83,44,63,20,17,66,81,67,77,36,68,82,93,10,25,9,34,24,72,91,88,11,38,3,45,14,56,22,61,97,27,12,48,18,1,31,98,86,19,99,92,8,43,52,23,21,0,7,50,57,70,49,13,51,40,76,94,53,59)\nbingo &lt;- FALSE\n\nfor(i in 1:length(call)) {\n  dt$V1[dt$V1 == call[i]] &lt;- NA\n  dt$V2[dt$V2 == call[i]] &lt;- NA\n  dt$V3[dt$V3 == call[i]] &lt;- NA\n  dt$V4[dt$V4 == call[i]] &lt;- NA\n  dt$V5[dt$V5 == call[i]] &lt;- NA\n  \n  for(R in seq(1, nrow(dt), 5)) {\n    for(r in R:(R+4)) {\n      if(sum(is.na(dt[r,])) == 5) {\n        bingo &lt;- TRUE\n        break\n      }\n    }\n    for(c in 1:5) {\n      if(sum(is.na(dt[R:(R+4),c])) == 5) {\n        bingo &lt;- TRUE\n        break\n      }\n    }\n    if(bingo)\n      break\n  }\n  if(bingo)\n    break\n}\nsum(dt[R:(R+4),], na.rm = TRUE) * call[i]\n\n[1] 29440",
    "crumbs": [
      "2021",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>2021-04: Giant Squid</span>"
    ]
  },
  {
    "objectID": "2021/04/2021-04.html#part-2",
    "href": "2021/04/2021-04.html#part-2",
    "title": "2021-04: Giant Squid",
    "section": "Part 2",
    "text": "Part 2\n\n# part 2\ndt &lt;- data.frame(fread(\"input2.txt\"))\ncall &lt;- c(84,28,29,75,58,71,26,6,73,74,41,39,87,37,16,79,55,60,62,80,64,95,46,15,5,47,2,35,32,78,89,90,96,33,4,69,42,30,54,85,65,83,44,63,20,17,66,81,67,77,36,68,82,93,10,25,9,34,24,72,91,88,11,38,3,45,14,56,22,61,97,27,12,48,18,1,31,98,86,19,99,92,8,43,52,23,21,0,7,50,57,70,49,13,51,40,76,94,53,59)\nbingo &lt;- 0\nbingoTF &lt;- FALSE\nboards &lt;- nrow(dt) / 5\n\nfor(i in 1:length(call)) {\n  dt$V1[dt$V1 == call[i]] &lt;- NA\n  dt$V2[dt$V2 == call[i]] &lt;- NA\n  dt$V3[dt$V3 == call[i]] &lt;- NA\n  dt$V4[dt$V4 == call[i]] &lt;- NA\n  dt$V5[dt$V5 == call[i]] &lt;- NA\n  \n  for (R in seq(1, nrow(dt), 5)) {\n    if (sum(is.na(dt[R:(R + 4), 1:5])) != 25) {\n      for (r in R:(R + 4)) {\n        if (sum(is.na(dt[r, ])) == 5) {\n          dt[r, ] &lt;- NA\n          bingo &lt;- append(bingo, i)\n          bingoTF &lt;- TRUE\n          break\n        }\n      }\n      for (c in 1:5) {\n        if (sum(is.na(dt[R:(R + 4), c])) == 5) {\n          dt[R:(R + 4), c] &lt;- NA\n          bingo &lt;- append(bingo, i)\n          bingoTF &lt;- TRUE\n          break\n        }\n      }\n      \n      if (bingoTF) {\n        dt[R:(R + 4),] &lt;- NA\n        bingo &lt;- append(bingo, i)\n        bingoTF &lt;- FALSE\n      }\n    }\n  }\n}\n\ndt &lt;- data.frame(fread(\"input2.txt\"))\nbingoTF &lt;- FALSE\n\nfor(i in 1:(bingo[length(bingo)]-1)) {\n  dt$V1[dt$V1 == call[i]] &lt;- NA\n  dt$V2[dt$V2 == call[i]] &lt;- NA\n  dt$V3[dt$V3 == call[i]] &lt;- NA\n  dt$V4[dt$V4 == call[i]] &lt;- NA\n  dt$V5[dt$V5 == call[i]] &lt;- NA\n  \n  for (R in seq(1, nrow(dt), 5)) {\n    if (sum(is.na(dt[R:(R + 4), 1:5])) != 25) {\n      for (r in R:(R + 4)) {\n        if (sum(is.na(dt[r, ])) == 5) {\n          dt[r, ] &lt;- NA\n          bingoTF &lt;- TRUE\n          break\n        }\n      }\n      for (c in 1:5) {\n        if (sum(is.na(dt[R:(R + 4), c])) == 5) {\n          dt[R:(R + 4), c] &lt;- NA\n          bingoTF &lt;- TRUE\n          break\n        }\n      }\n      \n      if (bingoTF) {\n        dt[R:(R + 4),] &lt;- NA\n        bingoTF &lt;- FALSE\n      }\n    }\n  }\n}\n\ndt &lt;- tail(dt[rowSums(dt, na.rm = TRUE) != 0,], 5)\ni &lt;- i + 1\ndt$V1[dt$V1 == call[i]] &lt;- NA\ndt$V2[dt$V2 == call[i]] &lt;- NA\ndt$V3[dt$V3 == call[i]] &lt;- NA\ndt$V4[dt$V4 == call[i]] &lt;- NA\ndt$V5[dt$V5 == call[i]] &lt;- NA\nsum(dt, na.rm = TRUE) * call[i]\n\n[1] 13884",
    "crumbs": [
      "2021",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>2021-04: Giant Squid</span>"
    ]
  },
  {
    "objectID": "2021/05/2021-05.html",
    "href": "2021/05/2021-05.html",
    "title": "2021-05: Hydrothermal Venture",
    "section": "",
    "text": "Part 1\n# part 1\ndt &lt;- data.frame(fread(\"input.txt\"))\ndt &lt;- data.table(\"x1\" = dt[, \"V1\"] + 1,\n                 \"y1\" = as.numeric(str_split(dt$V2, \" -&gt; \", \n                                             simplify = TRUE)[,1]) + 1,\n                 \"x2\" = as.numeric(str_split(dt$V2, \" -&gt; \", \n                                             simplify = TRUE)[,2]) + 1,\n                 \"y2\" = dt[, \"V3\"] + 1)[x1 == x2 | y1 == y2,]\nmx &lt;- data.frame(matrix(data = 0, nrow = max(dt), ncol = max(dt)))\n\nfor(r in 1:nrow(dt)) {\n  mx[dt$x1[r]:dt$x2[r], dt$y1[r]:dt$y2[r]] &lt;- \n    mx[dt$x1[r]:dt$x2[r], dt$y1[r]:dt$y2[r]] + 1\n}\n\nlength(mx[mx &gt; 1])\n\n[1] 4728",
    "crumbs": [
      "2021",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>2021-05: Hydrothermal Venture</span>"
    ]
  },
  {
    "objectID": "2021/05/2021-05.html#part-2",
    "href": "2021/05/2021-05.html#part-2",
    "title": "2021-05: Hydrothermal Venture",
    "section": "Part 2",
    "text": "Part 2\n\n# part 2\ndt &lt;- data.frame(fread(\"input.txt\"))\ndt &lt;- data.table(\"x1\" = dt[, \"V1\"] + 1,\n                 \"y1\" = as.numeric(str_split(dt$V2, \" -&gt; \", \n                                             simplify = TRUE)[,1]) + 1,\n                 \"x2\" = as.numeric(str_split(dt$V2, \" -&gt; \", \n                                             simplify = TRUE)[,2]) + 1,\n                 \"y2\" = dt[, \"V3\"] + 1) %&gt;%\n  .[, at :=  (x1 == y2 & x2 == y1) |\n             (x1 == y1 & x2 == y2) | \n             (abs(x2 - x1) == abs(y2 - y1))] \nmx &lt;- matrix(data = 0, nrow = max(dt), ncol = max(dt))\n\nfor(r in 1:nrow(dt)) {\n  ifelse(dt$at[r],\n    diag(mx[dt$x1[r]:dt$x2[r], dt$y1[r]:dt$y2[r]]) &lt;- \n      diag(mx[dt$x1[r]:dt$x2[r], dt$y1[r]:dt$y2[r]]) + 1,\n    mx[dt$x1[r]:dt$x2[r], dt$y1[r]:dt$y2[r]] &lt;- \n      mx[dt$x1[r]:dt$x2[r], dt$y1[r]:dt$y2[r]] + 1)\n}\n\nlength(mx[mx &gt; 1])\n\n[1] 17717",
    "crumbs": [
      "2021",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>2021-05: Hydrothermal Venture</span>"
    ]
  },
  {
    "objectID": "2021/06/2021-06.html",
    "href": "2021/06/2021-06.html",
    "title": "2021-06: Lanternfish",
    "section": "",
    "text": "Part 1\ndt2 &lt;- as.numeric(data.table::fread(\"input.txt\", header = FALSE)[1])\n\nt &lt;- table(dt2)\nv &lt;- c(0, 0, t, rep(0, 8 - length(t)))\n\nfor(i in 1:80)\n  v &lt;- c(v[2:7], v[8] + v[1], v[9:10], v[2])\nsum(v)\n\n[1] 363101",
    "crumbs": [
      "2021",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>2021-06: Lanternfish</span>"
    ]
  },
  {
    "objectID": "2021/06/2021-06.html#part-2",
    "href": "2021/06/2021-06.html#part-2",
    "title": "2021-06: Lanternfish",
    "section": "Part 2",
    "text": "Part 2\n\ndt2 &lt;- as.numeric(data.table::fread(\"input.txt\", header = FALSE)[1])\n\nt &lt;- table(dt2)\nv &lt;- c(0, 0, t, rep(0, 8 - length(t)))\n\nfor(i in 1:256)\n  v &lt;- c(v[2:7], v[8] + v[1], v[9:10], v[2])\noptions(scipen=999)\nsum(v)\n\n[1] 1644286074024",
    "crumbs": [
      "2021",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>2021-06: Lanternfish</span>"
    ]
  },
  {
    "objectID": "2021/06/2021-06.html#speed-edition",
    "href": "2021/06/2021-06.html#speed-edition",
    "title": "2021-06: Lanternfish",
    "section": "Speed Edition",
    "text": "Speed Edition\n\nThis was a classic Advent Of Code misdirection. Once I figured it out, my solution was quick to write and execute.\n\nFastest solution\n\n# part 1 and 2\ndt2 &lt;- c(1,3,3,4,5,1,1,1,1,1,1,2,1,4,1,1,1,5,2,2,4,3,1,1,2,5,4,2,2,3,1,2,3,2,1,\n         1,4,4,2,4,4,1,2,4,3,3,3,1,1,3,4,5,2,5,1,2,5,1,1,1,3,2,3,3,1,4,1,1,4,1,\n         4,1,1,1,1,5,4,2,1,2,2,5,5,1,1,1,1,2,1,1,1,1,3,2,3,1,4,3,1,1,3,1,1,1,1,\n         3,3,4,5,1,1,5,4,4,4,4,2,5,1,1,2,5,1,3,4,4,1,4,1,5,5,2,4,5,1,1,3,1,3,1,\n         4,1,3,1,2,2,1,5,1,5,1,3,1,3,1,4,1,4,5,1,4,5,1,1,5,2,2,4,5,1,3,2,4,2,1,\n         1,1,2,1,2,1,3,4,4,2,2,4,2,1,4,1,3,1,3,5,3,1,1,2,2,1,5,2,1,1,1,1,1,5,4,\n         3,5,3,3,1,5,5,4,4,2,1,1,1,2,5,3,3,2,1,1,1,5,5,3,1,4,4,2,4,2,1,1,1,5,1,\n         2,4,1,3,4,4,2,1,4,2,1,3,4,3,3,2,3,1,5,3,1,1,5,1,2,2,4,4,1,2,3,1,2,1,1,\n         2,1,1,1,2,3,5,5,1,2,3,1,3,5,4,2,1,3,3,4)\n\nfishTable &lt;- c(0, 0, table(dt2), rep(0, 8 - max(dt2)))\n\nfish &lt;- function(v, d) {\n  if (d == 0) {\n    return(sum(v, digits = 999))\n  } else if (d == 176) {\n    print(sum(v))\n  }\n  fish(c(v[2:7], v[8] + v[1], v[9:10], v[2]), d - 1)\n}\nfish(fishTable, 256)\n\n[1] 363101\n\n\n[1] 1644286075023\n\n\nBenchmark\n\nbench &lt;- rbenchmark::benchmark(\n  \"First try\" = {\n    # part 1\n    dt &lt;- as.numeric(unlist(stringr::str_split(readLines(\"input.txt\"), \",\")))\n    dt2 &lt;- dt\n    for(d in 1:80) {\n      dt2 &lt;- dt2 - 1\n      if(sum(dt2 == -1) &gt; 0) {\n        dt2 &lt;- append(dt2, rep(8, sum(dt2 == -1)))\n        dt2[dt2 == -1] &lt;- 6\n        }\n      }\n    s &lt;- length(dt2)\n\n    # part 2\n    dt &lt;- as.numeric(unlist(stringr::str_split(readLines(\"input2.txt\"), \",\")))\n    dt2 &lt;- dt\n\n    dt &lt;- data.frame(\"m\" = 0, \"zero\" = 0, \"one\" = 0, \"two\" = 0,\n                     \"three\" = 0, \"four\" = 0, \"five\" = 0, \"six\" = 0,\n                     \"seven\" = 0, \"eight\" = 0)\n\n    for(i in 1:length(dt2)) {\n      if(dt2[i] == 0) {dt$zero[1] &lt;- dt$zero[1] + 1}\n      if(dt2[i] == 1) {dt$one[1] &lt;- dt$one[1] + 1}\n      if(dt2[i] == 2) {dt$two[1] &lt;- dt$two[1] + 1}\n      if(dt2[i] == 3) {dt$three[1] &lt;- dt$three[1] + 1}\n      if(dt2[i] == 4) {dt$four[1] &lt;- dt$four[1] + 1}\n      if(dt2[i] == 5) {dt$five[1] &lt;- dt$five[1] + 1}\n      if(dt2[i] == 6) {dt$six[1] &lt;- dt$six[1] + 1}\n      if(dt2[i] == 7) {dt$seven[1] &lt;- dt$seven[1] + 1}\n      if(dt2[i] == 8) {dt$eight[1] &lt;- dt$eight[1] + 1}\n    }\n\n    for (i in 1:255) {\n      dt$zero[1] &lt;- dt$one[1]\n      dt$one[1] &lt;- dt$two[1]\n      dt$two[1] &lt;- dt$three[1]\n      dt$three[1] &lt;- dt$four[1]\n      dt$four[1] &lt;- dt$five[1]\n      dt$five[1] &lt;- dt$six[1]\n      dt$six[1] &lt;- dt$seven[1] + dt$m[1]\n      dt$seven[1] &lt;- dt$eight[1]\n\n      dt$eight[1] &lt;- dt$m[1]\n      dt$m[1] &lt;- dt$zero[1]\n    }\n\n    options(scipen = 999)\n    s &lt;- sum(dt[1, ])\n    },\n  \"Third try\" = {\n      # part 1 and 2\n      dt2 &lt;- as.numeric(data.table::fread(\"input.txt\", header = FALSE)[1])\n\n      t &lt;- table(dt2)\n      v &lt;- c(0, 0, t, rep(0, 8 - length(t)))\n\n      for (i in 1:256) {\n        v &lt;- c(v[2:7], v[8] + v[1], v[9:10], v[2])\n        if(i == 80)\n          s &lt;- sum(v)\n      }\n      options(scipen = 999)\n      s &lt;- sum(v)\n    },\n  \"With recursion!\" = {\n    # part 1 and 2\n    dt2 &lt;- c(1,3,3,4,5,1,1,1,1,1,1,2,1,4,1,1,1,5,2,2,4,3,1,1,2,5,4,2,2,3,1,2,3,\n             2,1,1,4,4,2,4,4,1,2,4,3,3,3,1,1,3,4,5,2,5,1,2,5,1,1,1,3,2,3,3,1,4,\n             1,1,4,1,4,1,1,1,1,5,4,2,1,2,2,5,5,1,1,1,1,2,1,1,1,1,3,2,3,1,4,3,1,\n             1,3,1,1,1,1,3,3,4,5,1,1,5,4,4,4,4,2,5,1,1,2,5,1,3,4,4,1,4,1,5,5,2,\n             4,5,1,1,3,1,3,1,4,1,3,1,2,2,1,5,1,5,1,3,1,3,1,4,1,4,5,1,4,5,1,1,5,\n             2,2,4,5,1,3,2,4,2,1,1,1,2,1,2,1,3,4,4,2,2,4,2,1,4,1,3,1,3,5,3,1,1,\n             2,2,1,5,2,1,1,1,1,1,5,4,3,5,3,3,1,5,5,4,4,2,1,1,1,2,5,3,3,2,1,1,1,\n             5,5,3,1,4,4,2,4,2,1,1,1,5,1,2,4,1,3,4,4,2,1,4,2,1,3,4,3,3,2,3,1,5,\n             3,1,1,5,1,2,2,4,4,1,2,3,1,2,1,1,2,1,1,1,2,3,5,5,1,2,3,1,3,5,4,2,1,\n             3,3,4)\n\n    fishTable &lt;- c(0, 0, table(dt2), rep(0, 8 - max(dt2)))\n    \n    fish &lt;- function(v, d) {\n      if (d == 0) {\n        return(sum(v, digits = 999))\n      } else if (d == 176) {\n        s &lt;- sum(v)\n      }\n      fish(c(v[2:7], v[8] + v[1], v[9:10], v[2]), d - 1)\n    }\n    s &lt;- fish(fishTable, 256)\n  }, \n  replications = 100, columns = c(1:5), order = \"user.self\")\n\nbench$per &lt;- bench$user.self / bench$replications\nbench\n\n             test replications user.self sys.self elapsed     per\n3 With recursion!          100     0.088    0.001   0.089 0.00088\n2       Third try          100     0.506    0.012   0.518 0.00506\n1       First try          100    10.192    1.695  11.944 0.10192",
    "crumbs": [
      "2021",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>2021-06: Lanternfish</span>"
    ]
  },
  {
    "objectID": "2021/07/2021-07.html",
    "href": "2021/07/2021-07.html",
    "title": "2021-07: The Treachery of Whales",
    "section": "",
    "text": "Part 1\ndt2 &lt;- data.table(\"start\" = dt)\ns &lt;- c()\nfor(i in -max(dt):max(dt)) {\n  dt2 &lt;- data.table(\"start\" = dt)\n  dt2[, mean := floor(mean(start))][, diff := abs(start - mean + i)]\n  s &lt;- append(s, sum(dt2$diff))\n}\nmin(s)\n\n[1] 342730",
    "crumbs": [
      "2021",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>2021-07: The Treachery of Whales</span>"
    ]
  },
  {
    "objectID": "2021/07/2021-07.html#part-2",
    "href": "2021/07/2021-07.html#part-2",
    "title": "2021-07: The Treachery of Whales",
    "section": "Part 2",
    "text": "Part 2\n\ndt2 &lt;- data.table(\"start\" = dt)\ns &lt;- c()\n\nfor(i in -max(dt):max(dt)) {\n  dt2 &lt;- data.table(\"start\" = dt)\n  dt2[, mean := floor(mean(start))]\n  for(r in 1:nrow(dt2))\n    dt2$diff[r] &lt;- sum(1:(abs(dt2$start[r] - dt2$mean[r] - i)))\n  s &lt;- append(s, sum(dt2$diff))\n}\nmin(s)\n\n[1] 92335207",
    "crumbs": [
      "2021",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>2021-07: The Treachery of Whales</span>"
    ]
  },
  {
    "objectID": "2021/07/2021-07.html#speed-edition",
    "href": "2021/07/2021-07.html#speed-edition",
    "title": "2021-07: The Treachery of Whales",
    "section": "Speed Edition",
    "text": "Speed Edition\nPlease don’t look at this. It’s embarrassing.\nI only did one rep because my first try is too slow.\nFastest solution\n\nlibrary(stringr)\nlibrary(tidyverse)\nlibrary(data.table)\n\n\ndt &lt;- as.numeric(data.table::fread(\"input.txt\", header = FALSE)[1])\n# part 1\ns &lt;- max(dt) ^ length(dt)\nfor (i in-ceiling(max(dt) / 2):ceiling(max(dt) / 2)) {\n  dt2 &lt;-\n    data.table(\"start\" = dt)[, mean := floor(mean(start))][, diff := abs(start - mean - i)]\n  dtDiff &lt;- sum(dt2$diff)\n  s &lt;- data.table::fifelse(dtDiff &lt; s, dtDiff, s)\n}\ns &lt;- c(s)\n\n# part 2\ncSum &lt;- function(y) {\n  eval(parse(text = y))\n}\ndt2 &lt;- data.table(\"start\" = dt)\ndt2[, mean := mean(dt2$start, na.rm = TRUE)]\ndt2$abs &lt;- abs(dt2$start - dt2$mean)\ndt2$meanC &lt;- ceiling(dt2$mean)\ndt2$meanF &lt;- floor(dt2$mean)\ndt2$absC &lt;- abs(dt2$start - dt2$meanC)\ndt2$absF &lt;- abs(dt2$start - dt2$meanF)\ndt2$diffC &lt;- sapply(paste0(\"sum(1:\", dt2$absC, \")\"), cSum)\ndt2$diffF &lt;- sapply(paste0(\"sum(1:\", dt2$absF, \")\"), cSum)\ns &lt;- min(sum(dt2$diffC), sum(dt2$diffF))\n\nBenchmark\n\nbench &lt;- rbenchmark::benchmark(\n  \"first\" = {\n    library(stringr)\n    library(tidyverse)\n    library(data.table)\n    dt &lt;-\n      as.numeric(data.table::fread(\"input.txt\", header = FALSE)[1])\n    # part 1\n    dt2 &lt;- data.table(\"start\" = dt)\n    s &lt;- c()\n    for (i in-max(dt):max(dt)) {\n      dt2 &lt;- data.table(\"start\" = dt)\n      dt2[, mean := floor(mean(start))][, diff := abs(start - mean + i)]\n      s &lt;- append(s, sum(dt2$diff))\n    }\n    s &lt;- min(s)\n    \n    # part 2\n    dt2 &lt;- data.table(\"start\" = dt)\n    s &lt;- c()\n    \n    for (i in-max(dt):max(dt)) {\n      dt2 &lt;- data.table(\"start\" = dt)\n      dt2[, mean := floor(mean(start))]\n      for (r in 1:nrow(dt2))\n        dt2$diff[r] &lt;- sum(1:(abs(dt2$start[r] - dt2$mean[r] - i)))\n      s &lt;- append(s, sum(dt2$diff))\n    }\n    s &lt;- min(s)\n  },\n  \"second\" = {\n    library(stringr)\n    library(tidyverse)\n    library(data.table)\n    dt &lt;-\n      as.numeric(data.table::fread(\"input.txt\", header = FALSE)[1])\n    # part 1\n    s &lt;- max(dt) ^ length(dt)\n    for (i in-ceiling(max(dt) / 2):ceiling(max(dt) / 2)) {\n      dt2 &lt;-\n        data.table(\"start\" = dt)[, mean := floor(mean(start))][, diff := abs(start - mean - i)]\n      dtDiff &lt;- sum(dt2$diff)\n      s &lt;- data.table::fifelse(dtDiff &lt; s, dtDiff, s)\n    }\n    s &lt;- c(s)\n    \n    cSum &lt;- function(y) {\n      eval(parse(text = y))\n    }\n    dt2 &lt;- data.table(\"start\" = dt)\n    dt2[, mean := mean(dt2$start, na.rm = TRUE)]\n    dt2$abs &lt;- abs(dt2$start - dt2$mean)\n    dt2$meanC &lt;- ceiling(dt2$mean)\n    dt2$meanF &lt;- floor(dt2$mean)\n    dt2$absC &lt;- abs(dt2$start - dt2$meanC)\n    dt2$absF &lt;- abs(dt2$start - dt2$meanF)\n    dt2$diffC &lt;- sapply(paste0(\"sum(1:\", dt2$absC, \")\"), cSum)\n    dt2$diffF &lt;- sapply(paste0(\"sum(1:\", dt2$absF, \")\"), cSum)\n    min(sum(dt2$diffC), sum(dt2$diffF))\n  },\n  replications = 1,\n  columns = 1:5,\n  order = \"user.self\"\n)\n\nbench$per &lt;- bench$user.self / bench$replications\nbench\n\n    test replications user.self sys.self elapsed     per\n2 second            1     0.863    0.005   0.870   0.863\n1  first            1   125.937   11.166 138.154 125.937",
    "crumbs": [
      "2021",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>2021-07: The Treachery of Whales</span>"
    ]
  },
  {
    "objectID": "2021/08/2021-08.html",
    "href": "2021/08/2021-08.html",
    "title": "2021-08: Seven Segment Search",
    "section": "",
    "text": "Part 1\ndt2 &lt;- data.table(\"output\" = dt$V2)\ndt2 &lt;- as.character(unlist(strsplit(dt2$output, \" \")))\nlength(dt2[nchar(dt2) %in% c(2, 3, 4, 7)])\n\n[1] 392",
    "crumbs": [
      "2021",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>2021-08: Seven Segment Search</span>"
    ]
  },
  {
    "objectID": "2021/08/2021-08.html#part-1",
    "href": "2021/08/2021-08.html#part-1",
    "title": "2021-08: Seven Segment Search",
    "section": "",
    "text": "This is how I laid out my positions",
    "crumbs": [
      "2021",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>2021-08: Seven Segment Search</span>"
    ]
  },
  {
    "objectID": "2021/08/2021-08.html#part-2",
    "href": "2021/08/2021-08.html#part-2",
    "title": "2021-08: Seven Segment Search",
    "section": "Part 2",
    "text": "Part 2\n\ndf &lt;- data.table::fread(\"input.txt\", header = FALSE)\ndt1 &lt;- data.table(\"input\" = df$V1)\ndt1 &lt;- data.table(str_split(dt1$input, \" \", simplify = TRUE))\ndt2 &lt;- data.table(\"output\" = df$V2)\ndt2 &lt;- data.table(str_split(dt2$output, \" \", simplify = TRUE))\ndf &lt;- cbind(dt1, dt2)\n\nsortV &lt;- function(x) {\n  sapply(lapply(strsplit(x, NULL), sort), paste, collapse=\"\")\n}\n\ngetNumber &lt;- function(x1) {\n  display &lt;- c(\"p1\" = \"\",\n               \"p2\" = \"\",\n               \"p3\" = \"\",\n               \"p4\" = \"\",\n               \"p5\" = \"\",\n               \"p6\" = \"\",\n               \"p7\" = \"\")\n  x &lt;- as.character(x1[1:10])\n  one &lt;- \"\"\n  four &lt;- \"\"\n  seven &lt;- \"\"\n  eight &lt;- \"\"\n  \n  for (i in 1:10) {\n    if (nchar(x[i]) == 2) one &lt;- x[i]\n    if (nchar(x[i]) == 3) seven &lt;- x[i]\n    if (nchar(x[i]) == 4) four &lt;- x[i]\n    if (nchar(x[i]) == 7) eight &lt;- x[i]\n  }\n  \n  # determine p1\n  display[\"p1\"] &lt;- str_split(seven, \"\", simplify = TRUE)[\n    !(str_split(seven, \"\", simplify = TRUE) %in% \n        str_split(one, \"\", simplify = TRUE))]\n  \n  # determine p57\n  p57 &lt;- paste0(seven, four, collapse = \"\")\n  p57 &lt;- str_split(p57, \"\", simplify = TRUE)\n  p27 &lt;- as.character(unlist(str_split(x[nchar(x) == 5], \"\")))\n  p27 &lt;- p27[!(p27 %in% p57)]\n  display[\"p5\"] &lt;- names(sort(table(p27)))[1]\n  display[\"p7\"] &lt;- names(sort(table(p27)))[2]\n  \n  # determine p36\n  p24 &lt;- str_split(eight, \"\", simplify = TRUE)[\n    !(str_split(eight, \"\", simplify = TRUE) %in% \n        str_split(one, \"\", simplify = TRUE))]\n  p24 &lt;- p24[!(p24 %in% display)]\n  p &lt;- as.character(unlist(str_split(x[nchar(x) == 6], \"\")))\n  p &lt;- p[!(p %in% p24)]\n  p &lt;- sort(table(p))\n  p36 &lt;- p[(names(p) %in% str_split(one, \"\", simplify = TRUE))]\n  display[\"p3\"] &lt;- names(p36)[1]\n  display[\"p6\"] &lt;- names(p36)[2]\n  \n  # determine p24\n  p24 &lt;- unlist(str_split(x[nchar(x) == 5], \"\"))\n  p24 &lt;- sort(table(p24[!(p24 %in% display)]))\n  display[\"p2\"] &lt;- names(p24)[1]\n  display[\"p4\"] &lt;- names(p24)[2]\n  display\n  \n  zero &lt;- paste0(sort(display[c(1:3,5:7)]), collapse = \"\")\n  one &lt;- paste0(sort(display[c(3,6)]), collapse = \"\")\n  two &lt;- paste0(sort(display[c(1,3,4:5,7)]), collapse = \"\")\n  three &lt;- paste0(sort(display[c(1,3:4,6:7)]), collapse = \"\")\n  four &lt;- paste0(sort(display[c(2:4,6)]), collapse = \"\")\n  five &lt;- paste0(sort(display[c(1:2,4,6:7)]), collapse = \"\")\n  six &lt;- paste0(sort(display[c(1:2,4:7)]), collapse = \"\")\n  seven &lt;- paste0(sort(display[c(1,3,6)]), collapse = \"\")\n  eight &lt;- paste0(sort(display[c(1:7)]), collapse = \"\")\n  nine &lt;- paste0(sort(display[c(1:4,6:7)]), collapse = \"\")\n  \n  x &lt;- as.character(x1[11:14])\n  x &lt;- sapply(x, sortV)\n  \n  returnNumber &lt;- function(x) {\n    return(case_when(\n      x == zero ~ 0,\n      x == one ~ 1,\n      x == two ~ 2,\n      x == three ~ 3,\n      x == four ~ 4,\n      x == five ~ 5,\n      x == six ~ 6,\n      x == seven ~ 7,\n      x == eight ~ 8,\n      x == nine ~ 9\n    ))\n  }\n  \n  x &lt;- paste0(sapply(x, returnNumber), collapse = \"\")\n  return(as.numeric(x))\n}\n\nsum(apply(df, 1, getNumber))\n\n[1] 1004688",
    "crumbs": [
      "2021",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>2021-08: Seven Segment Search</span>"
    ]
  },
  {
    "objectID": "2021/09/2021-09.html",
    "href": "2021/09/2021-09.html",
    "title": "2021-09: Smoke Basin",
    "section": "",
    "text": "Part 1\ndt2 &lt;- dt\n\ncoordX &lt;- c()\ncoordY &lt;- c()\nrLow &lt;- c()\nfor(r in 2:(nrow(dt2) - 1)) {\n  for(c in 2:(ncol(dt2) - 1)) {\n    if(dt2[r,c] == min(dt[(r-1):(r+1),(c-1):(c+1)])) {\n      rLow &lt;- append(rLow, dt2[r,c])\n      coordX &lt;- append(coordX, c)\n      coordY &lt;- append(coordY, r)\n    }\n  }\n}\n\ns &lt;- 0\nfor(n in 1:length(rLow)) {\n  s &lt;- s + (rLow[n] + 1)\n}\ns\n\n[1] 575",
    "crumbs": [
      "2021",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>2021-09: Smoke Basin</span>"
    ]
  },
  {
    "objectID": "2021/09/2021-09.html#part-2",
    "href": "2021/09/2021-09.html#part-2",
    "title": "2021-09: Smoke Basin",
    "section": "Part 2",
    "text": "Part 2\n\ndt2 &lt;- dt\ndt2[dt2 == 9 | dt2 == 10] &lt;- NA\n\ncoordX &lt;- c()\ncoordY &lt;- c()\nrLow &lt;- c()\nfor(r in 2:(nrow(dt2) - 1)) {\n  for(c in 2:(ncol(dt2) - 1)) {\n    if(!is.na(dt2[r,c])) {\n      rLow &lt;- append(rLow, dt2[r,c])\n      coordX &lt;- append(coordX, c)\n      coordY &lt;- append(coordY, r)\n    }\n  }\n}\n\ndt3 &lt;- data.frame(\"x\" = coordX, \"y\" = coordY, \"d\" = rLow)\ndt3 &lt;- dt3[dt3$d &lt;= 8,]\ndb &lt;- dbscan(dt3[,1:2], eps = 1, minPts = 0)\ndt3$cluster &lt;- db$cluster\ndt &lt;- dt3 %&gt;%\n  group_by(cluster) %&gt;%\n  count() %&gt;%\n  filter(cluster != 0) %&gt;%\n  arrange(desc(n)) %&gt;%\n  head(3)\nprod(dt$n)\n\n[1] 1019700\n\ndt3$cluster &lt;- ifelse(dt3$cluster %in% dt$cluster, dt3$cluster, 0)\ndt3 %&gt;%\n  mutate(cluster = as.factor(cluster)) %&gt;%\n  ggplot() +\n  geom_point(aes(x = x, y = y, color = cluster))\n\n\n\n\n\n\nggsave(\"cluster.png\")\n\nSaving 7 x 5 in image",
    "crumbs": [
      "2021",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>2021-09: Smoke Basin</span>"
    ]
  },
  {
    "objectID": "2021/10/2021-10.html",
    "href": "2021/10/2021-10.html",
    "title": "2021-10: Syntax Scoring",
    "section": "",
    "text": "Part 1\ndt2 &lt;- dt\n\nmonkeyBall &lt;- function(x, n) {\n  x &lt;- str_replace_all(x, \"\\\\(\\\\)|\\\\[\\\\]|\\\\{\\\\}|\\\\&lt;\\\\&gt;\", \"\")\n  if(nchar(x) == n) {\n    t &lt;- as.character(str_split(str_replace_all(x, \"[\\\\(\\\\[\\\\{\\\\&lt;]\", \"\"),\n                   \"\",\n                   simplify = TRUE)[1,])\n    t &lt;- t[1]\n    return(t)\n  }\n  return(monkeyBall(x, nchar(x)))\n}\n\nt &lt;- c()\nfor(r in 1:nrow(dt2)) {\n  x &lt;- dt2[r,1]\n  n &lt;- nchar(x)\n  t &lt;- append(t, monkeyBall(x, n))\n}\nt &lt;- table(t)\nif (is.na(t[\")\"]))\n  t[\")\"] &lt;- 0\nif (is.na(t[\"]\"]))\n  t[\"]\"] &lt;- 0\nif (is.na(t[\"}\"]))\n  t[\"}\"] &lt;- 0\nif (is.na(t[\"&gt;\"]))\n  t[\"&gt;\"] &lt;- 0\n(3 * t[\")\"]) + (57 * t[\"]\"]) + (1197 * t[\"}\"]) + (25137 * t[\"&gt;\"])\n\n     ) \n311949",
    "crumbs": [
      "2021",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>2021-10: Syntax Scoring</span>"
    ]
  },
  {
    "objectID": "2021/10/2021-10.html#part-2",
    "href": "2021/10/2021-10.html#part-2",
    "title": "2021-10: Syntax Scoring",
    "section": "Part 2",
    "text": "Part 2\n\ndt2 &lt;- dt\n\nmonkeyBall &lt;- function(x, n) {\n  x &lt;- str_replace_all(x, \"\\\\(\\\\)|\\\\[\\\\]|\\\\{\\\\}|\\\\&lt;\\\\&gt;\", \"\")\n  if(nchar(x) == n) {\n    if(!grepl(\"\\\\)|\\\\]|\\\\}|\\\\&gt;\", x, perl = TRUE))\n      return(x)\n    return(\"\")\n  }\n  return(monkeyBall(x, nchar(x)))\n}\n\nt &lt;- c()\nfor(r in 1:nrow(dt2)) {\n  x &lt;- dt2[r,1]\n  n &lt;- nchar(x)\n  t &lt;- append(t, monkeyBall(x, n))\n}\nt &lt;- t[nchar(t) &gt; 0]\ns &lt;- c()\nfor(i in t) {\n  miniS &lt;- 0\n  miniT &lt;- rev(str_split(i, \"\", simplify = TRUE)[1,])\n  for(l in miniT) {\n    miniS &lt;- (5 * miniS) + case_when(l == \"(\" ~ 1,\n                                     l == \"[\" ~ 2,\n                                     l == \"{\" ~ 3,\n                                     l == \"&lt;\" ~ 4)\n  }\n  s &lt;- append(s, miniS)\n}\ns &lt;- s[!is.na(s)]\nmedian(s)\n\n[1] 3042730309",
    "crumbs": [
      "2021",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>2021-10: Syntax Scoring</span>"
    ]
  },
  {
    "objectID": "2021/11/2021-11.html",
    "href": "2021/11/2021-11.html",
    "title": "2021-11: Dumbo Octopus",
    "section": "",
    "text": "Part 1\noctopus &lt;- octopusM |&gt;\n  strsplit(\"\") %&gt;%\n  do.call(rbind, .) |&gt;\n  as.matrix() |&gt;\n  apply(1, as.numeric) |&gt;\n  t()\n\noctopusCol &lt;- ncol(octopus)\noctopusRow &lt;- nrow(octopus)\n\nflash_counter &lt;- 0\n\nget_adjacent &lt;- function(xx, yy, ncol, nrow) {\n  x &lt;- xx; y &lt;- yy\n  x &lt;- (x-1):(x+1); y &lt;- (y-1):(y+1)\n  \n  x &lt;- x[sapply(x, \\(j) between(j, 1, ncol))]\n  y &lt;- y[sapply(y, \\(j) between(j, 1, nrow))]\n\n  expand.grid(\"col\" = x, \"row\" = y) |&gt;\n    filter(!(col == xx & row == yy)) |&gt;\n    as.matrix()\n}\n\nfor(i in 1:100) {\n  octopus &lt;- octopus + 1\n  \n  while(any(octopus &gt; 9)) {\n    flash &lt;- which(octopus &gt; 9, arr.ind = TRUE)\n    octopus[octopus &gt; 9] &lt;- 0\n    for(x in 1:nrow(flash)) {\n      adj &lt;- \n        get_adjacent(flash[x, \"col\"], flash[x, \"row\"], octopusCol, octopusRow)\n      \n      octopus[adj[,\"row\"], adj[,\"col\"]] &lt;- \n        apply(octopus[adj[,\"row\"], adj[,\"col\"]], c(1, 2), \n              \\(x) { ifelse(x == 0, 0, x + 1) })\n    }\n  }\n  flash_counter &lt;&lt;- flash_counter + length(octopus[octopus == 0])\n}\nflash_counter\n\n[1] 1603",
    "crumbs": [
      "2021",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>2021-11: Dumbo Octopus</span>"
    ]
  },
  {
    "objectID": "2021/11/2021-11.html#part-2",
    "href": "2021/11/2021-11.html#part-2",
    "title": "2021-11: Dumbo Octopus",
    "section": "Part 2",
    "text": "Part 2\n\noctopus &lt;- octopusM |&gt;\n  strsplit(\"\") %&gt;%\n  do.call(rbind, .) |&gt;\n  as.matrix() |&gt;\n  apply(1, as.numeric) |&gt;\n  t()\n\ni &lt;- 1\n\nwhile(TRUE) {\n  octopus &lt;- octopus + 1\n  \n  while(any(octopus &gt; 9)) {\n    flash &lt;- which(octopus &gt; 9, arr.ind = TRUE)\n    octopus[octopus &gt; 9] &lt;- 0\n    for(x in 1:nrow(flash)) {\n      adj &lt;- \n        get_adjacent(flash[x, \"col\"], flash[x, \"row\"], octopusCol, octopusRow)\n      \n      octopus[adj[,\"row\"], adj[,\"col\"]] &lt;- \n        apply(octopus[adj[,\"row\"], adj[,\"col\"]], c(1, 2), \n              \\(x) { ifelse(x == 0, 0, x + 1) })\n    }\n  }\n  if (length(octopus[octopus == 0]) == octopusRow * octopusCol) {\n    print(i)\n    break\n  } else { i &lt;- i + 1 }\n}\n\n[1] 222",
    "crumbs": [
      "2021",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>2021-11: Dumbo Octopus</span>"
    ]
  },
  {
    "objectID": "2021/13/2021-13.html",
    "href": "2021/13/2021-13.html",
    "title": "2021-13: Transparent Origami",
    "section": "",
    "text": "Part 1\nfold &lt;- function(dir, n, paper) {\n  if (dir == \"x\") {\n    paper1 &lt;- paper[,1:(n)]\n    paper2 &lt;- paper[,(n+2):ncol(paper)]\n    paper2 &lt;- t(apply(paper2, 1, rev))\n  } else if (dir == \"y\") {\n    paper1 &lt;- paper[1:(n),]\n    paper2 &lt;- paper[(n+2):nrow(paper), ]\n    paper2 &lt;- apply(paper2, 2, rev)\n  }\n\n  return(ifelse(paper1 | paper2, TRUE, FALSE))\n}\n\nfolded &lt;- fold(folds$X1[1], folds$X2[1], paper)\nlength(which(folded))\n\n[1] 684",
    "crumbs": [
      "2021",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>2021-13: Transparent Origami</span>"
    ]
  },
  {
    "objectID": "2021/13/2021-13.html#part-2",
    "href": "2021/13/2021-13.html#part-2",
    "title": "2021-13: Transparent Origami",
    "section": "Part 2",
    "text": "Part 2\n\nfold &lt;- function(dir, n, paper) {\n  if (dir == \"x\") {\n    paper1 &lt;- paper[,1:(n)]\n    paper2 &lt;- paper[,(n+2):ncol(paper)]\n    paper2 &lt;- t(apply(paper2, 1, rev))\n  } else if (dir == \"y\") {\n    paper1 &lt;- paper[1:(n),]\n    paper2 &lt;- paper[(n+2):nrow(paper), ]\n    paper2 &lt;- apply(paper2, 2, rev)\n  }\n  \n  return(ifelse(paper1 | paper2, TRUE, FALSE))\n}\n\nfor(i in 1:nrow(folds)) {\n  paper &lt;- fold(folds$X1[i], folds$X2[i], paper)\n  \n  coordX &lt;- c()\n  coordY &lt;- c()\n  for(r in 1:nrow(paper)) {\n    for(c in 1:ncol(paper)) {\n      if(paper[r,c]) {\n        coordX &lt;- append(coordX, r)\n        coordY &lt;- append(coordY, c)\n      }\n    }\n  }\n  \n  points &lt;- data.frame(cbind(coordX, coordY)) %&gt;%\n    ggplot() +\n    geom_point(aes(x = coordY, y = -coordX)) +\n    xlim(0, max(c(coordX, coordY))) +\n    ylim(-max(c(coordX, coordY)), 0)\n  if(i == nrow(folds))\n    print(points)\n}",
    "crumbs": [
      "2021",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>2021-13: Transparent Origami</span>"
    ]
  },
  {
    "objectID": "2021/14/2021-14.html",
    "href": "2021/14/2021-14.html",
    "title": "2022-14: Extended Polymerization",
    "section": "",
    "text": "Part 1\ndt &lt;- readLines(\"input.txt\")\npolymer &lt;- dt[!grepl(\" -&gt; \", dt)][1]\npolymer &lt;- str_split(polymer, \"\", simplify = TRUE)[1,]\npairs &lt;- data.frame(str_split(dt[grepl(\" -&gt; \", dt)], \" -&gt; \", simplify = TRUE))\n\nfor(d in 1:10) {\n  pos &lt;- data.frame(\"let\" = NA, \"pos\" = NA)\n  for (i in 1:(length(polymer) - 1)) {\n    pos &lt;- rbind(pos, data.frame(\"let\" =\n                                   pairs$X2[pairs$X1 == paste0(polymer[i:(i + 1)],\n                                                               collapse = \"\")],\n                                 \"pos\" = i))\n  }\n  pos &lt;- pos[-1, ]\n  \n  for (r in 1:nrow(pos)) {\n    polymer &lt;-\n      R.utils::insert(x = polymer,\n                      values = pos$let[r],\n                      ats = r + pos$pos[r])\n  }\n  # print((table(polymer)))\n}\nt &lt;- sort(table(polymer), decreasing = TRUE)\nt[1] - rev(t)[1]\n\n   S \n3230",
    "crumbs": [
      "2021",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>2022-14: Extended Polymerization</span>"
    ]
  },
  {
    "objectID": "2021/14/2021-14.html#part-2",
    "href": "2021/14/2021-14.html#part-2",
    "title": "2022-14: Extended Polymerization",
    "section": "Part 2",
    "text": "Part 2\n\ndt &lt;- readLines(\"input.txt\")\npolymer &lt;- dt[!grepl(\" -&gt; \", dt)][1]\npolymer &lt;- str_split(polymer, \"\", simplify = TRUE)[1,]\npairs &lt;- \n  data.frame(str_split(dt[grepl(\" -&gt; \", dt)], \" -&gt; \", simplify = TRUE))\n\ndt &lt;-\n  data.frame(\"x\" = polymer[-length(polymer)], \"y\" = polymer[-1]) %&gt;%\n  mutate(\"z\" = paste0(x, y, sep = \"\")) %&gt;%\n  select(\"z\") %&gt;%\n  group_by(z) %&gt;%\n  count()\n  \ncounts &lt;- unique(unlist(strsplit(pairs$X1, \"\")))\ncounts &lt;- \n  rep(0, length(counts)) %&gt;%\n  `names&lt;-`(sort(unique(counts))) %&gt;%\n  data.frame() %&gt;%\n  rownames_to_column(var = \"value\") %&gt;%\n  `colnames&lt;-`(c(\"value\", \"n\")) %&gt;%\n  rbind(table(polymer) |&gt; data.frame() |&gt; `colnames&lt;-`(c(\"value\", \"n\"))) %&gt;%\n  group_by(value) |&gt;\n    summarise(n = sum(n)) |&gt;\n    ungroup()\n\nbuild_poly &lt;- function(dt, counts, i = 1) {\n  if (i == 40 + 1) { return(counts) }\n  dt &lt;- dt %&gt;%\n    right_join(pairs, by = c(\"z\" = \"X1\")) %&gt;%\n    filter(!is.na(n))\n  \n  counts &lt;-\n    dt %&gt;%\n    group_by(X2) %&gt;%\n      summarise(n = sum(n)) %&gt;%\n    ungroup() %&gt;%\n    `colnames&lt;-`(c(\"value\", \"n\")) %&gt;%\n    rbind(counts) %&gt;%\n    group_by(value) %&gt;%\n      summarise(n = sum(n)) %&gt;%\n    ungroup() %&gt;%\n    filter(!is.na(n))\n  \n  dt &lt;- dt %&gt;%\n    separate(\"z\", into = c(\"x\", \"y\"), sep = 1) %&gt;%\n    mutate(x = paste(x, X2, sep = \"\"),\n           y = paste(X2, y, sep = \"\")) %&gt;%\n    select(-X2) %&gt;%\n    pivot_longer(cols = c(x, y)) %&gt;%\n    select(-name) %&gt;%\n    group_by(value) %&gt;%\n      summarise(n = sum(n)) %&gt;%\n    ungroup() %&gt;%\n    rename(\"z\" = value)\n  \n  build_poly(dt, counts, i + 1)\n}\n\noptions(digits = 20)\n\ntab &lt;- \n  build_poly(dt, counts) |&gt;\n  deframe() |&gt;\n  sort()\n\ntab[length(tab)] - tab[1]\n\n            S \n3542388214529",
    "crumbs": [
      "2021",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>2022-14: Extended Polymerization</span>"
    ]
  },
  {
    "objectID": "2020/01/2020-01.html",
    "href": "2020/01/2020-01.html",
    "title": "2020-01: Report Repair",
    "section": "",
    "text": "Part 1\nkey &lt;- NA\n\nfor(x in 1:200) {\n  for(y in 1:200) {\n    if((df$values[x] + df$values[y]) == 2020) {\n      print(paste(df$values[x], df$values[y]))\n      key &lt;- df$values[x] * df$values[y]\n      print(key)\n    }\n    if(!is.na(key))\n      break\n  }\n}\n\n[1] \"1825 195\"\n[1] 355875",
    "crumbs": [
      "2020",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>2020-01: Report Repair</span>"
    ]
  },
  {
    "objectID": "2020/01/2020-01.html#part-2",
    "href": "2020/01/2020-01.html#part-2",
    "title": "2020-01: Report Repair",
    "section": "Part 2",
    "text": "Part 2\n\nkey &lt;- NA\n\nfor(x in 1:200) {\n  for(y in 1:200) {\n    for(z in 1:200) {\n      if((df$values[x] + df$values[y]) + df$values[z] == 2020) {\n        print(paste(df$values[x], df$values[y], df$values[z]))\n        key &lt;- df$values[x] * df$values[y] * df$values[z]\n        print(key)\n      }\n      if(!is.na(key))\n        break\n    }\n  }\n}\n\n[1] \"346 1380 294\"\n[1] 140379120",
    "crumbs": [
      "2020",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>2020-01: Report Repair</span>"
    ]
  },
  {
    "objectID": "2020/02/2020-02.html",
    "href": "2020/02/2020-02.html",
    "title": "2020-02: Password Philosophy",
    "section": "",
    "text": "Part 1\ncount &lt;- 0\n\nfor(i in 1:nrow(df)) {\n  if(str_count(df$password[i], as.character(df$letter[i])) &gt;= df$min[i] & \n     str_count(df$password[i], as.character(df$letter[i])) &lt;= df$max[i])\n    count &lt;- count + 1\n}\n\ncount\n\n[1] 548",
    "crumbs": [
      "2020",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>2020-02: Password Philosophy</span>"
    ]
  },
  {
    "objectID": "2020/02/2020-02.html#part-2",
    "href": "2020/02/2020-02.html#part-2",
    "title": "2020-02: Password Philosophy",
    "section": "Part 2",
    "text": "Part 2\n\ncount &lt;- 0\n\nfor(i in 1:nrow(df)) {\n  sub &lt;- paste(substr(df$password[i], df$min[i], df$min[i]), \n               substr(df$password[i], df$max[i], df$max[i]))\n  if(str_count(sub, as.character(df$letter[i])) == 1)\n    count &lt;- count + 1\n}\n\ncount\n\n[1] 502",
    "crumbs": [
      "2020",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>2020-02: Password Philosophy</span>"
    ]
  },
  {
    "objectID": "2020/03/2020-03.html",
    "href": "2020/03/2020-03.html",
    "title": "2020-03: Toboggan Trajectory",
    "section": "",
    "text": "Part 1\nx &lt;- 1\npounds &lt;- \"\"\nxVals &lt;- c()\n\nfor(y in 1:323) {\n  pounds &lt;- paste(pounds, as.character(df[y, x]), sep = \"\")\n  if(x + 3 &gt; 31)\n    x &lt;- x + 3 - 31\n  else\n    x &lt;- x + 3\n  xVals &lt;- append(xVals, as.character(x))\n}\n\nstr_count(pounds, \"#\")\n\n[1] 228",
    "crumbs": [
      "2020",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>2020-03: Toboggan Trajectory</span>"
    ]
  },
  {
    "objectID": "2020/03/2020-03.html#part-2",
    "href": "2020/03/2020-03.html#part-2",
    "title": "2020-03: Toboggan Trajectory",
    "section": "Part 2",
    "text": "Part 2\n\nover &lt;- c(1, 3, 5, 7, 1)\ndown &lt;- c(1, 1, 1, 1, 2)\nrunning_total &lt;- 1\n\nfor(z in 1:5) {\n  x &lt;- 1\n  pounds &lt;- \"\"\n\n  for(y in seq(1, 323, by = down[z])) {\n    pounds &lt;- paste(pounds, as.character(df[y, x]), sep = \"\")\n    if(x + over[z] &gt; 31)\n      x &lt;- x + over[z] - 31\n    else\n      x &lt;- x + over[z]\n  }\n  running_total &lt;- running_total * str_count(pounds, \"#\")\n}\nrunning_total\n\n[1] 6818112000",
    "crumbs": [
      "2020",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>2020-03: Toboggan Trajectory</span>"
    ]
  },
  {
    "objectID": "2020/04/2020-04.html",
    "href": "2020/04/2020-04.html",
    "title": "2020-04: Passport Processing",
    "section": "",
    "text": "Part 1\ncount &lt;- 0\n\ntestDF &lt;- df[1,]\n\nrow &lt;- 1\ncolumn &lt;- 1\nfor(r in 1:1169) {\n  for(c in 1:8) {\n    if(c == 1 & is.na(df[r,c])) {\n      column &lt;- 1\n      row &lt;- row + 1\n    }\n    if(!is.na(df[r,c])) {\n      testDF[row,column] &lt;- df[r,c]\n      column &lt;- column + 1\n    }\n  }\n}\n\npassports &lt;- testDF\ncount &lt;- 0\n\nfor(r in 1:299) {\n  if(rowSums(is.na(passports[r,])) == 0)\n      count &lt;- count + 1\n  else if(!(apply(passports[r,], 1, function(x) {\n      any(substr(x, 1, 3) %in% \"cid\")\n    })) & rowSums(is.na(passports[r,])) == 1)\n      count &lt;- count + 1\n}\ncount\n\n[1] 247",
    "crumbs": [
      "2020",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>2020-04: Passport Processing</span>"
    ]
  },
  {
    "objectID": "2020/04/2020-04.html#part-2",
    "href": "2020/04/2020-04.html#part-2",
    "title": "2020-04: Passport Processing",
    "section": "Part 2",
    "text": "Part 2\n\ncount &lt;- 0\ndone &lt;- FALSE\nfields &lt;- c(\"byr\", \"iyr\", \"eyr\", \"hgt\", \"hcl\", \"ecl\", \"pid\", \"cid\")\nneeded &lt;- c(\"byr\", \"iyr\", \"eyr\", \"hgt\", \"hcl\", \"ecl\", \"pid\")\npassport &lt;- c()\n\ntestDF &lt;- df[1,]\n\nrow &lt;- 1\ncolumn &lt;- 1\nfor(r in 1:1169) {\n  for(c in 1:8) {\n    if(c == 1 & is.na(df[r,c])) {\n      column &lt;- 1\n      row &lt;- row + 1\n    }\n    if(!is.na(df[r,c])) {\n      testDF[row,column] &lt;- df[r,c]\n      column &lt;- column + 1\n    }\n  }\n}\n\npassports &lt;- testDF\npassports\n\n# A tibble: 299 × 8\n   X1          X2            X3            X4            X5    X6    X7    X8   \n   &lt;chr&gt;       &lt;chr&gt;         &lt;chr&gt;         &lt;chr&gt;         &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n 1 byr:2024    iyr:2016      eyr:2034      ecl:zzz       pid:… hcl:… hgt:… cid:…\n 2 hgt:66cm    pid:152cm     hcl:cfb18a    eyr:1947      byr:… ecl:… iyr:… &lt;NA&gt; \n 3 ecl:gry     hcl:#888785   eyr:2023      cid:63        iyr:… hgt:… pid:… &lt;NA&gt; \n 4 pid:#5e832a ecl:dne       hcl:#7d3b0c   byr:2018      eyr:… hgt:… iyr:… cid:…\n 5 hcl:#888785 ecl:oth       eyr:2025      pid:597580472 iyr:… hgt:… byr:… cid:…\n 6 eyr:2029    cid:145       iyr:2026      pid:178cm     hgt:… ecl:… hcl:… byr:…\n 7 eyr:2024    ecl:amb       pid:349191561 iyr:2018      hgt:… byr:… hcl:… &lt;NA&gt; \n 8 byr:1998    pid:408617933 hcl:#fffffd   hgt:193cm     eyr:… ecl:… iyr:… &lt;NA&gt; \n 9 eyr:1964    byr:2026      hcl:#cfa07d   hgt:154cm     pid:… cid:… iyr:… ecl:…\n10 hgt:161cm   pid:021086946 iyr:2020      ecl:blu       eyr:… byr:… &lt;NA&gt;  &lt;NA&gt; \n# ℹ 289 more rows\n\n\n\nmatt &lt;- passports[1,]\nmatt$valid &lt;- NA\n\nfor(r in 1:299) {\n  temp &lt;- passports[r,]\n  if(rowSums(is.na(passports[r,])) == 0 | \n     !(apply(passports[r,], 1, function(x) any(substr(x, 1, 3) %in% \"cid\"))) & \n     rowSums(is.na(passports[r,])) == 1)\n    temp$valid &lt;- TRUE\n  else\n    temp$valid &lt;- FALSE\n  matt &lt;- rbind(matt, temp)\n}\nmatt &lt;- matt[-1,]\n\nnewmatt &lt;- matt[1,]\n\nfor(r in 1:299) {\n  for(c in 1:8) {\n    if(!is.na(matt[r,c])) {\n      if(substr(matt[r,c], 1, 3) == \"byr\")\n        newmatt[r,1] &lt;- matt[r,c]\n      \n      else if(substr(matt[r,c], 1, 3) == \"iyr\") \n        newmatt[r,2] &lt;- matt[r,c]\n      \n      else if(substr(matt[r,c], 1, 3) == \"eyr\")\n        newmatt[r,3] &lt;- matt[r,c]\n      \n      else if(substr(matt[r,c], 1, 3) == \"hgt\") \n        newmatt[r,4] &lt;- matt[r,c]\n    \n      else if(substr(matt[r,c], 1, 5) == \"hcl:#\") \n        newmatt[r,5] &lt;- matt[r,c]\n      \n      else if(substr(matt[r,c], 1, 3) == \"ecl\") \n        newmatt[r,6] &lt;- matt[r,c]\n      \n      else if(substr(matt[r,c], 1, 3) == \"pid\") \n        newmatt[r,7] &lt;- matt[r,c]\n      \n      else if(substr(matt[r,c], 1, 3) == \"cid\")\n        newmatt[r,8] &lt;- matt[r,c]\n      \n    }\n    else\n      newmatt[r,c] &lt;- NA\n  }\n  newmatt[r,9] &lt;- matt[r,9]\n}\n\n#sorted &lt;- sorted[-1,]\n\nnewmatt$X1 &lt;- str_replace_all(newmatt$X1, \"[a-z:]\", \"\")\nnewmatt$X2 &lt;- str_replace_all(newmatt$X2, \"[a-z:]\", \"\")\nnewmatt$X3 &lt;- str_replace_all(newmatt$X3, \"[a-z:]\", \"\")\nnewmatt$X4 &lt;- substr(newmatt$X4, 5, nchar(newmatt$X4))\nnewmatt$X5 &lt;- substr(newmatt$X5, 5, nchar(newmatt$X5))\nnewmatt$X6 &lt;- substr(newmatt$X6, 5, nchar(newmatt$X6))\nnewmatt$X7 &lt;- substr(newmatt$X7, 5, nchar(newmatt$X7))\nnewmatt$X8[!is.na(newmatt$X8)] &lt;- TRUE\n\nnewmatt$X1 &lt;- as.numeric(newmatt$X1)\nnewmatt$X2 &lt;- as.numeric(newmatt$X2)\nnewmatt$X3 &lt;- as.numeric(newmatt$X3)\n#newmatt$X7 &lt;- as.numeric(newmatt$X7)\n\nnewmatt &lt;- newmatt %&gt;% filter(valid == TRUE)\nnewmatt$valid &lt;- TRUE\n\n#the ants go marching one by one...\nnewmatt$flag &lt;- 0\n\nnewmatt$valid &lt;- ifelse(newmatt$X1 &gt;= 1920 & newmatt$X1 &lt;= 2002 & \n                          newmatt$valid == TRUE, TRUE, FALSE) #197\nnewmatt$valid &lt;- ifelse(newmatt$X2 &gt;= 2010 & newmatt$X2 &lt;= 2020 & \n                          newmatt$valid == TRUE, TRUE, FALSE) #174\nnewmatt$valid &lt;- ifelse(newmatt$X3 &gt;= 2020 & newmatt$X3 &lt;= 2030 & \n                          newmatt$valid == TRUE, TRUE, FALSE) #160\nnewmatt$flag &lt;- \n  ifelse(newmatt$valid == TRUE & grepl(\"cm\", newmatt$X4) & \n           as.numeric(str_replace_all(newmatt$X4, \"[a-z]\", \"\")) &gt;= 150 & \n           as.numeric(str_replace_all(newmatt$X4, \"[a-z]\", \"\")) &lt;= 193, \n         newmatt$flag + 1, newmatt$flag)\nnewmatt$flag &lt;- \n  ifelse(newmatt$valid == TRUE & grepl(\"in\", newmatt$X4) & \n           as.numeric(str_replace_all(newmatt$X4, \"[a-z]\", \"\")) &gt;= 59 & \n           as.numeric(str_replace_all(newmatt$X4, \"[a-z]\", \"\")) &lt;= 76, \n         newmatt$flag + 1, newmatt$flag)\nnewmatt$valid &lt;- ifelse(newmatt$flag == 1, TRUE, FALSE)\nnewmatt$valid &lt;- \n  ifelse(substr(newmatt$X5, 1, 1) == \"#\" & \n           grepl(\"[0-9a-f#]\", substr(newmatt$X5, 2, nchar(newmatt$X5) - 1)) & \n           nchar(newmatt$X5) == 7 & newmatt$valid == TRUE, TRUE, FALSE)\nnewmatt$valid &lt;- \n  ifelse(grepl(\"(amb|blu|brn|gry|grn|hzl|oth)\", newmatt$X6) & \n           newmatt$valid == TRUE, TRUE, FALSE)\nnewmatt$valid &lt;- \n  ifelse(nchar(newmatt$X7) == 9 & grepl(\"[0-9]\", newmatt$X7) & \n           newmatt$valid == TRUE, TRUE, FALSE)\n\nnewmatt %&gt;%\n  filter(valid == TRUE) %&gt;%\n  nrow()\n\n[1] 145",
    "crumbs": [
      "2020",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>2020-04: Passport Processing</span>"
    ]
  },
  {
    "objectID": "2020/05/2020-05.html",
    "href": "2020/05/2020-05.html",
    "title": "2020-05: Binary Boarding",
    "section": "",
    "text": "Part 1\ndf$rowbin &lt;- df$X1\ndf$rowbin &lt;- str_replace_all(df$rowbin, \"F\", \"0\")\ndf$rowbin &lt;- str_replace_all(df$rowbin, \"B\", \"1\")\ndf$rownum &lt;- BinToDec(df$rowbin)\n\ndf$colbin &lt;- df$X2\ndf$colbin &lt;- str_replace_all(df$colbin, \"L\", \"0\")\ndf$colbin &lt;- str_replace_all(df$colbin, \"R\", \"1\")\ndf$colnum &lt;- BinToDec(df$colbin)\ndf$seatid &lt;- (df$rownum * 8) + df$colnum\nmax(df$seatid)\n\n[1] 828\n\nwrite.csv(df, \"input2.csv\")",
    "crumbs": [
      "2020",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>2020-05: Binary Boarding</span>"
    ]
  },
  {
    "objectID": "2020/05/2020-05.html#part-2",
    "href": "2020/05/2020-05.html#part-2",
    "title": "2020-05: Binary Boarding",
    "section": "Part 2",
    "text": "Part 2\n\ndf &lt;- df[order(df$seatid),]\n\n\nfor(i in 804:1) {\n  if(df$seatid[i + 1] - df$seatid[i] != 1) {\n    myseat &lt;- df$seatid[i + 1] - 1\n    break\n  }\n}\n\nmyseat\n\n[1] 565",
    "crumbs": [
      "2020",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>2020-05: Binary Boarding</span>"
    ]
  },
  {
    "objectID": "2020/06/2020-06.html",
    "href": "2020/06/2020-06.html",
    "title": "2020-06: Custom Customs",
    "section": "",
    "text": "Part 1\nRecycling this from D4P2\ndf &lt;- dt\ntestDF &lt;- df[1,]\ndfRow &lt;- 1\ndfColumn &lt;- 1\nfor(r in 1:2001) {\n  if(!is.na(df[r,1])) {\n    testDF[dfRow, dfColumn] &lt;- df[r,1]\n    dfColumn &lt;- dfColumn + 1\n  }\n  else {\n    dfRow &lt;- dfRow + 1\n    dfColumn &lt;- 1\n  }\n}\ndf &lt;- testDF\ndf\n\n# A tibble: 456 × 5\n   X1                X1                 X1                 X1              X1   \n   &lt;chr&gt;             &lt;chr&gt;              &lt;chr&gt;              &lt;chr&gt;           &lt;chr&gt;\n 1 tr                rt                 tr                 rt              tr   \n 2 fdrhu             gwuksvro           &lt;NA&gt;               &lt;NA&gt;            &lt;NA&gt; \n 3 tesnouwyrdf       twofuspcmvenh      &lt;NA&gt;               &lt;NA&gt;            &lt;NA&gt; \n 4 cnxpsmuqiaw       cxovminqpawus      qwaxjmupnsic       &lt;NA&gt;            &lt;NA&gt; \n 5 anpskchzojyeguwr  soqauprxzgmycvef   sorplgezycau       ngrecposyizwau  ayep…\n 6 mvwcl             vlcwxm             uwcflhpkjor        blnvwtic        wcmzl\n 7 hyvowmqzixc       lacsrjdyxiz        fyczpbxlti         &lt;NA&gt;            &lt;NA&gt; \n 8 qxjhrgefbkm       eqrgbfhjxkcm       &lt;NA&gt;               &lt;NA&gt;            &lt;NA&gt; \n 9 catsrkyjulmfzvixe teyxvimulfkczqrjsa xrtlyaqemsucjzkifv drjlmncsiftxae… &lt;NA&gt; \n10 ocgrnldhja        jicwgntvuhk        cxgajhln           &lt;NA&gt;            &lt;NA&gt; \n# ℹ 446 more rows\ndf[is.na(df)] &lt;- \"\"\ndf$all &lt;- \"\"\nfor(r in 1:456) {\n  df$all[r] &lt;- paste(df[r,1], df[r,2], df[r,3], df[r,4], df[r,5], sep = \"\")\n  df$count[r] &lt;- length(unique(unlist(strsplit(df$all[r], \"\"))))\n}\n\nWarning: Unknown or uninitialised column: `count`.\n\ndf\n\n# A tibble: 456 × 7\n   X1                X1                 X1               X1    X1    all   count\n   &lt;chr&gt;             &lt;chr&gt;              &lt;chr&gt;            &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt;\n 1 tr                rt                 \"tr\"             \"rt\"  \"tr\"  trrt…     2\n 2 fdrhu             gwuksvro           \"\"               \"\"    \"\"    fdrh…    11\n 3 tesnouwyrdf       twofuspcmvenh      \"\"               \"\"    \"\"    tesn…    16\n 4 cnxpsmuqiaw       cxovminqpawus      \"qwaxjmupnsic\"   \"\"    \"\"    cnxp…    14\n 5 anpskchzojyeguwr  soqauprxzgmycvef   \"sorplgezycau\"   \"ngr… \"aye… anps…    24\n 6 mvwcl             vlcwxm             \"uwcflhpkjor\"    \"bln… \"wcm… mvwc…    19\n 7 hyvowmqzixc       lacsrjdyxiz        \"fyczpbxlti\"     \"\"    \"\"    hyvo…    21\n 8 qxjhrgefbkm       eqrgbfhjxkcm       \"\"               \"\"    \"\"    qxjh…    12\n 9 catsrkyjulmfzvixe teyxvimulfkczqrjsa \"xrtlyaqemsucjz… \"drj… \"\"    cats…    21\n10 ocgrnldhja        jicwgntvuhk        \"cxgajhln\"       \"\"    \"\"    ocgr…    17\n# ℹ 446 more rows\nsum(df$count)\n\n[1] 6310",
    "crumbs": [
      "2020",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>2020-06: Custom Customs</span>"
    ]
  },
  {
    "objectID": "2020/06/2020-06.html#part-2",
    "href": "2020/06/2020-06.html#part-2",
    "title": "2020-06: Custom Customs",
    "section": "Part 2",
    "text": "Part 2\n\ndf &lt;- dt\ntestDF &lt;- df[1,]\ndfRow &lt;- 1\ndfColumn &lt;- 1\nfor(r in 1:2001) {\n  if(!is.na(df[r,1])) {\n    testDF[dfRow, dfColumn] &lt;- df[r,1]\n    dfColumn &lt;- dfColumn + 1\n  }\n  else {\n    dfRow &lt;- dfRow + 1\n    dfColumn &lt;- 1\n  }\n}\ndf &lt;- testDF\ndf\n\n# A tibble: 456 × 5\n   X1                X1                 X1                 X1              X1   \n   &lt;chr&gt;             &lt;chr&gt;              &lt;chr&gt;              &lt;chr&gt;           &lt;chr&gt;\n 1 tr                rt                 tr                 rt              tr   \n 2 fdrhu             gwuksvro           &lt;NA&gt;               &lt;NA&gt;            &lt;NA&gt; \n 3 tesnouwyrdf       twofuspcmvenh      &lt;NA&gt;               &lt;NA&gt;            &lt;NA&gt; \n 4 cnxpsmuqiaw       cxovminqpawus      qwaxjmupnsic       &lt;NA&gt;            &lt;NA&gt; \n 5 anpskchzojyeguwr  soqauprxzgmycvef   sorplgezycau       ngrecposyizwau  ayep…\n 6 mvwcl             vlcwxm             uwcflhpkjor        blnvwtic        wcmzl\n 7 hyvowmqzixc       lacsrjdyxiz        fyczpbxlti         &lt;NA&gt;            &lt;NA&gt; \n 8 qxjhrgefbkm       eqrgbfhjxkcm       &lt;NA&gt;               &lt;NA&gt;            &lt;NA&gt; \n 9 catsrkyjulmfzvixe teyxvimulfkczqrjsa xrtlyaqemsucjzkifv drjlmncsiftxae… &lt;NA&gt; \n10 ocgrnldhja        jicwgntvuhk        cxgajhln           &lt;NA&gt;            &lt;NA&gt; \n# ℹ 446 more rows\n\n\nCredit to Matthew McMillan for the idea of using sets\n\nfor(r in 1:456)\n  for(c in 2:5)\n    if(is.na(df[r,c]))\n      df[r,c] &lt;- df[r,1]\ndf$matthew &lt;- NA_integer_\nfor(r in 1:456) {\n  df$matthew[r] &lt;-\n    length(unique(\n      set_intersection(\n        unique(unlist(strsplit(\n          as.character(df[r, 1]), \"\"\n        ))),\n        unique(unlist(strsplit(\n          as.character(df[r, 2]), \"\"\n        ))),\n        unique(unlist(strsplit(\n          as.character(df[r, 3]), \"\"\n        ))),\n        unique(unlist(strsplit(\n          as.character(df[r, 4]), \"\"\n        ))),\n        unique(unlist(strsplit(\n          as.character(df[r, 5]), \"\"\n        )))\n      )\n    ))\n}\n\ndf\n\n# A tibble: 456 × 6\n   X1                X1                 X1                 X1      X1    matthew\n   &lt;chr&gt;             &lt;chr&gt;              &lt;chr&gt;              &lt;chr&gt;   &lt;chr&gt;   &lt;int&gt;\n 1 tr                rt                 tr                 rt      tr          2\n 2 fdrhu             gwuksvro           fdrhu              fdrhu   fdrhu       2\n 3 tesnouwyrdf       twofuspcmvenh      tesnouwyrdf        tesnou… tesn…       8\n 4 cnxpsmuqiaw       cxovminqpawus      qwaxjmupnsic       cnxpsm… cnxp…      11\n 5 anpskchzojyeguwr  soqauprxzgmycvef   sorplgezycau       ngrecp… ayep…      11\n 6 mvwcl             vlcwxm             uwcflhpkjor        blnvwt… wcmzl       3\n 7 hyvowmqzixc       lacsrjdyxiz        fyczpbxlti         hyvowm… hyvo…       5\n 8 qxjhrgefbkm       eqrgbfhjxkcm       qxjhrgefbkm        qxjhrg… qxjh…      11\n 9 catsrkyjulmfzvixe teyxvimulfkczqrjsa xrtlyaqemsucjzkifv drjlmn… cats…      17\n10 ocgrnldhja        jicwgntvuhk        cxgajhln           ocgrnl… ocgr…       5\n# ℹ 446 more rows\n\n\n\nsum(df$matthew)\n\n[1] 3193",
    "crumbs": [
      "2020",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>2020-06: Custom Customs</span>"
    ]
  },
  {
    "objectID": "2020/07/2020-07.html",
    "href": "2020/07/2020-07.html",
    "title": "07: Handy Haversacks",
    "section": "",
    "text": "Part 1\nlongerDF &lt;- data.frame(parent = \"\", nChild = 0, cChild = \"\")\n\nfor(col in seq(3, 9, by = 2)) {\n  for(r in 1:nrow(df)) {\n    if(!is.na(df[r,col-1]))\n      for(i in 1:df[r,col-1]) {\n        longerDF &lt;- rbind(longerDF, data.frame(parent = df[r,1], \n                                               nChild = df[r,col-1], \n                                               cChild = df[r,col]))\n    }\n  }\n}\nlongerDF &lt;- longerDF[-1,]\nshinygoldDF &lt;- \n  longerDF[longerDF$cChild == \"shiny gold\" | longerDF$parent == \"shiny gold\",]\nlevel &lt;- c(\"shiny gold\")\noldRows &lt;- 0\n\nwhile(oldRows != nrow(shinygoldDF)) {\n  oldRows &lt;- nrow(shinygoldDF)\n  level &lt;- unlist(shinygoldDF$parent)\n  shinygoldDF &lt;-\n    df[as.character(df$parent) %in% level |\n         as.character(df$child1C) %in% level |\n         as.character(df$child2C) %in% level |\n         as.character(df$child3C) %in% level |\n         as.character(df$child4C) %in% level, ]\n}\nnrow(shinygoldDF) - 1\n\n[1] 164",
    "crumbs": [
      "2020",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>07: Handy Haversacks</span>"
    ]
  },
  {
    "objectID": "2020/07/2020-07.html#part-2",
    "href": "2020/07/2020-07.html#part-2",
    "title": "07: Handy Haversacks",
    "section": "Part 2",
    "text": "Part 2\n\n\n\n\n\n\nCaution\n\n\n\nThis solution is still under construction.\n\n\n\nshorterDF &lt;-\n  longerDF |&gt;\n  dplyr::summarise(nChild = dplyr::n(), .by = c('parent', 'cChild'))\n\ntraverse &lt;- function(shorterDF, start, i = 0) {\n  if (length(start) == 1) return(i)\n  tmp &lt;- dplyr::filter(shorterDF, parent == start[1])\n  if (nrow(tmp) == 0) return(traverse(shorterDF, start[-1], i + 1))\n  traverse(shorterDF, tmp$cChild, i + 1)\n}\ntraverse(shorterDF, 'shiny gold')\n\n[1] 0\n\n\n\ntibble::tibble(\n  'parent' = c('shiny gold', 'red', 'orange', 'yellow', 'green', 'blue', 'violet'),\n  'nChild' = c(2, 2, 2, 2, 2, 2, 0),\n  'cChild' = c('red', 'orange', 'yellow', 'green', 'blue', 'violet', NA)\n) |&gt;\n  tidyr::uncount(nChild, .remove = FALSE) -&gt; longerDF\n\n\nshorterDF &lt;-\n  longerDF |&gt;\n  dplyr::summarise(nChild = dplyr::n(), .by = c('parent', 'cChild'))\nbags &lt;- \n  c(longerDF$parent, longerDF$cChild) |&gt;\n  unique() |&gt;\n  sort() |&gt;\n  factor()\nbags |&gt;\n  purrr::map_dbl(\\(x) {\n    x &lt;-\n      longerDF |&gt;\n      dplyr::select(parent, cChild) |&gt;\n      dplyr::mutate(dplyr::across(\n        tidyselect::everything(),\n        \\(x) { purrr::map_dbl(x, \\(x) { which(levels(bags) == x) }) }\n      )) |&gt;\n      as.matrix() |&gt;\n      t() |&gt;\n      as.vector() |&gt;\n      igraph::make_graph(n = length(bags)) |&gt;\n      igraph::all_simple_paths(from = which(bags == 'shiny gold'), to = which(bags == x)) |&gt;\n      unlist()\n    x &lt;- x[x != which(bags == 'shiny gold')]\n    shorterDF |&gt;\n      dplyr::filter(cChild %in% bags[x]) |&gt;\n      dplyr::pull(nChild) |&gt;\n      prod()\n  }, .progress = TRUE) |&gt;\n  sum(-1)\n\n[1] 126\n\n\n\n2068 6268 6286 &lt;16014",
    "crumbs": [
      "2020",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>07: Handy Haversacks</span>"
    ]
  },
  {
    "objectID": "2020/08/2020-08.html",
    "href": "2020/08/2020-08.html",
    "title": "2020-08: Handheld Halting",
    "section": "",
    "text": "Part 1\ndf &lt;- masterDF\ndf$ipa &lt;- NA\ndf$ipa[1] &lt;- 0\nacc &lt;- 0\nr &lt;- 1\nflag &lt;- TRUE\n\nwhile(flag == TRUE) {\n  if(as.character(df$ope[r]) == \"acc\" & r &lt;= 626 & r &gt;= 1) {\n    acc &lt;- acc + df$arg[r]\n    flag &lt;- is.na(df$ipa[r + 1])\n    df$ipa[r + 1] &lt;- r\n    r &lt;- r + 1\n    }\n  else if(as.character(df$ope[r]) == \"jmp\" & r + df$arg[r] &lt;= 626 & r + df$arg[r] &gt;= 1) {\n    flag &lt;- is.na(df$ipa[r + df$arg[r]])\n    df$ipa[r + df$arg[r]] &lt;- r\n    r &lt;- r + df$arg[r]\n    }\n  else if(as.character(df$ope[r]) == \"nop\" & r &lt;= 626 & r &gt;= 1) {\n    flag &lt;- is.na(df$ipa[r + 1])\n    df$ipa[r + 1] &lt;- r\n    r &lt;- r + 1\n    }\n}\n\nacc\n\n[1] 1317",
    "crumbs": [
      "2020",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>2020-08: Handheld Halting</span>"
    ]
  },
  {
    "objectID": "2020/08/2020-08.html#part-2",
    "href": "2020/08/2020-08.html#part-2",
    "title": "2020-08: Handheld Halting",
    "section": "Part 2",
    "text": "Part 2\n\nfor(i in 1:626) {\n  df &lt;- masterDF\n  \n  df$ipa &lt;- NA\n  df$ipa[1] &lt;- 0\n  \n  acc &lt;- 0\n  r &lt;- 1\n  \n  flag &lt;- TRUE\n  breakFlag &lt;- FALSE\n  \n  if(as.character(df$ope[i]) == \"nop\")\n    df$ope[i] &lt;- \"jmp\"\n  else if(as.character(df$ope[i]) == \"jmp\")\n    df$ope[i] &lt;- \"nop\"\n  \n  if(as.character(df$ope[i]) != \"acc\") {\n    while(flag) {\n      if(as.character(df$ope[r]) == \"acc\" & r &lt;= 626 & r &gt;= 1) {\n        acc &lt;- acc + df$arg[r]\n        flag &lt;- is.na(df$ipa[r + 1])\n        df$ipa[r + 1] &lt;- r\n        r &lt;- r + 1\n        }\n      else if(as.character(df$ope[r]) == \"jmp\" & r + df$arg[r] &lt;= 626 & r + df$arg[r] &gt;= 1) {\n        flag &lt;- is.na(df$ipa[r + df$arg[r]])\n        df$ipa[r + df$arg[r]] &lt;- r\n        r &lt;- r + df$arg[r]\n        }\n      else if(as.character(df$ope[r]) == \"nop\" & r &lt;= 626 & r &gt;= 1) {\n        flag &lt;- is.na(df$ipa[r + 1])\n        df$ipa[r + 1] &lt;- r\n        r &lt;- r + 1\n      }\n    \n      if(r == 626) {\n        breakFlag &lt;- TRUE\n        break\n        }\n    }\n  }\n  if(breakFlag)\n    break\n}\n\nacc\n\n[1] 1033",
    "crumbs": [
      "2020",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>2020-08: Handheld Halting</span>"
    ]
  },
  {
    "objectID": "2020/09/2020-09.html",
    "href": "2020/09/2020-09.html",
    "title": "2020-09: Encoding Error",
    "section": "",
    "text": "Part 1\ngoodNum &lt;- FALSE\nfor(i in 26:1000) {\n  for(r1 in (i-25):(i-1)) {\n    if(df[r1,1] &lt; df[i,1])\n      for(r2 in (i-25):(i-1))\n        if(df[i,1] - df[r1,1] == df[r2,1]) {\n          goodNum &lt;- TRUE\n          break\n        }\n    if(goodNum)\n      break\n  }\n  if(!goodNum) {\n    print(df[i,1])\n    break\n  }\n  goodNum &lt;- FALSE\n}\n\n[1] 69316178",
    "crumbs": [
      "2020",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>2020-09: Encoding Error</span>"
    ]
  },
  {
    "objectID": "2020/09/2020-09.html#part-2",
    "href": "2020/09/2020-09.html#part-2",
    "title": "2020-09: Encoding Error",
    "section": "Part 2",
    "text": "Part 2\n\ngoalNum &lt;- 0\ngoodNum &lt;- FALSE\nfor(i in 26:1000) {\n  for(r1 in (i-25):(i-1)) {\n    if(df[r1,1] &lt; df[i,1])\n      for(r2 in (i-25):(i-1))\n        if(df[i,1] - df[r1,1] == df[r2,1]) {\n          goodNum &lt;- TRUE\n          break\n        }\n    if(goodNum)\n      break\n  }\n  if(!goodNum) {\n    goalNum &lt;- df[i,1]\n    break\n  }\n  goodNum &lt;- FALSE\n}\n\n\nbreakFlag &lt;- FALSE\nfor(start in 1:1000) {\n  for(end in start:1000) {\n    if(sum(df$num[start:end]) == goalNum) {\n      breakFlag &lt;- TRUE\n      break\n    }\n  }\n  if(breakFlag)\n    break\n}\n\n\nsmallest &lt;- max(df$num)\nlargest &lt;- min(df$num)\n\nfor(r in start:end) {\n  if(df$num[r] &lt; smallest)\n    smallest &lt;- df$num[r]\n  if(df$num[r] &gt; largest)\n    largest &lt;- df$num[r]\n}\n\nsmallest + largest\n\n[1] 9351526",
    "crumbs": [
      "2020",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>2020-09: Encoding Error</span>"
    ]
  },
  {
    "objectID": "2020/10/2020-10.html",
    "href": "2020/10/2020-10.html",
    "title": "2020-10: Adapter Array",
    "section": "",
    "text": "Part 1\ndf &lt;- df[order(df$jolts),]\ncount1 &lt;- 0\ncount3 &lt;- 0\nfor(r in 1:(nrow(df) - 1)) {\n  if(df[r+1,1] - df[r,1] == 1)\n    count1 &lt;- count1 + 1\n  else if(df[r+1,1] - df[r,1] == 3)\n    count3 &lt;- count3 + 1\n}\ncount1 * count3\n\n[1] 2414",
    "crumbs": [
      "2020",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>2020-10: Adapter Array</span>"
    ]
  },
  {
    "objectID": "2020/10/2020-10.html#part-2",
    "href": "2020/10/2020-10.html#part-2",
    "title": "2020-10: Adapter Array",
    "section": "Part 2",
    "text": "Part 2\n\ndf$paths &lt;- 0\ndf$paths[1] &lt;- 1\nfor(i in 2:nrow(df))\n  for(x in 1:3)\n    if((df$jolts[i] - x) %in% df$jolts)\n      df$paths[i] &lt;- df$paths[i] + df$paths[match(df$jolts[i] - x, df$jolts)]\nformat(df$paths[nrow(df) - 1], scientific=FALSE)\n\n[1] \"21156911906816\"",
    "crumbs": [
      "2020",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>2020-10: Adapter Array</span>"
    ]
  },
  {
    "objectID": "2019/01/2019-01.html",
    "href": "2019/01/2019-01.html",
    "title": "2019-01: The Tyranny of the Rocket Equation",
    "section": "",
    "text": "Part 1\nsum(floor(dt / 3) - 2)\n\n[1] 3512133",
    "crumbs": [
      "2019",
      "<span class='chapter-number'>47</span>  <span class='chapter-title'>2019-01: The Tyranny of the Rocket Equation</span>"
    ]
  },
  {
    "objectID": "2019/01/2019-01.html#part-2",
    "href": "2019/01/2019-01.html#part-2",
    "title": "2019-01: The Tyranny of the Rocket Equation",
    "section": "Part 2",
    "text": "Part 2\n\nx &lt;- 1\ntotal &lt;- 0\nsapply(dt, function(x) {\n  total &lt;- 0\n  val &lt;- x\n  while (floor(val / 3) - 2 &gt;= 0) {\n    val &lt;- floor(val / 3) - 2\n    total &lt;- total + val\n  }\n  return(total)\n}) |&gt;\n  sum()\n\n[1] 5265294",
    "crumbs": [
      "2019",
      "<span class='chapter-number'>47</span>  <span class='chapter-title'>2019-01: The Tyranny of the Rocket Equation</span>"
    ]
  },
  {
    "objectID": "2019/02/2019-02.html",
    "href": "2019/02/2019-02.html",
    "title": "2019-02: 1202 Program Alarm",
    "section": "",
    "text": "Part 1\ndt &lt;- dtM\ndt[1 + 1] &lt;- 12\ndt[2 + 1] &lt;- 2\nd &lt;- 0\nx &lt;- 1\nwhile(d != 99) {\n  if (dt[x] == 1) { dt[dt[x + 3] + 1] &lt;- dt[dt[x + 1] + 1] + dt[dt[x + 2] + 1] }\n  else if (dt[x] == 2) { dt[dt[x + 3] + 1] &lt;- dt[dt[x + 1] + 1] * dt[dt[x + 2] + 1] }\n  x &lt;- x + 4\n  d &lt;- dt[x]\n}\ndt[1]\n\n[1] 3706713\n\nx\n\n[1] 125",
    "crumbs": [
      "2019",
      "<span class='chapter-number'>48</span>  <span class='chapter-title'>2019-02: 1202 Program Alarm</span>"
    ]
  },
  {
    "objectID": "2019/02/2019-02.html#part-2",
    "href": "2019/02/2019-02.html#part-2",
    "title": "2019-02: 1202 Program Alarm",
    "section": "Part 2",
    "text": "Part 2\n\nbreakFlag &lt;- FALSE\nfor (i in 0:99) {\n  for (j in 0:99) {\n    dt &lt;- dtM\n    dt[1 + 1] &lt;- i\n    dt[2 + 1] &lt;- j\n    d &lt;- 0\n    x &lt;- 1\n    while (d != 99) {\n      if (dt[x] == 1) {\n        dt[dt[x + 3] + 1] &lt;- dt[dt[x + 1] + 1] + dt[dt[x + 2] + 1]\n      }\n      else if (dt[x] == 2) {\n        dt[dt[x + 3] + 1] &lt;- dt[dt[x + 1] + 1] * dt[dt[x + 2] + 1]\n      }\n      x &lt;- x + 4\n      d &lt;- dt[x]\n    }\n    if (dt[1] == 19690720) {\n      breakFlag &lt;- TRUE\n      break\n    }\n  }\n  if (breakFlag) { break }\n}\n100 * dt[1 + 1] + dt[2 + 1]\n\n[1] 8609",
    "crumbs": [
      "2019",
      "<span class='chapter-number'>48</span>  <span class='chapter-title'>2019-02: 1202 Program Alarm</span>"
    ]
  },
  {
    "objectID": "2019/03/2019-03.html",
    "href": "2019/03/2019-03.html",
    "title": "2019-03: Crossed Wires",
    "section": "",
    "text": "Part 1\ndtM &lt;- lapply(dtMM, expand_directions, preserve_data = TRUE)\n\ndtM[[1]] &lt;- follow_directions(dtM[[1]], 0, 0, preserve_data = TRUE)\ndtM[[2]] &lt;- follow_directions(dtM[[2]], 0, 0, preserve_data = TRUE)\n\ninner_join(dtM[[1]], dtM[[2]], by = c(\"row\", \"col\")) |&gt;\n  mutate(dist = abs(row) + abs(col)) |&gt;\n  arrange(dist) |&gt;\n  head(1) |&gt;\n  pull(dist)\n\n[1] 1264",
    "crumbs": [
      "2019",
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>2019-03: Crossed Wires</span>"
    ]
  },
  {
    "objectID": "2019/03/2019-03.html#part-2",
    "href": "2019/03/2019-03.html#part-2",
    "title": "2019-03: Crossed Wires",
    "section": "Part 2",
    "text": "Part 2\n\ndtM[[1]] &lt;- \n  dtM[[1]] |&gt;\n  mutate(step = row_number())\ndtM[[2]] &lt;- \n  dtM[[2]] |&gt;\n  mutate(step = row_number())\n\ninner_join(dtM[[1]], dtM[[2]], by = c(\"row\", \"col\")) |&gt;\n  mutate(steps = step.x + step.y) |&gt;\n  arrange(steps) |&gt;\n  head(1) |&gt;\n  pull(steps)\n\n[1] 37390",
    "crumbs": [
      "2019",
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>2019-03: Crossed Wires</span>"
    ]
  },
  {
    "objectID": "2019/04/2019-04.html",
    "href": "2019/04/2019-04.html",
    "title": "2019-04: Secure Container",
    "section": "",
    "text": "Part 1\ns1 &lt;- map(dt, \\(password) {\n  s &lt;- str_split(password, \"\", simplify = TRUE)\n  ret1 &lt;- ifelse(all(s == cummax(s)), TRUE, FALSE)\n  ret2 &lt;- ifelse(!str_detect(password, \"(.)\\\\1\"), FALSE, TRUE)\n  \n  ret &lt;- ifelse(ret1 & ret2, TRUE, FALSE)\n  return(ret)\n}) |&gt;\n  unlist()\nsum(s1)\n\n[1] 1178\n\ndt &lt;- dt[s1]",
    "crumbs": [
      "2019",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>2019-04: Secure Container</span>"
    ]
  },
  {
    "objectID": "2019/04/2019-04.html#part-2",
    "href": "2019/04/2019-04.html#part-2",
    "title": "2019-04: Secure Container",
    "section": "Part 2",
    "text": "Part 2\n\ns2 &lt;-\n  sapply(dt, \\(s) {\n    s &lt;- str_split(s, \"\") |&gt; unlist() |&gt; table()\n    s &lt;- ifelse(any(s == 2), TRUE, FALSE)\n    return(s)\n  })\nsum(s2)\n\n[1] 763",
    "crumbs": [
      "2019",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>2019-04: Secure Container</span>"
    ]
  },
  {
    "objectID": "2018/01/2018-01.html",
    "href": "2018/01/2018-01.html",
    "title": "2018-01: Chronal Calibration",
    "section": "",
    "text": "Part 1\nhttps://adventofcode.com/2018/day/1\nsum(dt$V1)\n\n[1] 425",
    "crumbs": [
      "2018",
      "<span class='chapter-number'>51</span>  <span class='chapter-title'>2018-01: Chronal Calibration</span>"
    ]
  },
  {
    "objectID": "2018/01/2018-01.html#part-2",
    "href": "2018/01/2018-01.html#part-2",
    "title": "2018-01: Chronal Calibration",
    "section": "Part 2",
    "text": "Part 2\n\nbreakFlag &lt;- FALSE\nre_pete &lt;- 1\nwhile (!breakFlag) {\n  vec &lt;- cumsum(rep(dt$V1, re_pete))\n  \n  twice &lt;- vec[duplicated(vec)]\n  \n  if (length(twice &gt;= 1)) {\n    print(twice[1])\n    breakFlag &lt;- TRUE\n  } else {\n    re_pete &lt;- re_pete + 1\n  }\n}\n\n[1] 57538",
    "crumbs": [
      "2018",
      "<span class='chapter-number'>51</span>  <span class='chapter-title'>2018-01: Chronal Calibration</span>"
    ]
  },
  {
    "objectID": "2018/02/2018-02.html",
    "href": "2018/02/2018-02.html",
    "title": "2018-02: Inventory Management System",
    "section": "",
    "text": "Part 1\nsapply(strsplit(dt$V1, \"\"), function(x) {\n  x &lt;- table(x)\n  x &lt;- unique(x[x %in% 2:3])\n}) |&gt;\n  unlist() |&gt;\n  unname() |&gt;\n  table() |&gt;\n  prod()\n\n[1] 8118",
    "crumbs": [
      "2018",
      "<span class='chapter-number'>52</span>  <span class='chapter-title'>2018-02: Inventory Management System</span>"
    ]
  },
  {
    "objectID": "2018/02/2018-02.html#part-2",
    "href": "2018/02/2018-02.html#part-2",
    "title": "2018-02: Inventory Management System",
    "section": "Part 2",
    "text": "Part 2\n\nmat &lt;- adist(dt$V1)\nmat &lt;- as.character(expand.grid(dt$V1, dt$V1)[which(mat == 1),][,1])\nmat &lt;- strsplit(mat, \"\")\npaste0(mat[[1]][mat[[1]] == mat[[2]]], collapse = \"\")\n\n[1] \"jbbenqtlaxhivmwyscjukztdp\"",
    "crumbs": [
      "2018",
      "<span class='chapter-number'>52</span>  <span class='chapter-title'>2018-02: Inventory Management System</span>"
    ]
  },
  {
    "objectID": "2018/03/2018-03.html",
    "href": "2018/03/2018-03.html",
    "title": "2018-03: No Matter How You Slice It",
    "section": "",
    "text": "Part 1\nmat &lt;- matrix(0, 1000, 1000)\nfor(x in 1:nrow(dt)) {\n  xPos &lt;- dt$xPos[x] + 1\n  xSize &lt;- dt$xSize[x] - 1\n  yPos &lt;- dt$yPos[x] + 1\n  ySize &lt;- dt$ySize[x] - 1\n  mat[xPos:(xPos + xSize), yPos:(yPos + ySize)] &lt;- \n    mat[xPos:(xPos + xSize), yPos:(yPos + ySize)] + 1\n}\nlength(mat[mat &gt;= 2])\n\n[1] 98005",
    "crumbs": [
      "2018",
      "<span class='chapter-number'>53</span>  <span class='chapter-title'>2018-03: No Matter How You Slice It</span>"
    ]
  },
  {
    "objectID": "2018/03/2018-03.html#part-2",
    "href": "2018/03/2018-03.html#part-2",
    "title": "2018-03: No Matter How You Slice It",
    "section": "Part 2",
    "text": "Part 2\n\nfor(x in 1:nrow(dt)) {\n  xPos &lt;- dt$xPos[x] + 1\n  xSize &lt;- dt$xSize[x] - 1\n  yPos &lt;- dt$yPos[x] + 1\n  ySize &lt;- dt$ySize[x] - 1\n  if (all(mat[xPos:(xPos + xSize), yPos:(yPos + ySize)] == 1)) { print(x) }\n}\n\n[1] 331",
    "crumbs": [
      "2018",
      "<span class='chapter-number'>53</span>  <span class='chapter-title'>2018-03: No Matter How You Slice It</span>"
    ]
  },
  {
    "objectID": "2018/04/2018-04.html",
    "href": "2018/04/2018-04.html",
    "title": "2018-04: Repose Record",
    "section": "",
    "text": "Part 1\ndata.table(\"day\" =\n             rep(seq.Date(as.Date(min(dt$time)), \n                          as.Date(max(dt$time)), \n                          by = \"day\"), \n                 each = 60),\n           \"minute\" = 0:59) |&gt;\n  left_join(dt, by = c(\"day\", \"minute\")) |&gt;\n  select(-time) |&gt;\n  arrange(day, minute) |&gt;\n  fill(action, guard) |&gt;\n  filter(action == \"asleep\") |&gt;\n  dcast(guard ~ minute, value.var = \"action\", fun.aggregate = length) -&gt; saved\nsaved %&gt;%\n  mutate(total = rowSums(.) - guard) |&gt;\n  filter(total == max(total)) |&gt;\n  select(-total) |&gt;\n  as.vector() |&gt;\n  unlist() -&gt; vec\n\nunname(vec[\"guard\"] * as.numeric(names(which.max(vec[-1]))))\n\n[1] 146622",
    "crumbs": [
      "2018",
      "<span class='chapter-number'>54</span>  <span class='chapter-title'>2018-04: Repose Record</span>"
    ]
  },
  {
    "objectID": "2018/04/2018-04.html#part-2",
    "href": "2018/04/2018-04.html#part-2",
    "title": "2018-04: Repose Record",
    "section": "Part 2",
    "text": "Part 2\n\nsaved |&gt;\n  pivot_longer(cols = matches(\"[0-9]{1,2}\"), names_to = \"minute\", values_to = \"times\") |&gt;\n  filter(times == max(times)) |&gt;\n  mutate(value = guard * as.numeric(minute)) |&gt;\n  pull(value)\n\n[1] 31848",
    "crumbs": [
      "2018",
      "<span class='chapter-number'>54</span>  <span class='chapter-title'>2018-04: Repose Record</span>"
    ]
  },
  {
    "objectID": "2018/05/2018-05.html",
    "href": "2018/05/2018-05.html",
    "title": "2018-05: Alchemical Reduction",
    "section": "",
    "text": "Part 1\nreduced &lt;- TRUE\nwhile(reduced) {\n  old &lt;- length(dt)\n  for (x in 1:(old - 1)) {\n    if (dt[x] != dt[x + 1] & toupper(dt[x]) == toupper(dt[x + 1])) {\n      dt[c(x, x + 1)] &lt;- \"\"\n      reduced &lt;- TRUE\n    }\n  }\n  dt &lt;- dt[dt != \"\"]\n  if(old == length(dt)) {\n    reduced &lt;- FALSE\n  }\n}\nlength(dt)\n\n[1] 10598",
    "crumbs": [
      "2018",
      "<span class='chapter-number'>55</span>  <span class='chapter-title'>2018-05: Alchemical Reduction</span>"
    ]
  },
  {
    "objectID": "2018/05/2018-05.html#part-2",
    "href": "2018/05/2018-05.html#part-2",
    "title": "2018-05: Alchemical Reduction",
    "section": "Part 2",
    "text": "Part 2\n\nsapply(1:26, function(l) {\n  tmp &lt;- stri_replace_all_regex(dt, paste0(letters[l], \"|\", LETTERS[l]), \"\")\n  reduced &lt;- TRUE\n  while (reduced) {\n    old &lt;- length(tmp)\n    for (x in 1:(old - 1)) {\n      if (tmp[x] != tmp[x + 1] & toupper(tmp[x]) == toupper(tmp[x + 1])) {\n        tmp[c(x, x + 1)] &lt;- \"\"\n        reduced &lt;- TRUE\n      }\n    }\n    tmp &lt;- tmp[tmp != \"\"]\n    if (old == length(tmp)) {\n      reduced &lt;- FALSE\n    }\n  }\n  length(tmp)\n}) |&gt;\n  min()\n\n[1] 5312",
    "crumbs": [
      "2018",
      "<span class='chapter-number'>55</span>  <span class='chapter-title'>2018-05: Alchemical Reduction</span>"
    ]
  },
  {
    "objectID": "2018/06/2018-06.html",
    "href": "2018/06/2018-06.html",
    "title": "2018-06: Chronal Coordinates",
    "section": "",
    "text": "Part 1\nsize &lt;- max(max(dt$x), max(dt$y))\nmat &lt;- matrix(NA, size, size)\nmat[as.matrix(dt[, 1:2])] &lt;- dt$id\n\nfor(x in 1:ncol(mat)) {\n  for(y in 1:nrow(mat)) {\n    distX &lt;- abs(x - dt$x)\n    distY &lt;- abs(y - dt$y)\n    dist &lt;- (distX + distY) / 2\n    closest &lt;- dist[dist == min(dist)]\n    mat[x,y] &lt;- ifelse(length(closest) == 1, which.min(dist), NA)\n  }\n}\n\nedges &lt;- unique(c(mat[1, ], mat[,1], mat[nrow(mat), ], mat[, ncol(mat)]))\nmat[mat %in% edges] &lt;- NA\nmax(table(mat))\n\n[1] 4166",
    "crumbs": [
      "2018",
      "<span class='chapter-number'>56</span>  <span class='chapter-title'>2018-06: Chronal Coordinates</span>"
    ]
  },
  {
    "objectID": "2018/06/2018-06.html#part-2",
    "href": "2018/06/2018-06.html#part-2",
    "title": "2018-06: Chronal Coordinates",
    "section": "Part 2",
    "text": "Part 2\n\ngrid &lt;- expand.grid(1:size, 1:size)\nsapply(1:nrow(grid), function(i) {\n  dist &lt;- abs(dt$x - grid$Var1[i]) + abs(dt$y - grid$Var2[i])\n  if(sum(dist) &lt; 10000) { return(i) }\n  else { return(NA) }\n}) |&gt; \n  na.exclude() |&gt;\n  length()\n\n[1] 42250",
    "crumbs": [
      "2018",
      "<span class='chapter-number'>56</span>  <span class='chapter-title'>2018-06: Chronal Coordinates</span>"
    ]
  },
  {
    "objectID": "2017/01/2017-01.html",
    "href": "2017/01/2017-01.html",
    "title": "01: Inverse Captcha",
    "section": "",
    "text": "Part 1\ndata.table(\n  \"input\" = c(dt),\n  \"test\" = c(dt[-1], dt[1])\n) %&gt;%\n  .[, \"valid\" := ifelse(input == test, TRUE, FALSE)] %&gt;%\n  .[valid == TRUE, test] %&gt;%\n  sum()\n\n[1] 1031",
    "crumbs": [
      "2017",
      "<span class='chapter-number'>57</span>  <span class='chapter-title'>01: Inverse Captcha</span>"
    ]
  },
  {
    "objectID": "2017/01/2017-01.html#part-2",
    "href": "2017/01/2017-01.html#part-2",
    "title": "01: Inverse Captcha",
    "section": "Part 2",
    "text": "Part 2\n\nlen &lt;- length(dt) / 2\ndata.table(\n  \"input\" = c(dt),\n  \"test\" = c(dt[(len + 1):length(dt)], dt[1:len])\n) %&gt;%\n  .[, \"valid\" := ifelse(input == test, TRUE, FALSE)] %&gt;%\n  .[valid == TRUE, test] %&gt;%\n  sum()\n\n[1] 1080",
    "crumbs": [
      "2017",
      "<span class='chapter-number'>57</span>  <span class='chapter-title'>01: Inverse Captcha</span>"
    ]
  },
  {
    "objectID": "2017/02/2017-02.html",
    "href": "2017/02/2017-02.html",
    "title": "02: Corruption Checksum",
    "section": "",
    "text": "Part 1\ndt %&gt;%\n  rowwise() %&gt;%\n  mutate(\n    \"min\" = min(across()),\n    \"max\" = max(across())\n  ) %&gt;%\n  mutate(\"diff\" = max - min) %&gt;%\n  pull(diff) %&gt;%\n  sum()\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `min = min(across())`.\nℹ In row 1.\nCaused by warning:\n! Using `across()` without supplying `.cols` was deprecated in dplyr 1.1.0.\nℹ Please supply `.cols` instead.\n\n\n[1] 36174",
    "crumbs": [
      "2017",
      "<span class='chapter-number'>58</span>  <span class='chapter-title'>02: Corruption Checksum</span>"
    ]
  },
  {
    "objectID": "2017/02/2017-02.html#part-2",
    "href": "2017/02/2017-02.html#part-2",
    "title": "02: Corruption Checksum",
    "section": "Part 2",
    "text": "Part 2\n\napply(dt, 1, function(x) {\n  expand.grid(x, x) %&gt;%\n    filter(Var1 != Var2) %&gt;%\n    mutate(\"valid\" = ifelse(Var1 %% Var2 == 0, TRUE, FALSE)) %&gt;%\n    filter(valid) %&gt;%\n    mutate(\"val\" = Var1 / Var2) %&gt;%\n    pull(val)\n}) %&gt;%\n  sum()\n\n[1] 244",
    "crumbs": [
      "2017",
      "<span class='chapter-number'>58</span>  <span class='chapter-title'>02: Corruption Checksum</span>"
    ]
  },
  {
    "objectID": "2017/03/2017-03.html",
    "href": "2017/03/2017-03.html",
    "title": "03: Spiral Memory",
    "section": "",
    "text": "Part 1\ngrid_dim &lt;- ceiling(sqrt(input))\n\ndiff &lt;- (grid_dim ^ 2) - input\n\nside &lt;- case_when(\n  diff &lt; grid_dim ~ \"bottom\",\n  diff &gt;= grid_dim & diff &lt; grid_dim * 2 ~ \"left\",\n  diff &gt;= grid_dim * 2 & diff &lt; grid_dim * 3 ~ \"top\",\n  diff &gt;= grid_dim * 3 & diff &lt; grid_dim * 4 ~ \"right\",\n)\n\nmid &lt;- ((grid_dim - 1) / 2)\nabs((grid_dim - diff) - mid) + mid - 1\n\n[1] 438",
    "crumbs": [
      "2017",
      "<span class='chapter-number'>59</span>  <span class='chapter-title'>03: Spiral Memory</span>"
    ]
  },
  {
    "objectID": "2017/03/2017-03.html#part-2",
    "href": "2017/03/2017-03.html#part-2",
    "title": "03: Spiral Memory",
    "section": "Part 2",
    "text": "Part 2\nI don’t know why I struggled. This was actually kinda fun. Getting the logic for the movements was odd.\n\nm &lt;- matrix(1, 1, 1)\npoint = list(x = 1, y = 1)\nrepeat {\n  if (point$y == nrow(m) & point$x == ncol(m)) {\n    tmp &lt;- matrix(NA_integer_, ncol(m) + 2, nrow(m) + 2)\n    tmp[2:(nrow(tmp) - 1), 2:(ncol(tmp) - 1)] &lt;- m\n    m &lt;- tmp\n    point$x &lt;- point$x + 2\n    point$y &lt;- point$y + 1\n  } else if (point$x == ncol(m) & point$y != 1) {\n    point$y &lt;- point$y - 1\n  } else if (point$x &lt;= ncol(m) & point$y == 1 & point$x - 1 &gt;= 1) {\n    point$x &lt;- point$x - 1\n  } else if (point$x == 1 & point$y &gt;= 1 & point$y + 1 &lt;= nrow(m)) {\n    point$y &lt;- point$y + 1\n  } else {\n    point$x &lt;- point$x + 1\n  }\n  m[point$y, point$x] &lt;-\n    sum(get_adjacent_values(point$y, point$x, m), na.rm = TRUE)\n  # print(m)\n  if (m[point$y, point$x] &gt; input) break\n}\nmax(m, na.rm = TRUE)\n\n[1] 266330",
    "crumbs": [
      "2017",
      "<span class='chapter-number'>59</span>  <span class='chapter-title'>03: Spiral Memory</span>"
    ]
  },
  {
    "objectID": "2017/04/2017-04.html",
    "href": "2017/04/2017-04.html",
    "title": "04: High-Entropy Passphrases",
    "section": "",
    "text": "Part 1\nEasy enough. I wanted to do it in one pipe-line, but couldn’t think of anything efficient enough.\n\"input.txt\" |&gt;\n  readLines() |&gt;\n  map_lgl(\\(x) {\n    x &lt;-\n      x |&gt;\n      str_split_1(\" \") |&gt;\n      table()\n    all(x == 1)\n  }) |&gt;\n  sum()\n\n[1] 477",
    "crumbs": [
      "2017",
      "<span class='chapter-number'>60</span>  <span class='chapter-title'>04: High-Entropy Passphrases</span>"
    ]
  },
  {
    "objectID": "2017/04/2017-04.html#part-2",
    "href": "2017/04/2017-04.html#part-2",
    "title": "04: High-Entropy Passphrases",
    "section": "Part 2",
    "text": "Part 2\nI thought this would be harder, but then I realized I can just sort each string then use table again.\n\n\"input.txt\" |&gt;\n  readLines() |&gt;\n  map_lgl(\\(x) {\n    x &lt;-\n      x |&gt;\n      str_split_1(\" \") |&gt;\n      map_chr(\\(y) {\n        y |&gt;\n          str_split_1(\"\") |&gt;\n          sort() |&gt;\n          paste0(collapse = \"\")\n      }) |&gt;\n      table()\n    all(x == 1)\n  }) |&gt;\n  sum()\n\n[1] 167",
    "crumbs": [
      "2017",
      "<span class='chapter-number'>60</span>  <span class='chapter-title'>04: High-Entropy Passphrases</span>"
    ]
  },
  {
    "objectID": "2017/05/2017-05.html",
    "href": "2017/05/2017-05.html",
    "title": "05: A Maze of Twisty Trampolines, All Alike",
    "section": "",
    "text": "Part 1\nI tried recursion first, had a bit of trouble, then got C stack errors. Back to while loops we go…\nx &lt;- x2\npos &lt;- 1\ninc &lt;- 0\nwhile(pos &gt;= 1 & pos &lt;= length(x)) {\n  x[pos] &lt;- x[pos] + 1\n  pos &lt;- pos + x[pos] - 1\n  inc &lt;- inc + 1\n}\ninc\n\n[1] 376976",
    "crumbs": [
      "2017",
      "<span class='chapter-number'>61</span>  <span class='chapter-title'>05: A Maze of Twisty Trampolines, All Alike</span>"
    ]
  },
  {
    "objectID": "2017/05/2017-05.html#part-2",
    "href": "2017/05/2017-05.html#part-2",
    "title": "05: A Maze of Twisty Trampolines, All Alike",
    "section": "Part 2",
    "text": "Part 2\nFor some reason I struggled with getting the logic in the right order, but a poor night’s sleep does wonders :|\n\nx &lt;- x2\npos &lt;- 1\ninc &lt;- 0\nwhile(pos &gt;= 1 & pos &lt;= length(x)) {\n  jmp &lt;- x[pos]\n  x[pos] &lt;- if(x[pos] &gt;= 3) x[pos] - 1 else x[pos] + 1\n  inc &lt;- inc + 1\n  pos &lt;- pos + jmp\n}\ninc\n\n[1] 29227751",
    "crumbs": [
      "2017",
      "<span class='chapter-number'>61</span>  <span class='chapter-title'>05: A Maze of Twisty Trampolines, All Alike</span>"
    ]
  },
  {
    "objectID": "2017/08/2017-08.html",
    "href": "2017/08/2017-08.html",
    "title": "08: I Heard You Like Registers",
    "section": "",
    "text": "Part 1\nThis was so much fun. I like that I had to hack around my computer a bit with the proc function to do the actual processing, but it’s good to keep in my back pocket for later.\nregisters &lt;- \n  dt$V1 |&gt;\n  unique() |&gt;\n  sort()\nregisters &lt;- \n  rep(0L, length(registers)) |&gt;\n  as.list() |&gt;\n  `names&lt;-`(registers)\n\nfunctions &lt;- list(\n  \"proc\" = \\(x, y) {\n    x &lt;- str_match(x, \"([a-z]+) (inc|dec) (-?[0-9]+) if (.*)\")[1,-1]\n    iff &lt;- eval(parse(text = glue(\"self${x[4]}\")))\n    if (iff) {\n      self[[x[1]]] &lt;- self[[x[2]]](x[1], as.integer(x[3]))\n    }\n    private$.inc()\n  },\n  \"inc\" = \\(x, y) {\n    self[[x]] &lt;- self[[x]] + y\n  },\n  \"dec\" = \\(x, y) {\n    self[[x]] &lt;- self[[x]] - y\n  }\n)\n\nx &lt;- \n  readLines(\"input.txt\") |&gt;\n  add_processor()\na &lt;- create_assembly(registers, functions)$run(x)\nas.list(a)[names(registers)] |&gt;\n  unlist() |&gt;\n  max()\n\n[1] 2971",
    "crumbs": [
      "2017",
      "<span class='chapter-number'>62</span>  <span class='chapter-title'>08: I Heard You Like Registers</span>"
    ]
  },
  {
    "objectID": "2017/08/2017-08.html#part-2",
    "href": "2017/08/2017-08.html#part-2",
    "title": "08: I Heard You Like Registers",
    "section": "Part 2",
    "text": "Part 2\nHmmm. Okay. Small register and function mods and we’re good to go!\n\nregisters$maximum_value &lt;- 0L\n\nfunctions$proc &lt;- \\(x, y) {\n  x &lt;- str_match(x, \"([a-z]+) (inc|dec) (-?[0-9]+) if (.*)\")[1,-1]\n    iff &lt;- eval(parse(text = glue(\"self${x[4]}\")))\n    if (iff) {\n      self[[x[1]]] &lt;- self[[x[2]]](x[1], as.integer(x[3]))\n      if (self[[x[1]]] &gt; self$maximum_value) self$maximum_value &lt;- self[[x[1]]]\n    }\n    private$.inc()\n}\n\ncreate_assembly(registers, functions)$run(x, target = \"maximum_value\")\n\n[1] 4254",
    "crumbs": [
      "2017",
      "<span class='chapter-number'>62</span>  <span class='chapter-title'>08: I Heard You Like Registers</span>"
    ]
  },
  {
    "objectID": "2017/16/2017-16.html",
    "href": "2017/16/2017-16.html",
    "title": "16: Permutation Promenade",
    "section": "",
    "text": "Part 1\nI hate zero indexed stuff… But it’s fun to keep using create_assembly\nregisters &lt;-\n  1:16 |&gt;\n  as.list() |&gt;\n  `names&lt;-`(letters[1:16])\n\nfunctions &lt;- list(\n  \"proc\" = \\(x, y) {\n    y &lt;- stringr::str_split_fixed(x, \"/\", 2)\n    yy &lt;- stringr::str_split_fixed(y[,1], \"\", 2)\n    x &lt;- c(yy, y[,-1])\n    \n    x[1] &lt;- case_match(\n      x[1],\n      \"s\" ~ \"spin\",\n      \"x\" ~ \"exchange\",\n      \"p\" ~ \"partner\"\n    )\n    self[[x[1]]](x[2], x[3])\n    \n    private$.inc()\n  },\n  \"spin\" = \\(x, y) {\n    x &lt;- as.integer(x)\n    for (r in letters[1:16]) {\n      self[[r]] &lt;- (self[[r]] + as.integer(x)) %% length(registers)\n      if (self[[r]] == 0) self[[r]] &lt;- length(registers)\n    }\n  },\n  \"exchange\" = \\(x, y) {\n    x &lt;- as.integer(x) + 1\n    y &lt;- as.integer(y) + 1\n    pos &lt;- sapply(letters[1:16], \\(r) self[[r]])\n    x &lt;- names(which(pos == x))\n    y &lt;- names(which(pos == y))\n    self$partner(x, y)\n  },\n  \"partner\" = \\(x, y) {\n    tmp &lt;- self[[y]]\n    self[[y]] &lt;- self[[x]]\n    self[[x]] &lt;- tmp\n  }\n)\n\na &lt;- create_assembly(registers, functions)$run(x)\nas.list(a)[letters[1:16]] |&gt;\n  unlist() |&gt;\n  sort() |&gt;\n  names() |&gt;\n  paste0(collapse = \"\")\n\n[1] \"ceijbfoamgkdnlph\"",
    "crumbs": [
      "2017",
      "<span class='chapter-number'>63</span>  <span class='chapter-title'>16: Permutation Promenade</span>"
    ]
  },
  {
    "objectID": "2017/16/2017-16.html#part-2",
    "href": "2017/16/2017-16.html#part-2",
    "title": "16: Permutation Promenade",
    "section": "Part 2",
    "text": "Part 2\nIt’s going to loop at some point and I need to track that. Ugh. Just track the new ones until it repeats, then modulo. Slow, but it works.\n\nseen &lt;- c()\n\ni &lt;- 0\nrepeat {\n  a &lt;- create_assembly(registers, functions)$run(x)\n  registers &lt;- as.list(a)[letters[1:16]]\n  new_a &lt;-\n    registers |&gt;\n    unlist() |&gt;\n    sort() |&gt;\n    names() |&gt;\n    paste0(collapse = \"\")\n  if (new_a %in% seen) break else seen &lt;- c(seen, new_a)\n  i &lt;- i + 1\n}\n\nseen[1e9 %% i]\n\n[1] \"pnhajoekigcbflmd\"",
    "crumbs": [
      "2017",
      "<span class='chapter-number'>63</span>  <span class='chapter-title'>16: Permutation Promenade</span>"
    ]
  },
  {
    "objectID": "2016/01/2016-01.html",
    "href": "2016/01/2016-01.html",
    "title": "2016-01: No Time for a Taxicab",
    "section": "",
    "text": "Part 1\ndt$deg &lt;- 0\nfor(i in 2:nrow(dt)) {\n  if(dt$dir[i] == \"R\") { dt$deg[i] &lt;- dt$deg[i-1] + 90 }\n  else {dt$deg[i] &lt;- dt$deg[i-1] - 90}\n}\ndt |&gt;\n  mutate(deg = deg %% 360, \n         dis = ifelse(deg %in% c(180, 270), -dis, dis)) |&gt;\n  group_by(deg) |&gt;\n  summarise(n = sum(dis)) |&gt;\n  pull(n) |&gt;\n  sum()\n\n[1] 250",
    "crumbs": [
      "2016",
      "<span class='chapter-number'>64</span>  <span class='chapter-title'>2016-01: No Time for a Taxicab</span>"
    ]
  },
  {
    "objectID": "2016/01/2016-01.html#part-2",
    "href": "2016/01/2016-01.html#part-2",
    "title": "2016-01: No Time for a Taxicab",
    "section": "Part 2",
    "text": "Part 2\n\npoints &lt;- matrix(c(ifelse(dt$dir[1] == \"R\", dt$dis[1], -dt$dis[1]), 0), 1, 2)\nfor (j in 2:nrow(dt)) {\n  tmp &lt;- dt[1:j,]\n  tmp$deg &lt;- 0\n  for (i in 2:j) {\n    if (tmp$dir[i] == \"R\") { tmp$deg[i] &lt;- tmp$deg[i - 1] + 90 }\n    else {  tmp$deg[i] &lt;- tmp$deg[i - 1] - 90 }\n  }\n  tmp |&gt;\n    mutate(deg = deg %% 360,\n           dis = ifelse(deg %in% c(180, 270), -dis, dis)) |&gt;\n    group_by(deg) |&gt;\n      summarise(n = sum(dis)) |&gt;\n      ungroup() |&gt;\n    mutate(deg = ifelse(deg %% 360 %in% c(0, 180), TRUE, FALSE)) |&gt;\n    group_by(deg) |&gt;\n      summarise(n = sum(n)) |&gt;\n      ungroup() |&gt;\n    pull(n) -&gt; point\n  points &lt;- rbind(points, unname(point))\n}\npoints &lt;- rbind(t(c(0, 0)), points)\n\ntmp &lt;- t(c(NA, NA))\n\nfor(i in 1:(nrow(points) - 1)) {\n  tmp &lt;- \n    rbind(tmp, cbind(points[i,1]:points[i+1,1], points[i,2]:points[i+1,2]))\n}\n\nWarning in cbind(points[i, 1]:points[i + 1, 1], points[i, 2]:points[i + :\nnumber of rows of result is not a multiple of vector length (arg 1)\n\ntmp &lt;- tmp[-1,]\nfor(i in 1:(nrow(tmp) - 1)) {\n  if(all(tmp[i,] == tmp[i+1,])) {\n    tmp[i,] &lt;- t(c(NA, NA))\n  }\n}\ntmp &lt;- na.omit(tmp)\nsum(tmp[duplicated(tmp),][1,])\n\n[1] 151",
    "crumbs": [
      "2016",
      "<span class='chapter-number'>64</span>  <span class='chapter-title'>2016-01: No Time for a Taxicab</span>"
    ]
  },
  {
    "objectID": "2016/02/2016-02.html",
    "href": "2016/02/2016-02.html",
    "title": "2016-02: Bathroom Security",
    "section": "",
    "text": "Part 1\nmat &lt;- matrix(1:9, 3, 3)\n\nstartX &lt;&lt;- 2\nstartY &lt;&lt;- 2\napply(dt, 1, function(x) {\n  sapply(unlist(stri_match_all_regex(x, \"[ULRD]\")), function(y) {\n    if (y == \"U\") { startY &lt;&lt;- startY - 1 }\n    else if (y == \"D\") { startY &lt;&lt;- startY + 1 }\n    else if (y == \"L\") { startX &lt;&lt;- startX - 1 }\n    else { startX &lt;&lt;- startX + 1 }\n    \n    if(startX == 0) { startX &lt;&lt;- 1 }\n    else if (startX == 4) {startX &lt;&lt;- 3}\n    \n    if(startY == 0) { startY &lt;&lt;- 1 }\n    else if (startY == 4) {startY &lt;&lt;- 3}\n  })\n  return(rbind(startX, startY))\n}) |&gt; \n  t() |&gt;\n  apply(1, function(x) {\n    return(mat[x[1], x[2]])\n  }) |&gt;\n  paste0(collapse = \"\")\n\n[1] \"82958\"",
    "crumbs": [
      "2016",
      "<span class='chapter-number'>65</span>  <span class='chapter-title'>2016-02: Bathroom Security</span>"
    ]
  },
  {
    "objectID": "2016/02/2016-02.html#part-2",
    "href": "2016/02/2016-02.html#part-2",
    "title": "2016-02: Bathroom Security",
    "section": "Part 2",
    "text": "Part 2\n\nmat &lt;- as.matrix(fread(\"grid2.csv\", header = FALSE, na.strings = \"\"))\n\nstartX &lt;&lt;- 3\nstartY &lt;&lt;- 1\n\napply(dt, 1, function(x) {\n  sapply(unlist(stri_match_all_regex(x, \"[ULRD]\")), function(y) {\n    if (y == \"L\") { \n      startY &lt;&lt;- startY - 1\n      if (startY == 0 || is.na(mat[startX,startY])) { startY &lt;&lt;- startY + 1 }\n    } else if (y == \"R\") { \n      startY &lt;&lt;- startY + 1 \n      if (startY == 6 || is.na(mat[startX,startY])) { startY &lt;&lt;- startY - 1 }\n    } else if (y == \"U\") { \n      startX &lt;&lt;- startX - 1 \n      if (startX == 0 || is.na(mat[startX,startY])) { startX &lt;&lt;- startX + 1 }\n    } else { \n      startX &lt;&lt;- startX + 1 \n      if (startX == 6 || is.na(mat[startX,startY])) { startX &lt;&lt;- startX - 1 }\n    }\n  })\n  return(rbind(startX, startY))\n}) |&gt; \n  t() |&gt;\n  apply(1, function(x) {\n    return(mat[x[1], x[2]])\n  }) |&gt;\n  paste0(collapse = \"\") |&gt;\n  stri_replace_all_regex(\" \", \"\")\n\n[1] \"B3DB8\"",
    "crumbs": [
      "2016",
      "<span class='chapter-number'>65</span>  <span class='chapter-title'>2016-02: Bathroom Security</span>"
    ]
  },
  {
    "objectID": "2016/03/2016-03.html",
    "href": "2016/03/2016-03.html",
    "title": "2016-03: Squares With Three Sides",
    "section": "",
    "text": "Part 1\ndt &lt;- dtM\ndt$valid &lt;- ifelse(dt$a + dt$b &gt; dt$c &\n                     dt$a + dt$c &gt; dt$b &\n                     dt$b + dt$c &gt; dt$a, TRUE, FALSE)\ntable(dt$valid)[\"TRUE\"]\n\nTRUE \n 862",
    "crumbs": [
      "2016",
      "<span class='chapter-number'>66</span>  <span class='chapter-title'>2016-03: Squares With Three Sides</span>"
    ]
  },
  {
    "objectID": "2016/03/2016-03.html#part-2",
    "href": "2016/03/2016-03.html#part-2",
    "title": "2016-03: Squares With Three Sides",
    "section": "Part 2",
    "text": "Part 2\n\ndt &lt;- dtM\ndt &lt;- data.table(t(matrix(c(dt$a, dt$b, dt$c), 3, nrow(dt)))) |&gt;\n  `colnames&lt;-`(c(letters[1:3]))\n\ndt$valid &lt;- ifelse(dt$a + dt$b &gt; dt$c & \n                     dt$a + dt$c &gt; dt$b &\n                     dt$b + dt$c &gt; dt$a, TRUE, FALSE)\ntable(dt$valid)[\"TRUE\"]\n\nTRUE \n1577",
    "crumbs": [
      "2016",
      "<span class='chapter-number'>66</span>  <span class='chapter-title'>2016-03: Squares With Three Sides</span>"
    ]
  },
  {
    "objectID": "2016/04/2016-04.html",
    "href": "2016/04/2016-04.html",
    "title": "2016-04: Security Through Obscurity",
    "section": "",
    "text": "Part 1\nstri_extract_all_regex(dt, \"[a-z]+\") |&gt;\n  lapply(function(x) {\n    x &lt;- paste0(x, collapse = \"\") |&gt;\n      strsplit(\"\") |&gt;\n      unlist()\n    check &lt;- x[(length(x) - 4):length(x)]\n    x &lt;- x[1:(length(x) - 4)]\n    x &lt;- sort(table(x), decreasing = TRUE)[1:5]\n    \n    check &lt;- paste0(check, collapse = \"\")\n    x &lt;- paste0(names(x), collapse = \"\")\n    \n    if(x == check) { return(TRUE) }\n    return(FALSE)\n  }) |&gt;\n  unlist() -&gt; tmp\n\ndt[tmp] |&gt;\n  stri_extract_all_regex(\"[0-9]*\", simplify = TRUE) |&gt;\n  as.numeric() |&gt;\n  sum(na.rm = TRUE)\n\n[1] 361724",
    "crumbs": [
      "2016",
      "<span class='chapter-number'>67</span>  <span class='chapter-title'>2016-04: Security Through Obscurity</span>"
    ]
  },
  {
    "objectID": "2016/04/2016-04.html#part-2",
    "href": "2016/04/2016-04.html#part-2",
    "title": "2016-04: Security Through Obscurity",
    "section": "Part 2",
    "text": "Part 2\n\nx &lt;- lapply(dt[tmp], function(x) {\n  x &lt;- unlist(stri_match_all(x , regex = \"(.*)-([0-9]*)\"))\n  y &lt;- as.numeric(x[3])\n  x &lt;- unlist(strsplit(x[2], \"-\"))\n  x &lt;- cipheR::caesar(x[-length(x)], n = y, preset = \"lowercase\")\n  return(paste(x, collapse = \" \"))\n}) |&gt;\n  unlist()\n\nas.numeric(stri_extract(dt[tmp][which(x == \"northpole object\")], \n                        regex = \"([0-9]{3})\"))\n\n[1] 482",
    "crumbs": [
      "2016",
      "<span class='chapter-number'>67</span>  <span class='chapter-title'>2016-04: Security Through Obscurity</span>"
    ]
  },
  {
    "objectID": "2016/05/2016-05.html",
    "href": "2016/05/2016-05.html",
    "title": "05: How About a Nice Game of Chess?",
    "section": "",
    "text": "Part 1\nI initially did everything in pure R, but it was kinda slow and the solution seemed easy enough to dip my toes into Rcpp. All things considered, it went pretty smoothly. Some of the trickier bits were getting the StringVector&lt;&gt;std::string relationship straight, and not crashing everything when trying to sub-string a StringVector with string_vector[x][y] which is why I ended up just using std::string.\nAfter re-writing, I was able to speed up Part 1 by ~37 seconds and Part 2 by ~ 10 minutes…\nThis isn’t as bad as it looks. Only annoying thing was serialize = FALSE but StackOverflow cleared that up pretty quick.",
    "crumbs": [
      "2016",
      "<span class='chapter-number'>68</span>  <span class='chapter-title'>05: How About a Nice Game of Chess?</span>"
    ]
  },
  {
    "objectID": "2016/05/2016-05.html#part-1",
    "href": "2016/05/2016-05.html#part-1",
    "title": "05: How About a Nice Game of Chess?",
    "section": "",
    "text": "Rcpp\nR\n\n\n\n\ncppFunction('\n  StringVector part1(StringVector dt) {\n    std::string string_x, dig, string_dt = as&lt;std::string&gt;(dt);\n    StringVector password(8);\n    int x = 0, j = 0, p_size = password.size();\n    Function md5(\"digest\");\n    Function paste0(\"paste0\");\n  \n    while (j &lt; p_size) {\n      string_x = std::to_string(x);\n      dig = string_dt + string_x;\n      dig = as&lt;std::string&gt;(md5(dig, _[\"algo\"]=\"md5\", _[\"serialize\"]=0));\n      if (dig.substr(0, 5) == \"00000\") {\n        password[j] = dig.substr(5, 1);\n        j++;\n      }\n      //if (x % 100000 == 0) { std::cout &lt;&lt; \"\\\\r\" &lt;&lt; string_x &lt;&lt; password; }\n      x++;\n    }\n    std::cout &lt;&lt; std::endl;\n    return paste0(password, _[\"collapse\"]=\"\");\n  }\n')\npart1(dt)\n\n[1] \"f97c354d\"\n\n\n\n\n\nx &lt;- 0\npassword &lt;- c()\nwhile(length(password) != 8) {\n  dig &lt;- \n    paste0(dt, x) |&gt;\n    digest::digest(algo = \"md5\", serialize = FALSE)\n  if (substr(dig, 1, 5) == \"00000\") password &lt;- c(password, substr(dig, 6, 6))\n  x &lt;- x + 1\n}\npaste0(password, collapse = \"\")",
    "crumbs": [
      "2016",
      "<span class='chapter-number'>68</span>  <span class='chapter-title'>05: How About a Nice Game of Chess?</span>"
    ]
  },
  {
    "objectID": "2016/05/2016-05.html#part-2",
    "href": "2016/05/2016-05.html#part-2",
    "title": "05: How About a Nice Game of Chess?",
    "section": "Part 2",
    "text": "Part 2\nThat’s not so bad. Just a few small changes and a lot slower…\n\n\nRcpp\nR\n\n\n\n\ncppFunction('\n  StringVector part2(StringVector dt) {\n    std::string string_x, dig, string_dt = as&lt;std::string&gt;(dt);\n    StringVector password(8);\n    int x = 0, j = 0, p_size = password.size(), int_six;\n    Function md5(\"digest\");\n    Function paste0(\"paste0\");\n  \n    while (j &lt; p_size) {\n      string_x = std::to_string(x);\n      dig = string_dt + string_x;\n      dig = as&lt;std::string&gt;(md5(dig, _[\"algo\"]=\"md5\", _[\"serialize\"]=0));\n      if (dig.substr(0, 5) == \"00000\") {\n        try { \n          int_six = stoi(dig.substr(5, 1)); \n        } catch(...) {\n          int_six = -1;\n        }\n        if (int_six &gt; -1 && int_six &lt; p_size && password[int_six] == \"\") {\n          password[int_six] = dig.substr(6, 1);\n          j++;\n        }\n      }\n      //if (x % 100000 == 0) { std::cout &lt;&lt; \"\\\\r\" &lt;&lt; string_x &lt;&lt; password; }\n      x++;\n    }\n    std::cout &lt;&lt; std::endl;\n    return paste0(password, _[\"collapse\"]=\"\");\n  }\n')\nold &lt;- Sys.time()\npart2(dt)\n\n[1] \"863dde27\"\n\nSys.time() - old\n\nTime difference of 5.57279 mins\n\n\n\n\n\nold &lt;- Sys.time()\nx &lt;- 0\npassword &lt;- rep(\"\", 8)\nwhile(any(password == \"\")) {\n  dig &lt;- \n    paste0(dt, x) |&gt;\n    digest::digest(algo = \"md5\", serialize = FALSE)\n  z &lt;- \n    dig |&gt;\n    substr(6, 6) |&gt;\n    as.numeric() |&gt;\n    suppressWarnings()\n  if (\n    substr(dig, 1, 5) == \"00000\" & !is.na(z) & \n    !is.na(password[z + 1]) & password[z + 1] == \"\") {\n    password[z + 1] &lt;- substr(dig, 7, 7)\n  }\n  x &lt;- x + 1\n}\npaste0(password, collapse = \"\")\nSys.time() - old",
    "crumbs": [
      "2016",
      "<span class='chapter-number'>68</span>  <span class='chapter-title'>05: How About a Nice Game of Chess?</span>"
    ]
  },
  {
    "objectID": "2016/06/2016-06.html",
    "href": "2016/06/2016-06.html",
    "title": "06: Signals and Noise",
    "section": "",
    "text": "Part 1\nomg. This is gonna be so easy.\nEdit: it was!\ndt |&gt;\n  map_chr(\\(x) {\n    x |&gt;\n      table() |&gt;\n      sort(decreasing = TRUE) |&gt;\n      head(1) |&gt;\n      names()\n  }) |&gt;\n  paste0(collapse = \"\")\n\n[1] \"bjosfbce\"",
    "crumbs": [
      "2016",
      "<span class='chapter-number'>69</span>  <span class='chapter-title'>06: Signals and Noise</span>"
    ]
  },
  {
    "objectID": "2016/06/2016-06.html#part-2",
    "href": "2016/06/2016-06.html#part-2",
    "title": "06: Signals and Noise",
    "section": "Part 2",
    "text": "Part 2\nClassic. Just drop decreasing = TRUE.\n\ndt |&gt;\n  map_chr(\\(x) {\n    x |&gt;\n      table() |&gt;\n      sort() |&gt;\n      head(1) |&gt;\n      names()\n  }) |&gt;\n  paste0(collapse = \"\")\n\n[1] \"veqfxzfx\"",
    "crumbs": [
      "2016",
      "<span class='chapter-number'>69</span>  <span class='chapter-title'>06: Signals and Noise</span>"
    ]
  },
  {
    "objectID": "2016/07/2016-07.html",
    "href": "2016/07/2016-07.html",
    "title": "07: Internet Protocol Version 7",
    "section": "",
    "text": "Part 1\nUgh. A stupid mistake with my variable scoping and a lot of headaches…\nfind_char &lt;- function(x, char) {\n  x |&gt;\n    str_locate_all(char) |&gt;\n    unlist() |&gt;\n    unique()\n}\n\nfind_abba &lt;- function(s) {\n  any(\n    s != lead(s, 1) & s == lead(s, 3) & lead(s, 1) == lead(s, 2), \n    na.rm = TRUE\n  )\n}\n\ndt |&gt;\n  map_lgl(\\(x) {\n    s &lt;- find_char(x, \"\\\\[\")\n    e &lt;- find_char(x, \"\\\\]\")\n    brackets &lt;-\n      map2_lgl(s, e, \\(s, e) {\n        x |&gt;\n          substr(s, e) |&gt;\n          str_split_1(\"\") |&gt;\n          find_abba()\n      }) |&gt;\n      any()\n    if (!brackets) {\n      pat &lt;-\n        map2_chr(s, e, ~ str_sub(x, .x, .y)) |&gt;\n        str_escape() |&gt;\n        paste0(collapse = \"|\")\n      x &lt;-\n        x |&gt;\n        str_replace_all(pat, \" \") |&gt;\n        str_split_1(\" \") |&gt;\n        map_lgl(~ find_abba(str_split_1(.x, \"\"))) |&gt;\n        any()\n      return(x)\n    } else {\n      return(FALSE)\n    }\n  }) |&gt;\n  sum()\n\n[1] 110",
    "crumbs": [
      "2016",
      "<span class='chapter-number'>70</span>  <span class='chapter-title'>07: Internet Protocol Version 7</span>"
    ]
  },
  {
    "objectID": "2016/07/2016-07.html#part-2",
    "href": "2016/07/2016-07.html#part-2",
    "title": "07: Internet Protocol Version 7",
    "section": "Part 2",
    "text": "Part 2\nJust not my day today, I guess. Spent a bit of time struggling with vector comparison issues that I couldn’t find.\n\nfind_bab &lt;- function(s) {\n  w &lt;- which(s != lead(s, 1) & s == lead(s, 2))\n  if (length(w) &gt; 0) map(w, ~ paste0(s[.x+1], s[.x], s[.x+1])) else NULL\n}\n\ndt |&gt;\n  map_lgl(\\(x) {\n    s &lt;- find_char(x, \"\\\\[\")\n    e &lt;- find_char(x, \"\\\\]\")\n    brackets &lt;-\n      map2(s, e, \\(s, e) {\n        x |&gt;\n          substr(s, e) |&gt;\n          str_split_1(\"\") |&gt;\n          find_bab()\n      }) |&gt;\n      discard(is.null) |&gt;\n      unlist() |&gt;\n      unique()\n    if (length(brackets) &gt; 0) {\n      x &lt;-\n        brackets |&gt;\n        map_lgl(\\(aba) {\n          pat &lt;-\n            map2_chr(s, e, ~ str_sub(x, .x, .y)) |&gt;\n            str_escape() |&gt;\n            paste0(collapse = \"|\")\n          x |&gt;\n            str_replace_all(pat, \" \") |&gt;\n            str_detect(aba)\n        }) |&gt;\n        any()\n      return(x)\n    } else {\n      return(FALSE)\n    }\n  }) |&gt;\n  sum()\n\n[1] 242",
    "crumbs": [
      "2016",
      "<span class='chapter-number'>70</span>  <span class='chapter-title'>07: Internet Protocol Version 7</span>"
    ]
  },
  {
    "objectID": "2016/08/2016-08.html",
    "href": "2016/08/2016-08.html",
    "title": "08: Two-Factor Authentication",
    "section": "",
    "text": "Part 1\nA short ride on the struggle bus, but I actually really liked this one! And I found a better way to make cyclical vectors which is nice. I’ll probably add it to mistlecode…\nm &lt;- matrix(\" \", nrow = 6, ncol = 50)\n\ncycle &lt;- function(x, n) {\n  n &lt;- n %% length(x)\n  if (n == 0) x else c(tail(x, n), head(x, -n))\n}\n\nparse_input &lt;- function(x) {\n  y &lt;-\n    str_match(x, \"(\\\\d+)(x| by )(\\\\d+)\")[1, c(2, 4)] |&gt;\n    as.numeric()\n  a &lt;- y[1]; b &lt;- y[2];\n  if (str_detect(x, \"rect\")) {\n    x &lt;- \\(m) { m[1:b, 1:a] &lt;- \"#\"; m; }\n  } else {\n    a &lt;- a + 1\n    if (str_detect(x, \"rotate row\")) {\n      x &lt;- \\(m) { m[a,] &lt;- cycle(m[a,], b); m; }\n    } else if (str_detect(x, \"rotate col\")) {\n      x &lt;- \\(m) { m[,a] &lt;- cycle(m[,a], b); m; }\n    }\n  }\n  return(x)\n}\n\nf_dt &lt;- map(dt, parse_input)\ni &lt;- seq_along(f_dt)\nwhile (length(i) &gt; 0) {\n  m &lt;- f_dt[[i[1]]](m)\n  i &lt;- i[-1]\n}\nsum(m == \"#\")\n\n[1] 121",
    "crumbs": [
      "2016",
      "<span class='chapter-number'>71</span>  <span class='chapter-title'>08: Two-Factor Authentication</span>"
    ]
  },
  {
    "objectID": "2016/08/2016-08.html#part-2",
    "href": "2016/08/2016-08.html#part-2",
    "title": "08: Two-Factor Authentication",
    "section": "Part 2",
    "text": "Part 2\nPlotting for Advent is always fun! Just need to mess with the scaling a bit.\n\nmatrix_to_coords(m) |&gt;\n  data.frame() |&gt;\n  filter(data == \"#\") |&gt;\n  mutate(across(row:col, as.numeric)) |&gt;\n  ggplot() +\n  geom_tile(aes(x = col, y = -row)) +\n  theme_void() +\n  ylim(-18, 0)",
    "crumbs": [
      "2016",
      "<span class='chapter-number'>71</span>  <span class='chapter-title'>08: Two-Factor Authentication</span>"
    ]
  },
  {
    "objectID": "2016/12/2016-12.html",
    "href": "2016/12/2016-12.html",
    "title": "12: Leonardo’s Monorail",
    "section": "",
    "text": "Part 1\nOkay. I finally had the motivation I needed to write an AoC BASIC interpreter/runner. It’s super slow, but it works and I don’t really have to do anything besides define the registers and the functions. If you want to learn more, take a look here.\nregisters &lt;- list(\"a\" = 0L, \"b\" = 0L, \"c\" = 0L, \"d\" = 0L)\nfunctions &lt;- list(\n  \"cpy\" = \\(x, y) {\n    self[[y]] &lt;- self$val_or_index(x)\n    private$.inc()\n  },\n  \"inc\" = \\(x, y) {\n    self[[x]] &lt;- self[[x]] + 1\n    private$.inc()\n  },\n  \"dec\" = \\(x, y) {\n    self[[x]] &lt;- self[[x]] - 1\n    private$.inc()\n  },\n  \"jnz\" = \\(x, y) {\n    x &lt;- self$val_or_index(x)\n    if (x != 0) private$.inc(y) else private$.inc()\n  }\n)\ncreate_assembly(registers, functions)$run(dt, target = \"a\")\n\n[1] 318009",
    "crumbs": [
      "2016",
      "<span class='chapter-number'>72</span>  <span class='chapter-title'>12: Leonardo's Monorail</span>"
    ]
  },
  {
    "objectID": "2016/12/2016-12.html#part-2",
    "href": "2016/12/2016-12.html#part-2",
    "title": "12: Leonardo’s Monorail",
    "section": "Part 2",
    "text": "Part 2\nJust a quick change, but oh so slow…\n\nregisters &lt;- list(\"a\" = 0L, \"b\" = 0L, \"c\" = 1L, \"d\" = 0L)\ncreate_assembly(registers, functions)$run(dt, target = \"a\")\n\n[1] 9227663",
    "crumbs": [
      "2016",
      "<span class='chapter-number'>72</span>  <span class='chapter-title'>12: Leonardo's Monorail</span>"
    ]
  },
  {
    "objectID": "2015/01/2015-01.html",
    "href": "2015/01/2015-01.html",
    "title": "01: Not Quite Lisp",
    "section": "",
    "text": "Part 1\nstr_count(dt, \"\\\\(\") - str_count(dt, \"\\\\)\")\n\n[1] 138",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>73</span>  <span class='chapter-title'>01: Not Quite Lisp</span>"
    ]
  },
  {
    "objectID": "2015/01/2015-01.html#part-2",
    "href": "2015/01/2015-01.html#part-2",
    "title": "01: Not Quite Lisp",
    "section": "Part 2",
    "text": "Part 2\n\ndt &lt;- data.frame(\"paren\" = t(str_split_fixed(dt, \"\", nchar(dt))))\ndt$val &lt;- ifelse(dt$paren == \"(\", 1, -1)\nwhich(cumsum(dt$val) == -1)[1]\n\n[1] 1771",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>73</span>  <span class='chapter-title'>01: Not Quite Lisp</span>"
    ]
  },
  {
    "objectID": "2015/02/2015-02.html",
    "href": "2015/02/2015-02.html",
    "title": "02: I Was Told There Would Be No Math",
    "section": "",
    "text": "Part 1\n# part 1\ntmp &lt;- dt %&gt;%\n  .[, c(\"l\", \"w\", \"h\") := .(V1 * V2, V2 * V3, V1 * V3)] %&gt;%\n  .[, min := ifelse(l &lt;= w & l &lt;= h, l, \n                    ifelse(w &lt;= l & w &lt;= h, w, h))] %&gt;%\n  .[, sq := 2*l + 2*w + 2*h + min]\nsum(tmp$sq, na.rm = TRUE)\n\n[1] 1598415",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>74</span>  <span class='chapter-title'>02: I Was Told There Would Be No Math</span>"
    ]
  },
  {
    "objectID": "2015/02/2015-02.html#part-2",
    "href": "2015/02/2015-02.html#part-2",
    "title": "02: I Was Told There Would Be No Math",
    "section": "Part 2",
    "text": "Part 2\n\ntmp &lt;- dt %&gt;%\n  .[, c(\"l\", \"w\", \"h\") := .(V1 * V2, V2 * V3, V1 * V3)]\ntmp &lt;- tmp[, c(\"l\", \"w\", \"h\") := .(V1, V2, V3)] %&gt;%\n  .[, max := apply(dt[, .(l, w, h)], 1, max)] %&gt;%\n  rowwise() %&gt;%\n  mutate(test = list(c(l, w, h)))\ntmp$min1 &lt;- t(data.frame(sapply(tmp$test, sort)))[,1]\ntmp$min2 &lt;- t(data.frame(sapply(tmp$test, sort)))[,2]\n\ntmp &lt;- data.table::data.table(tmp)[,rib := ((2*min1 + 2*min2) + (V1 * V2 * V3))]\nsum(tmp$rib, na.rm = TRUE)\n\n[1] 3812909",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>74</span>  <span class='chapter-title'>02: I Was Told There Would Be No Math</span>"
    ]
  },
  {
    "objectID": "2015/03/2015-03.html",
    "href": "2015/03/2015-03.html",
    "title": "03: Perfectly Spherical Houses in a Vacuum",
    "section": "",
    "text": "Part 1\ndirX &lt;- function(x) {\n  case_when(\n    x == \"^\" ~ 0,\n    x == \"&gt;\" ~ 1,\n    x == \"&lt;\" ~ -1,\n    x == \"v\" ~ 0\n  )\n}\ndirY &lt;- function(x) {\n  case_when(\n    x == \"^\" ~ 1,\n    x == \"&gt;\" ~ 0,\n    x == \"&lt;\" ~ 0,\n    x == \"v\" ~ -1\n  )\n}\n\ndf &lt;- data.frame(\"x\" = 0, \"y\" = 0)\nfor(i in 1:nchar(dt))\n  df &lt;- rbind(df, data.frame(\"x\" = dirX(substr(dt, i, i)),\n                             \"y\" = dirY(substr(dt, i, i))))\ndf &lt;- data.table::data.table(df)\ndf$cumX &lt;- cumsum(df$x)\ndf$cumY &lt;- cumsum(df$y)\ndf &lt;- df[, .(cumX, cumY)]\nnrow(unique(df))\n\n[1] 2565",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>75</span>  <span class='chapter-title'>03: Perfectly Spherical Houses in a Vacuum</span>"
    ]
  },
  {
    "objectID": "2015/03/2015-03.html#part-2",
    "href": "2015/03/2015-03.html#part-2",
    "title": "03: Perfectly Spherical Houses in a Vacuum",
    "section": "Part 2",
    "text": "Part 2\n\ndfR &lt;- data.frame(\"x\" = 0, \"y\" = 0)\ndfS &lt;- data.frame(\"x\" = 0, \"y\" = 0)\nfor(i in seq(1, nchar(dt), 2))\n  dfS &lt;- rbind(dfS, data.frame(\"x\" = dirX(substr(dt, i, i)),\n                               \"y\" = dirY(substr(dt, i, i))))\nfor(i in seq(2, nchar(dt), 2))\n  dfR &lt;- rbind(dfR, data.frame(\"x\" = dirX(substr(dt, i, i)),\n                               \"y\" = dirY(substr(dt, i, i))))\n\ndts &lt;- data.table::data.table(dfS)\ndts$cumX &lt;- cumsum(dts$x)\ndts$cumY &lt;- cumsum(dts$y)\ndtr &lt;- data.table::data.table(dfR)\ndtr$cumX &lt;- cumsum(dtr$x)\ndtr$cumY &lt;- cumsum(dtr$y)\n\ndf &lt;- data.table::data.table(rbind(dts, dtr))\n\ndf &lt;- df[, .(cumX, cumY)]\nnrow(unique(df))\n\n[1] 2639",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>75</span>  <span class='chapter-title'>03: Perfectly Spherical Houses in a Vacuum</span>"
    ]
  },
  {
    "objectID": "2015/04/2015-04.html",
    "href": "2015/04/2015-04.html",
    "title": "04: The Ideal Stocking Stuffer",
    "section": "",
    "text": "Part 1\ni &lt;- 0\nwhile(substr(digest(paste0(dt, i), algo = \"md5\", serialize = FALSE), 1, 5) != \"00000\")\n  i &lt;- i + 1\ndigest(paste0(dt, i), algo = \"md5\", serialize = FALSE)\n\n[1] \"000004b30d481662b9cb0c105f6549b2\"\n\ni\n\n[1] 254575",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>76</span>  <span class='chapter-title'>04: The Ideal Stocking Stuffer</span>"
    ]
  },
  {
    "objectID": "2015/04/2015-04.html#part-2",
    "href": "2015/04/2015-04.html#part-2",
    "title": "04: The Ideal Stocking Stuffer",
    "section": "Part 2",
    "text": "Part 2\n\ni &lt;- 0\nwhile(substr(digest(paste0(dt, i), algo = \"md5\", serialize = FALSE), 1, 6) != \"000000\")\n  i &lt;- i + 1\ndigest(paste0(dt, i), algo = \"md5\", serialize = FALSE)\n\n[1] \"000000b1b64bf5eb55aad89986126953\"\n\ni\n\n[1] 1038736",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>76</span>  <span class='chapter-title'>04: The Ideal Stocking Stuffer</span>"
    ]
  },
  {
    "objectID": "2015/05/2015-05.html",
    "href": "2015/05/2015-05.html",
    "title": "05: Doesn’t He Have Intern-Elves For This?",
    "section": "",
    "text": "Part 1\ndt &lt;- df\ndt &lt;- dt[!grepl(\"(ab)|(cd)|(pq)|(xy)\", dt)]\ndt &lt;- dt[grepl(\"(\\\\w*[aeuio]\\\\w*){3,}\", dt)]\ndt &lt;- dt[grepl(\"(.)\\\\1+\", dt)]\nlength(dt)\n\n[1] 255",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>77</span>  <span class='chapter-title'>05: Doesn't He Have Intern-Elves For This?</span>"
    ]
  },
  {
    "objectID": "2015/05/2015-05.html#part-2",
    "href": "2015/05/2015-05.html#part-2",
    "title": "05: Doesn’t He Have Intern-Elves For This?",
    "section": "Part 2",
    "text": "Part 2\n\ndt &lt;- df\ndt &lt;- dt[grepl(\"(..).*(\\\\1)\", dt, perl = TRUE)]\ndt &lt;- dt[grepl(\"(.)(.)(\\\\1)\", dt, perl = TRUE)]\nlength(dt)\n\n[1] 55",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>77</span>  <span class='chapter-title'>05: Doesn't He Have Intern-Elves For This?</span>"
    ]
  },
  {
    "objectID": "2015/06/2015-06.html",
    "href": "2015/06/2015-06.html",
    "title": "06: Probably a Fire Hazard",
    "section": "",
    "text": "Part 1\ndt &lt;- data.frame(\"dir\" = str_extract(dt, \"off|on|toggle\"),\n                 \"from\" = str_extract(dt, \"[0-9]{1,3},[0-9]{1,3}\"),\n                 \"to\" = str_extract(dt, \"[0-9]{1,3},[0-9]{1,3}$\"))\nfrom &lt;- str_split(dt$from, \",\", simplify = TRUE)\ndt$fromX &lt;- as.numeric(from[,1]) + 1\ndt$fromY &lt;- as.numeric(from[,2]) + 1\n\nto &lt;- str_split(dt$to, \",\", simplify = TRUE)\ndt$toX &lt;- as.numeric(to[,1]) + 1\ndt$toY &lt;- as.numeric(to[,2]) + 1\n\nlights &lt;- data.frame(\"x\" = rep(1:1000, 1000), \n                     \"y\" = rep(1:1000, each = 1000),\n                     \"stat\" = as.integer(0))\n\nfor(i in 1:nrow(dt)) {\n  if(dt$dir[i] == \"on\") {\n    lights$stat[dt$fromX[i] &lt;= lights$x & \n                  dt$toX[i] &gt;= lights$x & \n                  dt$fromY[i] &lt;= lights$y & \n                  dt$toY[i] &gt;= lights$y] &lt;- 1\n  }\n  if(dt$dir[i] == \"off\") {\n    lights$stat[dt$fromX[i] &lt;= lights$x & \n                  dt$toX[i] &gt;= lights$x & \n                  dt$fromY[i] &lt;= lights$y & \n                  dt$toY[i] &gt;= lights$y] &lt;- 0\n  }\n  if(dt$dir[i] == \"toggle\") {\n    lights$stat[dt$fromX[i] &lt;= lights$x & dt$toX[i] &gt;= lights$x & \n                  dt$fromY[i] &lt;= lights$y & dt$toY[i] &gt;= lights$y] &lt;- \n      ifelse(lights$stat[dt$fromX[i] &lt;= lights$x & dt$toX[i] &gt;= lights$x & \n                  dt$fromY[i] &lt;= lights$y & dt$toY[i] &gt;= lights$y] == 1, 0, 1)\n  }\n}\n\nnrow(lights[lights$stat == 1,])\n\n[1] 400410",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>78</span>  <span class='chapter-title'>06: Probably a Fire Hazard</span>"
    ]
  },
  {
    "objectID": "2015/06/2015-06.html#part-2",
    "href": "2015/06/2015-06.html#part-2",
    "title": "06: Probably a Fire Hazard",
    "section": "Part 2",
    "text": "Part 2\n\n# part 2\nlights &lt;- data.frame(\"x\" = rep(1:1000, 1000), \n                     \"y\" = rep(1:1000, each = 1000),\n                     \"stat\" = as.integer(0))\n\nfor(i in 1:nrow(dt)) {\n  if(dt$dir[i] == \"on\") {\n    lights$stat[dt$fromX[i] &lt;= lights$x & \n                  dt$toX[i] &gt;= lights$x & \n                  dt$fromY[i] &lt;= lights$y & \n                  dt$toY[i] &gt;= lights$y] &lt;- lights$stat[dt$fromX[i] &lt;= lights$x & \n                  dt$toX[i] &gt;= lights$x & \n                  dt$fromY[i] &lt;= lights$y & \n                  dt$toY[i] &gt;= lights$y] + 1\n  }\n  if(dt$dir[i] == \"off\") {\n    lights$stat[dt$fromX[i] &lt;= lights$x & dt$toX[i] &gt;= lights$x & \n                  dt$fromY[i] &lt;= lights$y & dt$toY[i] &gt;= lights$y] &lt;- \n      ifelse(lights$stat[dt$fromX[i] &lt;= lights$x & dt$toX[i] &gt;= lights$x & \n                  dt$fromY[i] &lt;= lights$y & dt$toY[i] &gt;= lights$y] == 0, \n             lights$stat[dt$fromX[i] &lt;= lights$x & dt$toX[i] &gt;= lights$x & \n                  dt$fromY[i] &lt;= lights$y & dt$toY[i] &gt;= lights$y], \n             lights$stat[dt$fromX[i] &lt;= lights$x & dt$toX[i] &gt;= lights$x & \n                  dt$fromY[i] &lt;= lights$y & dt$toY[i] &gt;= lights$y] - 1)\n  }\n  if(dt$dir[i] == \"toggle\") {\n    lights$stat[dt$fromX[i] &lt;= lights$x & \n                  dt$toX[i] &gt;= lights$x & \n                  dt$fromY[i] &lt;= lights$y & \n                  dt$toY[i] &gt;= lights$y] &lt;- lights$stat[dt$fromX[i] &lt;= lights$x & \n                  dt$toX[i] &gt;= lights$x & \n                  dt$fromY[i] &lt;= lights$y & \n                  dt$toY[i] &gt;= lights$y] + 2\n  }\n}\n\nsum(lights$stat)\n\n[1] 15343601",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>78</span>  <span class='chapter-title'>06: Probably a Fire Hazard</span>"
    ]
  },
  {
    "objectID": "2015/07/2015-07.html",
    "href": "2015/07/2015-07.html",
    "title": "07: Some Assembly Required",
    "section": "",
    "text": "Part 1\nI’ve looked at this one before and it’s a bit messy. I had a few false starts, especially in regards to parsing the input, but eventually settled on using function factories to build the bitwise function calls and some gross regex to get the rest of it in line for that to happen.\nThis was originally the solution to part 1, but since it’s reusable for part 2, I put it into a function.\nI initially tried just writing to a file then sourcing it, but quickly discovered that my statements were out of order. I figured a loop would be fast enough, then I can use a tryCatch to skip over any errors, paring down the statements until they all run. I had a bit of trouble with my eval statement until I remembered I have to parse the dang thing first.\n(a &lt;- run(dt))\n\n[1] 3176",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>79</span>  <span class='chapter-title'>07: Some Assembly Required</span>"
    ]
  },
  {
    "objectID": "2015/07/2015-07.html#part-2",
    "href": "2015/07/2015-07.html#part-2",
    "title": "07: Some Assembly Required",
    "section": "Part 2",
    "text": "Part 2\nThis bit was easy. Just had to copy to a new object for some reason then it was a simple replacement with the value from part 1.\n\ndt2 &lt;- dt\ndt2[str_detect(dt2, \"-&gt; b$\")] &lt;- glue::glue(\"{a} -&gt; b\")\nrun(dt2)\n\n[1] 14710",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>79</span>  <span class='chapter-title'>07: Some Assembly Required</span>"
    ]
  },
  {
    "objectID": "2015/08/2015-08.html",
    "href": "2015/08/2015-08.html",
    "title": "08: Matchsticks",
    "section": "",
    "text": "Part 1\nThis doesn’t look too bad. Dealing with R’s \\\\ nonsense is going to be a pain.\nGetting the regex right was the worst part, just like I thought. \\\\ is the worst part about R.\nliteral_length &lt;- \n  dt |&gt;\n  nchar() |&gt;\n  sum()\n\nmemory_length &lt;-\n  dt |&gt;\n  str_sub(start = 2) |&gt;\n  str_sub(end = -2) |&gt;\n  str_replace_all('\\\\\\\\x[0-9a-f]{2}', ' ') |&gt;\n  str_replace_all('\\\\\\\\\\\\\"', ' ') |&gt;\n  str_replace_all('\\\\\\\\\\\\\\\\', ' ') |&gt;\n  nchar() |&gt;\n  sum()\n\nliteral_length - memory_length\n\n[1] 1371",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>80</span>  <span class='chapter-title'>08: Matchsticks</span>"
    ]
  },
  {
    "objectID": "2015/08/2015-08.html#part-2",
    "href": "2015/08/2015-08.html#part-2",
    "title": "08: Matchsticks",
    "section": "Part 2",
    "text": "Part 2\nTurns out R also auto-converts double spaces to tabs so to get two characters, you need three spaces…\n\ntotal_length &lt;-\n  dt |&gt;\n  str_escape() |&gt;\n  str_replace_all('^\"|\"$', '   ') |&gt;\n  str_replace_all('\\\\\\\\x[0-9a-f]{2}', '    ') |&gt;\n  str_replace_all('\\\\\\\\\\\\\"', '   ') |&gt;\n  str_replace_all('\\\\\\\\', ' ') |&gt;\n  nchar() |&gt;\n  sum()\ntotal_length - literal_length\n\n[1] 2117",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>80</span>  <span class='chapter-title'>08: Matchsticks</span>"
    ]
  },
  {
    "objectID": "2015/09/2015-09.html",
    "href": "2015/09/2015-09.html",
    "title": "09: All in a Single Night",
    "section": "",
    "text": "Part 1\nOh no! It’s the traveling salesman!\nI figured with R the way it is, there had to be a package that can solve it. Sure enough, TSP exists. Creating the symmetric matrix was a bit of a pain, but then I was getting solutions for the test input but not the real input. Ugh. I slept on the problem then tried replacing the diagonal with NA, rather than zeroes. That seemed to do the trick.\nm &lt;-\n  expand.grid(stops, stops) |&gt;\n  data.table() |&gt;\n  `colnames&lt;-`(c(\"start\", \"end\")) |&gt;\n  left_join(dt, by = c(\"start\", \"end\")) |&gt;\n  mutate(dist = ifelse(start == end, NA_integer_, dist)) |&gt;\n  dcast(start ~ end, value.var = \"dist\") |&gt;\n  data.frame() |&gt;\n  `rownames&lt;-`(stops) |&gt;\n  select(-start) |&gt;\n  as.matrix()\n\nm &lt;-\n  map2_dbl(m, t(m), \\(x, y) {\n    if(is.na(x) & !is.na(y)) return(y) else return(x)\n  }) |&gt;\n  matrix(length(stops), length(stops)) |&gt;\n  `colnames&lt;-`(stops) |&gt;\n  `rownames&lt;-`(stops) |&gt;\n  as.matrix() \n\nstops &lt;- get_stops(m)\n\nWarning: executing %dopar% sequentially: no parallel backend registered\n\nget_dist(m, stops)\n\n[1] 251",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>81</span>  <span class='chapter-title'>09: All in a Single Night</span>"
    ]
  },
  {
    "objectID": "2015/09/2015-09.html#part-2",
    "href": "2015/09/2015-09.html#part-2",
    "title": "09: All in a Single Night",
    "section": "Part 2",
    "text": "Part 2\nOh boy. I think I have an easy solution for this! If I can re-scale the values so that the smallest numbers are biggest and the biggest numbers are smallest, I can just re-run to get the cities in order, then use the original distances. A quick apply with \\(\\frac{1}{x}\\) and I’m on my way. Just need to throw everything into functions and there we go!\n\nstops &lt;-\n  m |&gt;\n  apply(c(1, 2), \\(x) 1 / x) |&gt;\n  get_stops()\nget_dist(m, stops)\n\n[1] 898",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>81</span>  <span class='chapter-title'>09: All in a Single Night</span>"
    ]
  },
  {
    "objectID": "2015/10/2015-10.html",
    "href": "2015/10/2015-10.html",
    "title": "10: Elves Look, Elves Say",
    "section": "",
    "text": "Part 1\nI got stuck trying to think of the smart way to do this so I’m brute-forcing it with recursion instead.\nexpand &lt;- function(x, max, i = 1) {\n  if (i == (max + 1)) { return(nchar(x)) }\n  x &lt;-\n    x |&gt;\n    strsplit(\"\") |&gt;\n    unlist() |&gt;\n    data.table() |&gt;\n    `colnames&lt;-`(\"input\") |&gt;\n    mutate(group = rleid(input)) |&gt;\n    group_by(group, input) |&gt;\n    summarise(count = n(), .groups = \"drop\") |&gt;\n    mutate(string = glue::glue(\"{count}{input}\")) |&gt;\n    pull(string) |&gt;\n    paste0(collapse = \"\")\n  p()\n  return(expand(x, max, i + 1))\n}\n\ntimes &lt;- 40\nwith_progress({ \n  p &lt;- progressor(steps = times)\n  expand(dt, times) \n})\n\n[1] 252594",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>82</span>  <span class='chapter-title'>10: Elves Look, Elves Say</span>"
    ]
  },
  {
    "objectID": "2015/10/2015-10.html#part-2",
    "href": "2015/10/2015-10.html#part-2",
    "title": "10: Elves Look, Elves Say",
    "section": "Part 2",
    "text": "Part 2\nI thought it was going to be 100 iterations. I can’t believe I’m glad for just 50… But I think I can brute-force this too. I definitely have enough RAM. I just modified the function a bit to take a max iteration input argument as well.\n\ntimes &lt;- 50\nwith_progress({ \n  p &lt;- progressor(steps = times)\n  expand(dt, times) \n})\n\n[1] 3579328",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>82</span>  <span class='chapter-title'>10: Elves Look, Elves Say</span>"
    ]
  },
  {
    "objectID": "2015/11/2015-11.html",
    "href": "2015/11/2015-11.html",
    "title": "11: Corporate Policy",
    "section": "",
    "text": "Part 1\nI struggled for so long with some half-baked quasi-recursive solution that worked on one of the test inputs. I eventually realized that I needed my replacement function to be recursive (I was working with string indexes before) and then it all fell into place. Not my fastest computationally, but it gets the job done.\ncheck_consecutive &lt;- function(x) {\n  x &lt;- paste0(x, collapse = \"\")\n  letters |&gt;\n    runner(k = 3, f = paste0, collapse = \"\") |&gt;\n    tail(-2) |&gt;\n    map_lgl(~ str_detect(x, .x)) |&gt;\n    any()\n}\n\ncheck_confusing &lt;- function(x) { !any(c(\"i\", \"o\", \"l\") %in% x) }\n\ncheck_pairs &lt;- function(x) {\n  x &lt;- \n    data.frame(\n      \"a\" = x,\n      \"b\" = lead(x)\n    ) |&gt;\n    filter(a == b) |&gt;\n    group_by(a, b) |&gt;\n    count() |&gt;\n    nrow()\n  return(x &gt;= 2)\n}\n\ncheck &lt;- function(x) {\n  return(\n    check_consecutive(x) & \n    check_confusing(x) &\n    check_pairs(x)\n  )\n}\n\nno_iol &lt;- letters[!(letters %in% c(\"i\", \"o\", \"l\"))]\n\nreplace &lt;- function(x, pos) {\n  l &lt;- which(no_iol == x[pos]) + 1\n  if (l &gt; length(no_iol)) {\n    x[pos] &lt;- \"a\"\n    x &lt;- replace(x, pos - 1)\n  } else {\n    x[pos] &lt;- no_iol[l]\n  }\n  return(x)\n}\n\nsplit_dt &lt;- str_split(dt, \"\")[[1]]\n\nrepeat {\n  if (check(split_dt)) { break }\n  split_dt &lt;- replace(split_dt, length(split_dt))\n}\npaste0(split_dt, collapse = \"\")\n\n[1] \"hxbxxyzz\"",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>83</span>  <span class='chapter-title'>11: Corporate Policy</span>"
    ]
  },
  {
    "objectID": "2015/11/2015-11.html#part-2",
    "href": "2015/11/2015-11.html#part-2",
    "title": "11: Corporate Policy",
    "section": "Part 2",
    "text": "Part 2\nHmmm. I suppose my solution from part 1 wouldn’t work right away. That would be too easy. I could just say that’s no longer a valid solution then it’ll keep going. Kinda dumb but it should work.\nIt’s me. I’m back. It was taking too long. I think I can speed this up just by thinking about it. If xx changes to xy, that whole branch becomes invalid no matter what comes after because it won’t have a sequence available. Same with yy or zz. So that means that b has to increase to c. Here we have some more options. In fact, we have a whole alphabet’s worth. We want to minimize the value so let’s go with a. Same for the next character. Now we only have three spots left and we need to complete our sequence of three letters and get another double. If we do bbc, we don’t have the sequence so we have to do bcc to complete the sequence and get the last double.\n\n\"hxcaabcc\"\n\n[1] \"hxcaabcc\"",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>83</span>  <span class='chapter-title'>11: Corporate Policy</span>"
    ]
  },
  {
    "objectID": "2015/12/2015-12.html",
    "href": "2015/12/2015-12.html",
    "title": "12: JSAbacusFramework.io",
    "section": "",
    "text": "Part 1\nSurprisingly easy. Just had a small regex typo with ? instead of +.\ndt |&gt;\n  str_extract_all(\"(-?[0-9]+)\") |&gt;\n  unlist() |&gt;\n  as.numeric() |&gt;\n  sum(na.rm = TRUE)\n\n[1] 191164",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>84</span>  <span class='chapter-title'>12: JSAbacusFramework.io</span>"
    ]
  },
  {
    "objectID": "2015/12/2015-12.html#part-2",
    "href": "2015/12/2015-12.html#part-2",
    "title": "12: JSAbacusFramework.io",
    "section": "Part 2",
    "text": "Part 2\nWhat a nightmare! I got the answer wrong 16 times and tried so many things. String replacement, string reduction, listing, unlisting, whatever I could think of. I eventually remembered rrapply and had a wacky solution that didn’t work at all. I took a break for a few days and really read the documentation on how = \"recurse\". Then it was just a matter of realizing that .xname in the documentation is not the same as names(x) and I was good to go!\n\ndt |&gt;\n  parse_json() |&gt;\n  list() |&gt;\n  rrapply::rrapply(\n    \\(o) { any(o == \"red\") & any(names(o) %in% letters) },\n    \\(x) { return(list(\"a\" = \"red\")) }, \n    how = \"recurse\",\n    classes = \"list\") |&gt;\n  unlist() |&gt;\n  as.numeric() |&gt;\n  suppressWarnings() |&gt;\n  sum(na.rm = TRUE)\n\n[1] 87842",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>84</span>  <span class='chapter-title'>12: JSAbacusFramework.io</span>"
    ]
  },
  {
    "objectID": "2015/13/2015-13.html",
    "href": "2015/13/2015-13.html",
    "title": "13: Knights of the Dinner Table",
    "section": "",
    "text": "Part 1\nAs usual, this was moved into a function after part 1 because I reused it in part 2.\nHonestly, not a clue.\nOkay. I’m back. It’s been a few weeks but I had a stroke of inspiration last night. I had started out trying a bunch of longer data and filtering, brute forcing, and anything else I could think of. BUT. Last night I realized this is just a circular traveling salesman problem. After a bit of fiddling with my solution from 2015-09 I was able to get it. Some key things were rescaling from 0-1 so that I don’t have both positive and negative numbers, then using the \\(\\frac{1}{x}\\) trick to get longest distances instead of shortest.\nm &lt;- \n  dt |&gt;\n  dcast(origin ~ subject, value.var = \"units\", fill = 0) |&gt;\n  column_to_rownames(\"origin\") |&gt;\n  as.matrix() |&gt;\n  `diag&lt;-`(NA_integer_)\n\nsolve(m)\n\nWarning: executing %dopar% sequentially: no parallel backend registered\n\n\n[1] 573",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>85</span>  <span class='chapter-title'>13: Knights of the Dinner Table</span>"
    ]
  },
  {
    "objectID": "2015/13/2015-13.html#part-2",
    "href": "2015/13/2015-13.html#part-2",
    "title": "13: Knights of the Dinner Table",
    "section": "Part 2",
    "text": "Part 2\nI always knew my relationships had a happiness score of zero, but I didn’t need to be reminded of it :(.\n\nm &lt;-\n  dt |&gt;\n  bind_rows(expand.grid(\n    \"origin\" = \"Gus\",\n    \"units\" = 0,\n    \"subject\" = c(\"Gus\", unique(dt$origin))\n  )) |&gt;\n  dcast(origin ~ subject, value.var = \"units\", fill = 0) |&gt;\n  column_to_rownames(\"origin\") |&gt;\n  as.matrix() |&gt;\n  `diag&lt;-`(NA_integer_)\n\nsolve(m)\n\n[1] 601",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>85</span>  <span class='chapter-title'>13: Knights of the Dinner Table</span>"
    ]
  },
  {
    "objectID": "2015/14/2015-14.html",
    "href": "2015/14/2015-14.html",
    "title": "14: Reindeer Olympics",
    "section": "",
    "text": "Part 1\nThis bit was added after Part 1 was completed because it’s reused in Part 2.\nThis was super annoying. My first version of my .qmd file was corrupted somehow so I could only run anything once after restarting RStudio. I thought it was because I had just updated to R 4.3 but deleting the old file and pasting everything into a new one seems to have fixed it.\nAnyways, easy enough. Just a little annoying to get the vector recycling to line up how I wanted it to.\ndt |&gt;\n  do_part() |&gt;\n  select(-total_time) |&gt;\n  map_int(sum, na.rm = TRUE) |&gt;\n  max()\n\n[1] 2660",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>86</span>  <span class='chapter-title'>14: Reindeer Olympics</span>"
    ]
  },
  {
    "objectID": "2015/14/2015-14.html#part-2",
    "href": "2015/14/2015-14.html#part-2",
    "title": "14: Reindeer Olympics",
    "section": "Part 2",
    "text": "Part 2\nThis looks simple enough to change Part 1.\nI ended up not changing the parts I thought I would\n\ndt |&gt;\n  do_part() |&gt;\n  pivot_longer(\n    cols = -total_time,\n    names_to = \"reindeer\",\n    values_to = \"distance\"\n  ) |&gt;\n  arrange(reindeer, total_time) |&gt;\n  mutate(total_distance = cumsum(distance), .by = reindeer) |&gt;\n  mutate(\n    points = ifelse(total_distance == max(total_distance), 1, 0), \n    .by = total_time\n  ) |&gt;\n  mutate(total_points = cumsum(points), .by = reindeer) |&gt;\n  filter(total_time == sec) |&gt;\n  pull(total_points) |&gt;\n  max()\n\n[1] 1564",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>86</span>  <span class='chapter-title'>14: Reindeer Olympics</span>"
    ]
  },
  {
    "objectID": "2015/15/2015-15.html",
    "href": "2015/15/2015-15.html",
    "title": "15: Science for Hungry People",
    "section": "",
    "text": "Part 1\nThis is super dumb but I don’t feel like learning how to use one of the linear programming tools. I’ll probably regret it.\ncost &lt;-\n  dt |&gt;\n  nrow() |&gt;\n  seq_len() |&gt;\n  map(\\(x) {\n    dt[x, ] |&gt;\n      mutate(count = 101) |&gt;\n      uncount(count, .id = \"id\") |&gt;\n      mutate(id = id - 1)\n  }) |&gt;\n  bind_rows()\n\ncombos &lt;-\n  expand.grid(list(1:100)[rep(1,nrow(dt))]) |&gt;\n  `colnames&lt;-`(dt$candy) |&gt;\n  filter(rowSums(across(everything())) == 100)\n\nfilter_cookies &lt;- function(...) {\n  p()\n  list2(...) |&gt;\n    imap(\\(.x, idx) {\n      filter(cost, id == .x & candy == idx)\n    }) |&gt;\n    bind_rows() |&gt;\n    mutate(across(capacity:calories, ~ .x * id)) |&gt;\n    select(capacity:texture) |&gt;\n    map_int(sum) |&gt;\n    data.frame() |&gt;\n    `colnames&lt;-`(\"value\") |&gt;\n    mutate(value = ifelse(value &lt; 0, 0, value)) |&gt;\n    pull(value) |&gt;\n    prod()\n}\n\nplan(multisession, workers = availableCores())\nwith_progress({\n  p &lt;- progressor(steps = nrow(combos))\n  combos |&gt;\n    future_pmap_int(filter_cookies) |&gt;\n    max()\n})\n\n[1] 13882464\n\nplan(sequential)",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>87</span>  <span class='chapter-title'>15: Science for Hungry People</span>"
    ]
  },
  {
    "objectID": "2015/15/2015-15.html#part-2",
    "href": "2015/15/2015-15.html#part-2",
    "title": "15: Science for Hungry People",
    "section": "Part 2",
    "text": "Part 2\nRemember how I said I’d probably regret it? It could’ve been worse.\n\ncheck_calories &lt;- function(cal) {\n  if (cal$value[rownames(cal) == \"calories\"] == 500) {\n    return(data.frame(value = cal[rownames(cal) != \"calories\",]))\n  } else {\n    return(data.frame(value = 0))\n  }\n}\n\nfilter_cookies &lt;- function(...) {\n  p()\n  list2(...) |&gt;\n    imap(\\(.x, idx) {\n      filter(cost, id == .x & candy == idx)\n    }) |&gt;\n    bind_rows() |&gt;\n    mutate(across(capacity:calories, ~ .x * id)) |&gt;\n    select(capacity:calories) |&gt;\n    map_int(sum) |&gt;\n    data.frame() |&gt;\n    `colnames&lt;-`(\"value\") |&gt;\n    check_calories() |&gt;\n    mutate(value = ifelse(value &lt; 0, 0, value)) |&gt;\n    pull(value) |&gt;\n    prod()\n}\n\nplan(multisession, workers = availableCores())\nwith_progress({\n  p &lt;- progressor(steps = nrow(combos))\n  combos |&gt;\n    future_pmap_int(filter_cookies) |&gt;\n    max()\n})\n\n[1] 11171160\n\nplan(sequential)",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>87</span>  <span class='chapter-title'>15: Science for Hungry People</span>"
    ]
  },
  {
    "objectID": "2015/16/2015-16.html",
    "href": "2015/16/2015-16.html",
    "title": "16: Aunt Sue",
    "section": "",
    "text": "Part 1\nHmmm. Just need to get the data in longer format then I can group by sue and filter as needed.\nOnly tricky bit was remembering how to pivot longer with multiple columns.\nsue |&gt;\n  filter(qty == ticker_qty) |&gt;\n  filter(n() == 3, .by = sue) |&gt;\n  pull(sue) |&gt;\n  unique()\n\n[1] 373",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>88</span>  <span class='chapter-title'>16: Aunt Sue</span>"
    ]
  },
  {
    "objectID": "2015/16/2015-16.html#part-2",
    "href": "2015/16/2015-16.html#part-2",
    "title": "16: Aunt Sue",
    "section": "Part 2",
    "text": "Part 2\nNot too bad. Just a gross filter and we’re good to go. Oh and don’t forget to put your ! in the right spot :).\n\nsue |&gt;\n  filter(\n    (item %in% c(\"cats\", \"trees\") & qty &gt; ticker_qty) |\n      (item %in% c(\"pomeranians\", \"goldfish\") & qty &lt; ticker_qty) |\n      (\n        (!item %in% c(\"cats\", \"trees\", \"pomeranians\", \"goldfish\") & \n            qty == ticker_qty)\n      )\n  ) |&gt;\n  filter(n() == 3, .by = sue) |&gt;\n  pull(sue) |&gt;\n  unique()\n\n[1] 260",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>88</span>  <span class='chapter-title'>16: Aunt Sue</span>"
    ]
  },
  {
    "objectID": "2015/17/2015-17.html",
    "href": "2015/17/2015-17.html",
    "title": "17: No Such Thing as Too Much",
    "section": "",
    "text": "Part 1\nbuckets was made for part 1, but is used in part 2 as well.\nThis was surprisingly easy. I thought for sure I was going to have to run stuff in parallel.\nsum(buckets, na.rm = TRUE)\n\n[1] 4372",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>89</span>  <span class='chapter-title'>17: No Such Thing as Too Much</span>"
    ]
  },
  {
    "objectID": "2015/17/2015-17.html#part-2",
    "href": "2015/17/2015-17.html#part-2",
    "title": "17: No Such Thing as Too Much",
    "section": "Part 2",
    "text": "Part 2\nAlso weirdly easy. Especially since I set myself up for that with part 1.\n\nbuckets |&gt;\n  na.omit() |&gt;\n  head(1)\n\n[1] 4",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>89</span>  <span class='chapter-title'>17: No Such Thing as Too Much</span>"
    ]
  },
  {
    "objectID": "2015/18/2015-18.html",
    "href": "2015/18/2015-18.html",
    "title": "18: Like a GIF For Your Yard",
    "section": "",
    "text": "Part 1\nI’ve got a plan this time…\nUgh. I need to find a way to make this faster.\nprocess_light &lt;- function(y, x, m) {\n  state &lt;- m[y,x]\n  m[y,x] &lt;- \"\"\n  val &lt;- get_adjacent_values(y, x, m)\n  if (state == \"#\") {\n    if (sum(val == \"#\") %in% 2:3) {\n      return(\"#\")\n    } else {\n      return(\".\")\n    }\n  } else if (state == \".\") {\n    if (sum(val == \"#\") == 3) {\n      return(\"#\")\n    } else {\n      return(\".\")\n    }\n  }\n}\n\ndo_flash &lt;- function(dt, flash, i) {\n  while (i &gt; 0) {\n    p()\n    dt &lt;- \n      expand.grid(\n        \"y\" = seq_len(nrow(dt)),\n        \"x\" = seq_len(ncol(dt))\n      ) |&gt;\n      furrr::future_pmap_chr(\\(y, x) {\n        rlang::exec(quote(flash), y, x, dt)\n      }) |&gt;\n      matrix(nrow = nrow(dt), byrow = FALSE)\n    i &lt;- i - 1\n  }\n  return(dt)\n}\n\nfuture::plan(future::multicore, workers = future::availableCores())\n\nWarning in supportsMulticoreAndRStudio(...): [ONE-TIME WARNING] Forked\nprocessing ('multicore') is not supported when running R from RStudio because\nit is considered unstable. For more details, how to control forked processing\nor not, and how to silence this warning in future R sessions, see\n?parallelly::supportsMulticore\n\nprogressr::with_progress({\n  i &lt;- 100\n  p &lt;- progressr::progressor(steps = i)\n  do_flash(dt, process_light, i) |&gt;\n    map_int( ~ .x == \"#\") |&gt;\n    sum()\n})\n\n[1] 814\n\nfuture::plan(future::sequential)",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>90</span>  <span class='chapter-title'>18: Like a GIF For Your Yard</span>"
    ]
  },
  {
    "objectID": "2015/18/2015-18.html#part-2",
    "href": "2015/18/2015-18.html#part-2",
    "title": "18: Like a GIF For Your Yard",
    "section": "Part 2",
    "text": "Part 2\nAt least it’s not like 1000 iterations. Just some small changes and a long wait and we’re good to go.\n\nprocess_light &lt;- function(y, x, m) {\n  m[1,1] &lt;- m[nrow(m),1] &lt;- m[1,ncol(m)] &lt;- m[nrow(m), ncol(m)] &lt;- \"#\"\n  state &lt;- m[y,x]\n  m[y,x] &lt;- \"\"\n  val &lt;- get_adjacent_values(y, x, m)\n  if (state == \"#\") {\n    if (sum(val == \"#\") %in% 2:3) {\n      return(\"#\")\n    } else {\n      return(\".\")\n    }\n  } else if (state == \".\") {\n    if (sum(val == \"#\") == 3) {\n      return(\"#\")\n    } else {\n      return(\".\")\n    }\n  }\n}\n\ndo_flash &lt;- function(dt, flash, i) {\n  while (i &gt; 0) {\n    p()\n    dt &lt;- \n      expand.grid(\n        \"y\" = seq_len(nrow(dt)),\n        \"x\" = seq_len(ncol(dt))\n      ) |&gt;\n      furrr::future_pmap_chr(\\(y, x) {\n        rlang::exec(quote(flash), y, x, dt)\n      }) |&gt;\n      matrix(nrow = nrow(dt), byrow = FALSE)\n    i &lt;- i - 1\n  }\n  dt[1,1] &lt;- dt[nrow(dt),1] &lt;- dt[1,ncol(dt)] &lt;- dt[nrow(dt), ncol(dt)] &lt;- \"#\"\n  return(dt)\n}\n\nfuture::plan(future::multicore, workers = future::availableCores())\nprogressr::with_progress({\n  i &lt;- 100\n  p &lt;- progressr::progressor(steps = i)\n  do_flash(dt, process_light, i) |&gt;\n    map_int( ~ .x == \"#\") |&gt;\n    sum()\n})\n\n[1] 924\n\nfuture::plan(future::sequential)",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>90</span>  <span class='chapter-title'>18: Like a GIF For Your Yard</span>"
    ]
  },
  {
    "objectID": "2015/20/2015-20.html",
    "href": "2015/20/2015-20.html",
    "title": "20: Infinite Elves and Infinite Houses",
    "section": "",
    "text": "Part 1\nThere’s something I can do with prime factorization, I just can’t figure it out. Ugh. Took me a fat minute but I was able to work with my idea about how if you divide a number x by 1:x then round down, you get the total number of times each elf would have stopped at a house before x. Just had to get that set up right and we’re good to go. Not the fastest, but it works. Maybe another chance for Rcpp if I’m up for it later.\nSpoiler alert. I wasn’t happy with the plain R version and re-wrote it in Rcpp. At this point I’ve been through so many versions, I think my working R solution is lost…\nDouble spoiler… I did it again, but way better this time.",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>91</span>  <span class='chapter-title'>20: Infinite Elves and Infinite Houses</span>"
    ]
  },
  {
    "objectID": "2015/20/2015-20.html#part-1",
    "href": "2015/20/2015-20.html#part-1",
    "title": "20: Infinite Elves and Infinite Houses",
    "section": "",
    "text": "R (Best)\nRcpp\nR\n\n\n\n\ntarget &lt;- 36e6\ni &lt;- 0\nrepeat {\n  i &lt;- i + 1\n  n &lt;- sum(RcppBigIntAlgos::divisorsBig(i))\n  if (n &gt;= target / 10) break\n}\ni\n\n[1] 831600\n\n\n\n\n\ncppFunction('\nIntegerVector part1(int target, int total_l) {\n  IntegerVector m_vec, sum_vec(total_l, 0.0), v;\n  IntegerMatrix m_mat;\n  int idx = 0;\n  while (idx &lt;= total_l) {\n    idx++;\n    if (idx % 1000 == 0) { std::cout &lt;&lt; \"\\\\r\" &lt;&lt; idx; }\n    v = rep_len(IntegerVector::create(idx), total_l / idx);\n    m_mat = IntegerMatrix(idx, v.size());\n    m_mat(idx - 1, _) = v * 10;\n    m_vec = IntegerVector(m_mat);\n    m_vec.attr(\"dim\") = R_NilValue;\n    m_vec = rep_len(m_vec, total_l);\n    sum_vec = sum_vec + m_vec;\n    for (int i = 0; i &lt; sum_vec.size(); i++) {\n      if (i &lt;= idx & sum_vec[i] &gt;= target) {\n        if (idx &gt; 1000) { std::cout.clear(); }\n        return IntegerVector::create(i) + 1;\n      }\n    }\n  }\n  if (idx &gt; 1000) { std::cout.clear(); }\n  return sum_vec;\n}\n')\npart1(36e6, 1e6)\n\n\n\n\ntarget &lt;- 36e6 / 10\nidx &lt;- 1\ns &lt;- 0\nd &lt;- seq_len(target)\ndenominator &lt;- d\nrepeat {\n  denominator &lt;- d[seq_len(idx)]\n  s &lt;- sum(denominator[idx %% denominator == 0])\n  if (s &lt; target) idx &lt;- idx + 1 else break\n}\nidx",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>91</span>  <span class='chapter-title'>20: Infinite Elves and Infinite Houses</span>"
    ]
  },
  {
    "objectID": "2015/20/2015-20.html#part-2",
    "href": "2015/20/2015-20.html#part-2",
    "title": "20: Infinite Elves and Infinite Houses",
    "section": "Part 2",
    "text": "Part 2\nFinally. Remembering the logic for the last fifty divisors took longer than it should’ve. At least it’s over now…\n\ntarget &lt;- 36e6\ni &lt;- 0\nrepeat {\n  i &lt;- i + 1\n  d &lt;- \n    i |&gt;\n    RcppBigIntAlgos::divisorsBig() |&gt;\n    as.integer()\n  n &lt;- sum(d[i %/% d &lt;= 50] * 11)\n  if (n &gt;= target) break\n}\ni\n\n[1] 884520",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>91</span>  <span class='chapter-title'>20: Infinite Elves and Infinite Houses</span>"
    ]
  },
  {
    "objectID": "2015/21/2015-21.html",
    "href": "2015/21/2015-21.html",
    "title": "21: RPG Simulator 20XX",
    "section": "",
    "text": "Part 1\nUghhh. Not that difficult but I swapped the order of who goes first in my brain then suffered for a long time.\ncombinations &lt;- function(shop, n) {\n  n |&gt;\n    map(\\(n) {\n      if (n == 0) return(list(\"V0\" = 0))\n      shop |&gt;\n        length() |&gt;\n        combn(n) |&gt;\n        as.data.frame() |&gt;\n        as.list()\n    }) |&gt;\n    unlist(recursive = FALSE)\n}\nweapons &lt;- combinations(shop$weapons, 1)\narmor &lt;- combinations(shop$armor, 0:1)\nrings &lt;- combinations(shop$rings, 0:2)\n\nexpand.grid(\n  \"w\" = seq_along(weapons),\n  \"a\" = seq_along(armor),\n  \"r\" = seq_along(rings)\n)|&gt;\n  pmap(\\(w, a, r) {\n    w &lt;- as.list(shop$weapons[[weapons[[w]]]])\n    a &lt;- if (armor[[a]] == 0) list(\"cost\" = 0, \"armor\" = 0) else as.list(shop$armor[[armor[[a]]]])\n    r &lt;- if (any(rings[[r]] == 0)) list(list(\"modifier\" = 0, \"cost\" = 0, \"damage\" = 0, \"armor\" = 0)) else map(rings[[r]], ~ as.list(shop$rings[[.x]]))\n    damage &lt;- w$damage + sum(map_dbl(r, ~ .x$damage), na.rm = TRUE)\n    armor &lt;- a$armor + sum(map_dbl(r, ~ .x$armor), na.rm = TRUE)\n    hp &lt;- 100\n    boss_hp &lt;- boss$hp\n    repeat {\n      my_damage &lt;- damage - boss$armor\n      boss_hp &lt;- if (my_damage &lt;= 0) { boss_hp - 1 } else { boss_hp - my_damage }\n      if (boss_hp &lt;= 0) { break }\n      boss_damage &lt;- boss$damage - armor\n      hp &lt;- if (boss_damage &lt;= 0) { hp - 1 } else { hp - boss_damage }\n      if (hp &lt;= 0) { break }\n    }\n    if (hp &gt; 0 & boss_hp &lt;= 0) {\n      return(w$cost + a$cost + sum(map_int(r, ~ .x$cost)))\n    } else {\n      return(NA_integer_)\n    }\n  }) |&gt;\n  unlist() |&gt;\n  min(na.rm = TRUE)\n\n[1] 78",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>92</span>  <span class='chapter-title'>21: RPG Simulator 20XX</span>"
    ]
  },
  {
    "objectID": "2015/21/2015-21.html#part-2",
    "href": "2015/21/2015-21.html#part-2",
    "title": "21: RPG Simulator 20XX",
    "section": "Part 2",
    "text": "Part 2\nClassic Advent. smh. But super easy.\n\nexpand.grid(\n  \"w\" = seq_along(weapons),\n  \"a\" = seq_along(armor),\n  \"r\" = seq_along(rings)\n)|&gt;\n  pmap(\\(w, a, r) {\n    w &lt;- as.list(shop$weapons[[weapons[[w]]]])\n    a &lt;- if (armor[[a]] == 0) list(\"cost\" = 0, \"armor\" = 0) else as.list(shop$armor[[armor[[a]]]])\n    r &lt;- if (any(rings[[r]] == 0)) list(list(\"modifier\" = 0, \"cost\" = 0, \"damage\" = 0, \"armor\" = 0)) else map(rings[[r]], ~ as.list(shop$rings[[.x]]))\n    damage &lt;- w$damage + sum(map_dbl(r, ~ .x$damage), na.rm = TRUE)\n    armor &lt;- a$armor + sum(map_dbl(r, ~ .x$armor), na.rm = TRUE)\n    hp &lt;- 100\n    boss_hp &lt;- boss$hp\n    repeat {\n      my_damage &lt;- damage - boss$armor\n      boss_hp &lt;- if (my_damage &lt;= 0) { boss_hp - 1 } else { boss_hp - my_damage }\n      if (boss_hp &lt;= 0) { break }\n      boss_damage &lt;- boss$damage - armor\n      hp &lt;- if (boss_damage &lt;= 0) { hp - 1 } else { hp - boss_damage }\n      if (hp &lt;= 0) { break }\n    }\n    if (hp &lt;= 0 & boss_hp &gt; 0) {\n      return(w$cost + a$cost + sum(map_int(r, ~ .x$cost)))\n    } else {\n      return(NA_integer_)\n    }\n  }) |&gt;\n  unlist() |&gt;\n  max(na.rm = TRUE)\n\n[1] 148",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>92</span>  <span class='chapter-title'>21: RPG Simulator 20XX</span>"
    ]
  },
  {
    "objectID": "2015/23/2015-23.html",
    "href": "2015/23/2015-23.html",
    "title": "23: Opening the Turing Lock",
    "section": "",
    "text": "Part 1\nThis was very annoying. I’m happy I got to use function factories, but I really do need to find a better way to write these “follow instructions” style programs. Maybe something with S4 or S7 so I can self reference?\ndt_i &lt;- dt[[1]]$instruction(list(dt, 1, 0, 0))\nrepeat {\n  dt_i &lt;- dt_i[[1]][[dt_i[[2]]]]$instruction(dt_i)\n  if (length(dt_i) == 2) { break }\n}\ndt_i[[2]]\n\n[1] 255",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>93</span>  <span class='chapter-title'>23: Opening the Turing Lock</span>"
    ]
  },
  {
    "objectID": "2015/23/2015-23.html#part-2",
    "href": "2015/23/2015-23.html#part-2",
    "title": "23: Opening the Turing Lock",
    "section": "Part 2",
    "text": "Part 2\nOh jeez. A super easy copy/paste part 2!\n\ndt_i &lt;- dt[[1]]$instruction(list(dt, 1, 1, 0))\nrepeat {\n  dt_i &lt;- dt_i[[1]][[dt_i[[2]]]]$instruction(dt_i)\n  if (length(dt_i) == 2) { break }\n}\ndt_i[[2]]\n\n[1] 334",
    "crumbs": [
      "2015",
      "<span class='chapter-number'>93</span>  <span class='chapter-title'>23: Opening the Turing Lock</span>"
    ]
  },
  {
    "objectID": "2024/02/2024-02.html",
    "href": "2024/02/2024-02.html",
    "title": "02: Red-Nosed Reports",
    "section": "",
    "text": "Part 1\nI missed the second condition for a pass at first. Mildly annoying, but not too bad globally.\ndt |&gt;\n  purrr::map_lgl(\\(x) {\n    x &lt;- x - lag(x)\n    x &lt;- x[!is.na(x)]\n    all(abs(x) %in% 1:3) & (all(x &lt; 0) | all(x &gt; 0))\n  }) |&gt; \n  sum()\n\n[1] 686",
    "crumbs": [
      "2024",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>02: Red-Nosed Reports</span>"
    ]
  },
  {
    "objectID": "2024/02/2024-02.html#part-2",
    "href": "2024/02/2024-02.html#part-2",
    "title": "02: Red-Nosed Reports",
    "section": "Part 2",
    "text": "Part 2\nI’m really pleased with this. I was trying something more functional, then realized a simple for loop was the way to go and that resulted in a 495 on the leaderboard. It’s also a good example for whatever it’s called that I did with my returns not just being if statements the whole way down.\n\ntest &lt;- function(x) {\n  x &lt;- x - lag(x)\n  x &lt;- x[!is.na(x)]\n  all(abs(x) %in% 1:3) & (all(x &lt; 0) | all(x &gt; 0))\n}\n\ndt |&gt;\n  purrr::map_lgl(\\(x) {\n    if (test(x)) return(TRUE)\n    \n    for(i in seq_along(x)) {\n      if (test(x[-i])) return(TRUE)\n    }\n    return(FALSE)\n  }) |&gt; sum()\n\n[1] 717",
    "crumbs": [
      "2024",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>02: Red-Nosed Reports</span>"
    ]
  }
]