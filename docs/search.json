[
  {
    "objectID": "index.html#star-chart",
    "href": "index.html#star-chart",
    "title": "Gus Lipkin’s Awesome Code",
    "section": "Star Chart",
    "text": "Star Chart"
  },
  {
    "objectID": "index.html#my-favorite-solutions",
    "href": "index.html#my-favorite-solutions",
    "title": "Gus Lipkin’s Awesome Code",
    "section": "My Favorite Solutions",
    "text": "My Favorite Solutions\n\n2021-09: I used the dbscan clustering method to solve a path finding issue.\n2022-04: While not my fastest part 1, part 2 took me just 38 seconds!\n2022-11: I used S3 Classes and function factories for the first time, and got just a little bit better at recursion."
  },
  {
    "objectID": "2022/01/2022-01.html#part-1",
    "href": "2022/01/2022-01.html#part-1",
    "title": "2022-01: Calorie Counting",
    "section": "Part 1",
    "text": "Part 1\nThis was just a matter of getting a loop with a maximum value counter going. I knew from the get-go that I would need to use the global assignment operator inside the loop. For reasons I thought that naming my variable sum would work but got an error since that’s a reserved word in R (duh!). Find+replace helped get that sorted but my inner loop logic was still wrong. I realized that I was missing an else case to catch any time the maximum hadn’t changed, but the sum needed to be reset.\n\nsm <- 0\nmaxsm <- 0\nfor (x in dt) {\n  x <- as.numeric(x)\n  if (!is.na(x)) {\n    sm <<- sm + x\n  } else if (sm > maxsm) {\n    maxsm <<- sm\n    sm <<- 0\n  } else {\n    sm <<- 0\n  }\n}\nmaxsm\n\n[1] 68923"
  },
  {
    "objectID": "2022/01/2022-01.html#part-2",
    "href": "2022/01/2022-01.html#part-2",
    "title": "2022-01: Calorie Counting",
    "section": "Part 2",
    "text": "Part 2\nComing out of Part 1 was really strong, especially on Day 1. Instead of saving just the max sum, I made it a vector to record all sums. Then I just need to sort it, get the top three values, and sum those.\n\nsm <- 0\nmaxsm <- c()\nfor (x in dt) {\n  x <- as.numeric(x)\n  if (!is.na(x)) {\n    sm <<- sm + x\n  } else  {\n    maxsm <<- c(maxsm, sm)\n    sm <<- 0\n  }\n}\nsum(sort(maxsm, decreasing = TRUE)[1:3])\n\n[1] 200044"
  },
  {
    "objectID": "2022/02/2022-02.html#part-1",
    "href": "2022/02/2022-02.html#part-1",
    "title": "2022-02: Rock Paper Scissors",
    "section": "Part 1",
    "text": "Part 1\nI initially did V1 == V2 but that doesn’t work with ABC and XYZ, but a quick fix put me at 549 on the leaderboard so I’m really pleased.\n\ndt %>%\n  mutate(\"my_score\" = case_when(\n    V2 == \"X\" ~ 1,\n    V2 == \"Y\" ~ 2,\n    V2 == \"Z\" ~ 3\n  )) %>%\n  mutate(\"win_score\" = case_when(\n    (V1 == \"A\" & V2 == \"X\") | (V1 == \"B\" & V2 == \"Y\") | (V1 == \"C\" & V2 == \"Z\") ~ 3,\n    V1 == \"A\" & V2 == \"Y\" ~ 6,\n    V1 == \"A\" & V2 == \"Z\" ~ 0,\n    V1 == \"B\" & V2 == \"X\" ~ 0,\n    V1 == \"B\" & V2 == \"Z\" ~ 6,\n    V1 == \"C\" & V2 == \"X\" ~ 6,\n    V1 == \"C\" & V2 == \"Y\" ~ 0\n  )) %>%\n  mutate(\"score\" = my_score + win_score) %>%\n  pull(\"score\") %>%\n  sum()\n\n[1] 14163"
  },
  {
    "objectID": "2022/02/2022-02.html#part-2",
    "href": "2022/02/2022-02.html#part-2",
    "title": "2022-02: Rock Paper Scissors",
    "section": "Part 2",
    "text": "Part 2\nI had this one pretty quick, just a bit of logic to get the play column right. Of course, I then had to remember to change all the right V2 references which took me a minute to figure out when I missed the second mutate.\n\ndt %>%\n  mutate(\"play\" = case_when(\n    V2 == \"X\" & V1 == \"A\" ~ \"Z\",\n    V2 == \"X\" & V1 == \"B\" ~ \"X\",\n    V2 == \"X\" & V1 == \"C\" ~ \"Y\",\n    V2 == \"Y\" & V1 == \"A\" ~ \"X\",\n    V2 == \"Y\" & V1 == \"B\" ~ \"Y\",\n    V2 == \"Y\" & V1 == \"C\" ~ \"Z\",\n    V2 == \"Z\" & V1 == \"A\" ~ \"Y\",\n    V2 == \"Z\" & V1 == \"B\" ~ \"Z\",\n    V2 == \"Z\" & V1 == \"C\" ~ \"X\",\n  )) %>%\n  mutate(\"my_score\" = case_when(\n    play == \"X\" ~ 1,\n    play == \"Y\" ~ 2,\n    play == \"Z\" ~ 3\n  )) %>%\n  mutate(\"win_score\" = case_when(\n    (V1 == \"A\" & play == \"X\") | (V1 == \"B\" & play == \"Y\") | (V1 == \"C\" & play == \"Z\") ~ 3,\n    V1 == \"A\" & play == \"Y\" ~ 6,\n    V1 == \"A\" & play == \"Z\" ~ 0,\n    V1 == \"B\" & play == \"X\" ~ 0,\n    V1 == \"B\" & play == \"Z\" ~ 6,\n    V1 == \"C\" & play == \"X\" ~ 6,\n    V1 == \"C\" & play == \"Y\" ~ 0\n  )) %>%\n  mutate(\"score\" = my_score + win_score) %>%\n  pull(\"score\") %>%\n  sum()\n\n[1] 12091"
  },
  {
    "objectID": "2022/03/2022-03.html#part-1",
    "href": "2022/03/2022-03.html#part-1",
    "title": "2022-03: Rucksack Reorganization",
    "section": "Part 1",
    "text": "Part 1\nUltimately not too bad. I got to make use of \\(x) for an anonymous function. I messed up the second half of the string and had it started at the end of the first half. I got docked a minute for the bad answer but then was able to fix it in time for resubmission.\n\ndata.frame(\"input\" = dt) %>%\n  mutate(V1 = substr(input, 1, nchar(input) / 2),\n         V2 = substr(input, nchar(input) / 2 + 1, nchar(input))) %>%\n  apply(1, \\(x) {\n    v1 <- unlist(strsplit(x[\"V1\"], \"\"))\n    v2 <- unlist(strsplit(x[\"V2\"], \"\"))\n    \n    return(v1[v1 %in% v2])\n  }) %>%\n  sapply(\\(x) {\n    x <- unique(x)\n    sum(which(letters == x), (which(LETTERS == x) + 26), na.rm = TRUE)\n  }) %>%\n  sum()\n\n[1] 7811"
  },
  {
    "objectID": "2022/03/2022-03.html#part-2",
    "href": "2022/03/2022-03.html#part-2",
    "title": "2022-03: Rucksack Reorganization",
    "section": "Part 2",
    "text": "Part 2\nI struggled with creating the groups for some reason. Once I had that going, the rest was pretty easy.\n\ndata.frame(\"input\" = dt) %>%\n  mutate(\"group\" = rep(1:(nrow(.) / 3), each = 3)) -> dt2\n\nd2 <- c()\nfor(g in unique(dt2$group)) {\n  d <- dt2$input[dt2$group == g]\n  \n  v1 <- unlist(strsplit(d[1], \"\"))\n  v2 <- unlist(strsplit(d[2], \"\"))\n  v3 <- unlist(strsplit(d[3], \"\"))\n    \n  d2 <<- c(d2, unique(v3[v3 %in% v1[v1 %in% v2]]))\n}\n\nsapply(d2, \\(x) {\n    x <- unique(x)\n    sum(which(letters == x), (which(LETTERS == x) + 26), na.rm = TRUE)\n  }) %>%\n  sum()\n\n[1] 2639"
  },
  {
    "objectID": "2022/04/2022-04.html#part-1",
    "href": "2022/04/2022-04.html#part-1",
    "title": "2022-04: Camp Cleanup",
    "section": "Part 1",
    "text": "Part 1\nIt took me a minute to figure out how I wanted to work with the data ranges. I started with mutate then lapply then quickly switched to mapply. From there it wrote itself. I then second-guessed my answer and divided by two because I thought I was double reporting the ranges. I cost myself a minute :(\n\nmapply(\\(x, y) {\n  x <- as.numeric(unlist(strsplit(x, \"-\")))\n  y <- as.numeric(unlist(strsplit(y, \"-\")))\n  \n  all(x[1]:x[2] %in% y[1]:y[2]) | all(y[1]:y[2] %in% x[1]:x[2])\n}, dt$V1, dt$V2) |>\n  unlist() |>\n  table() %>%\n  .[\"TRUE\"]\n\nTRUE \n 532"
  },
  {
    "objectID": "2022/04/2022-04.html#part-2",
    "href": "2022/04/2022-04.html#part-2",
    "title": "2022-04: Camp Cleanup",
    "section": "Part 2",
    "text": "Part 2\n38 seconds for part 2! I just had to change all to any.\n\nmapply(\\(x, y) {\n  x <- as.numeric(unlist(strsplit(x, \"-\")))\n  y <- as.numeric(unlist(strsplit(y, \"-\")))\n  \n  any(x[1]:x[2] %in% y[1]:y[2]) | any(y[1]:y[2] %in% x[1]:x[2])\n}, dt$V1, dt$V2) |>\n  unlist() |>\n  table() %>%\n  .[\"TRUE\"]\n\nTRUE \n 854"
  },
  {
    "objectID": "2022/05/2022-05.html#part-1",
    "href": "2022/05/2022-05.html#part-1",
    "title": "2022-05: Supply Stacks",
    "section": "Part 1",
    "text": "Part 1\nOnce I had the input in, it was relatively smooth sailing. I missed the part in part 1 where the boxes move one by one (oh part 2, how I wish I knew you then…) but once I had that fixed, I was looking pretty good. I got the test input working but then the real input wasn’t working. I eventually realized that my regex \\\\d was missing any numbers greater than 9 once that was fixed, everything else was pretty easy.\n\ndo_part(1)\n\nRows: 8 Columns: 9\n── Column specification ────────────────────────────────────────────────────────\n\nchr (9): X1, X2, X3, X4, X5, X6, X7, X8, X9\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nWarning in lapply(data.frame(str_match_all(tail(readLines(file_name), -(which(dt\n== : NAs introduced by coercion\n\n\n[1] \"ZBDRNPMVH\""
  },
  {
    "objectID": "2022/05/2022-05.html#part-2",
    "href": "2022/05/2022-05.html#part-2",
    "title": "2022-05: Supply Stacks",
    "section": "Part 2",
    "text": "Part 2\nAfter firing off a celebratory text message, I read part 2, deleted my rev and was done in 52 seconds!\n\ndo_part(2)\n\nRows: 8 Columns: 9\n── Column specification ────────────────────────────────────────────────────────\n\nchr (9): X1, X2, X3, X4, X5, X6, X7, X8, X9\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nWarning in lapply(data.frame(str_match_all(tail(readLines(file_name), -(which(dt\n== : NAs introduced by coercion\n\n\n[1] \"WDLPFNNNB\""
  },
  {
    "objectID": "2022/06/2022-06.html#part-1",
    "href": "2022/06/2022-06.html#part-1",
    "title": "2022-06: Tuning Trouble",
    "section": "Part 1",
    "text": "Part 1\nHardcoding everything will bite me in the butt later probably. Ultimately not too bad in hindsight.\n\nNewOriginal\n\n\n\ndo_part(4)\n\nbdjq \n1578 \n\n\n\n\n\ndata.frame(\"w\" = dt,\n           \"x\" = c(dt[-1], NA),\n           \"y\" = c(dt[-1:-2], NA, NA),\n           \"z\" = c(dt[-1:-3], NA, NA, NA)) |>\n  mutate(marker = paste0(w, x, y, z, sep = \"\")) |>\n  apply(1, function(x) {\n    max(table(strsplit(x[\"marker\"], \"\")))\n  }) -> tmp\n(which(tmp == 1) + 3)[1]\n\n[1] 1578"
  },
  {
    "objectID": "2022/06/2022-06.html#part-2",
    "href": "2022/06/2022-06.html#part-2",
    "title": "2022-06: Tuning Trouble",
    "section": "Part 2",
    "text": "Part 2\nWell, well, well. Hardcoding is never a good move. Took a bit of time to get it figured out, but I got there in the end.\n\nNewOriginal\n\n\n\ndo_part(14)\n\nmdcbnwqgshpvfj \n          2178 \n\n\n\n\n\nget_vec <- function(vec, place) {\n  if (place == 0) { return(vec) }\n  c(vec[-1:(-place)], rep(NA, place))\n}\n\nlapply(0:13, function(x) {\n  get_vec(dt, x)\n}) |>\n  data.frame() |>\n  `colnames<-`(paste0(\"X\", 1:14)) %>%\n  apply(1, function(x) {\n    paste0(x, collapse = \"\")\n  }) |>\n  sapply(function(x) {\n    max(table(strsplit(x, \"\")))\n  }) -> tmp\n(which(tmp == 1) + 13)[1]\n\nmdcbnwqgshpvfj \n          2178"
  },
  {
    "objectID": "2022/07/2022-07.html#part-1",
    "href": "2022/07/2022-07.html#part-1",
    "title": "2022-07: No Space Left On Device",
    "section": "Part 1",
    "text": "Part 1\nMy first attempt I just kinda hoped I wouldn’t need recursion. It was silly, but a guy can dream. My next idea was to just create the file system and so that’s what I did. Rather than making the files the size it says, I just filled them with one line holding the size so that I could read it in later. Getting the instructions fleshed out wasn’t too bad. It reminds me a lot of my Cat Simulator 2019 project from Intro to UNIX.\n\ndir.create(\"here_we_go\")\nsetwd(paste0(wd, \"/here_we_go\"))\n\ninvisible(sapply(dt, \\(x) {\n  if(grepl(\"dir \", x)) {\n    d <- str_remove(x, \"dir \")\n    if (!dir.exists(d)) { dir.create(d) }\n  } else if (grepl(\"[0-9]+\", x)) {\n    f <- paste0(str_remove_all(x, \"[0-9 \\\\.]\"), \".txt\")\n    if (!file.exists(f)) {\n      f <- file(f)\n      content <-\n        paste0(as.numeric(paste0(\n          str_extract_all(x, \"\\\\d\", simplify = TRUE), collapse = \"\"\n        )), \"\\n\")\n      cat(content, file = f)\n      close(f)\n    }\n  } else if (grepl(\"\\\\$ cd \\\\.\\\\.\", x)) {\n    setwd(\"../\")\n  } else if (grepl(\"\\\\$ cd \\\\w\", x)) {\n    d <- str_remove(x, \"\\\\$ cd \")\n    if (!dir.exists(d)) { dir.create(d) }\n    setwd(d)\n  } else if (grepl(\"\\\\$ cd /\", x)) {\n    setwd(paste0(wd, \"/here_we_go\")) \n  } else if (!grepl(\"\\\\$ ls|\\\\$ cd /\", x)) { print(x) }\n}))\nsetwd(wd)\n\nGetting this bit working was a pain, but I’m really pleased with it. I had it working on the test input for a while before the real input which was excruciating, but I eventually tracked the problem down to my regex where I remove any file paths. In my earlier step where I repeated file paths then unlisted, any duplicates are assigned a trailing number. In the test input, this number was never more than one digit. In my regex, I was only looking for one digit and so any paths with no digits or more than one digit were missed. With that out of the way, it still doesn’t work. Eventually I realized I was collapsing my paths backwards so all my folder sizes were reversed. Fixing that eventually got me where I needed to be.\n\nv <- \npaste0(\"here_we_go/\", list.files(\"here_we_go\", recursive = TRUE)) |>\n  sapply(\\(x) {\n    count <- str_count(x, \"/\") - 1\n    count <- ifelse(count == 0, 1, count)\n    rep(x, count)\n  }) \npaths <-\n  v |>\n  lapply(\\(x) {\n    xx <- str_remove(x, \"here_we_go/\")\n    sapply(0:(length(x) - 1), \\(x) {\n      if (x == 0) { return(xx) }\n      m <- str_split(xx, \"/\")[[1]]\n      m <- m[-(length(m) - (1:x))]\n      m <- paste0(m, collapse = \"/\")\n      return(m)\n    }) |>\n      unlist() |>\n      unique()\n  }) |>\n  unlist() |>\n  unname()\n\nfiles <- \n  v |>\n  unlist() |>\n  sapply(\\(x) {\n    x <- as.numeric(readLines(x))\n  }) |>\n  data.frame() |>\n  rownames_to_column(var = \"path\") |>\n  `colnames<-`(c(\"full_path\", \"size\")) |>\n  cbind(paths) |>\n  mutate(path = str_remove(paths, \"/\\\\w*\\\\.txt\\\\d*\"))\n  # filter(grepl(\"\\\\.txt\", path)) |>\n  # mutate(path = str_remove(path, \"/\\\\w*\\\\.txt[0-9]?\"))\nfiles |>\n  group_by(path) |>\n    summarise(size = sum(size)) |>\n    arrange(path, .by_group = TRUE) |>\n  ungroup() |>\n  filter(size <= 100000) |>\n  pull(size) |>\n  sum()\n\n[1] 1297683"
  },
  {
    "objectID": "2022/07/2022-07.html#part-2",
    "href": "2022/07/2022-07.html#part-2",
    "title": "2022-07: No Space Left On Device",
    "section": "Part 2",
    "text": "Part 2\nThis wasn’t too bad. Just took a bit to make the changes needed from part 1. I was briefly stuck when just grouping by path in the second pipeline, but adding the level grouping took care of it and I was good to go!\n\nf <- \n  files |>\n  select(paths, size) |>\n  mutate(path = str_remove(paths, \"/\\\\w*\\\\.txt\\\\d*\")) |>\n  select(-paths) |>\n  unique() |>\n  group_by(path) |>\n    summarise(size = sum(size)) |>\n    ungroup() |>\n  mutate(level = str_count(path, \"/\"))\nhome <- sum(f$size[f$level == 0])\n\nf |>\n  group_by(path, level) |>\n    summarise(size = sum(size), .groups = \"keep\") |>\n    arrange(path, .by_group = TRUE) |>\n    ungroup() |>\n  mutate(free = 70000000 - home,\n         sort = size + free) |>\n  arrange(desc(sort), size) |>\n  filter(sort > 30000000) |>\n  tail(1) |>\n  pull(size)\n\n[1] 5756764"
  },
  {
    "objectID": "2022/08/2022-08.html#part-1",
    "href": "2022/08/2022-08.html#part-1",
    "title": "2022-08: Treetop Tree House",
    "section": "Part 1",
    "text": "Part 1\nThis was a weird one. I’m writing this the day after I wrote the code, and I have no clue what my thought process was. I did it reasonably quickly so I’m not too unhappy with it.\n\nmm <- \n  dt |>\n  as.matrix() |>\n  as.character() |>\n  str_split(\"\", simplify = TRUE) |>\n  apply(c(1, 2), as.numeric)\n\ngrid <- expand.grid(\"col\" = 1:ncol(mm), \"row\" = 1:nrow(mm))\n\nm <-\n  mapply(\\(x, y) {\n    tree <- mm[y, x]\n    \n    if (x == 1 | x == ncol(mm) | y == 1 | y == nrow(mm)) { return(c(x, y)) }\n    \n    if (all(mm[(y + 1):nrow(mm), x] < tree, na.rm = TRUE) |\n        all(mm[1:(y - 1), x] < tree, na.rm = TRUE) |\n        all(mm[y, 1:(x - 1)] < tree, na.rm = TRUE) |\n        all(mm[y, (x + 1):ncol(mm)] < tree, na.rm = TRUE)) {\n      return(c(x, y))\n    }\n  }, grid$col, grid$row)\n\nm[!sapply(m, is.null)] %>%\n  do.call(rbind, .) |>\n  data.frame() |>\n  `colnames<-`(c(\"col\", \"row\")) -> mi\nnrow(mi)\n\n[1] 1717"
  },
  {
    "objectID": "2022/08/2022-08.html#part-2",
    "href": "2022/08/2022-08.html#part-2",
    "title": "2022-08: Treetop Tree House",
    "section": "Part 2",
    "text": "Part 2\nThis was a mess. I kept trying to be smart about it and wasted so much time. I mostly had trouble working with patterns like [5050] where the first five can see both the zero and the second five, but not the second zero. This meant that x < 5 ignored the five, and x <= 5 would keep going and read over the remaining zero. Even though I ended up hard-coding everything, I’m rather pleased with how neat it is. I’m sure I could move more of it to functions, but it wouldn’t be too much prettier, if any.\n\nscenic <- matrix(NA, nrow(mm), ncol(mm))\n\nchecker <- function(vec, i, tree, dir) {\n  vec <- detect_index(vec, \\(.x) { .x >= tree }) \n  if (dir == -1) { vec <- ifelse(vec == 0, i - 1, vec) }\n  else { vec <- ifelse(vec == 0, ncol(mm) - i, vec) }\n  vec\n}\n\nmapply(\\(y, x) {\n  tree <- mm[y, x]\n  up <- NA; down <- NA; left <- NA; right <- NA\n  if (y == 1) { up <- 0 }; if (y == nrow(mm)) { down <- 0 }\n  if (x == 1) { left <- 0}; if (x == ncol(mm)) { right <- 0 }\n  \n  rowMin <- ifelse(y - 1 < 1, 1, y - 1); rowMax <- ifelse(y + 1 > nrow(mm), nrow(mm), y + 1)\n  colMin <- ifelse(x - 1 < 1, 1, x - 1); colMax <- ifelse(x + 1 > ncol(mm), ncol(mm), x + 1)\n  \n  yMin <- ifelse(y - 1 < 1, 1, y - 1); yMax <- ifelse(y + 1 > nrow(mm), nrow(mm), y + 1)\n  xMin <- ifelse(x - 1 < 1, 1, x - 1); xMax <- ifelse(x + 1 > ncol(mm), ncol(mm), x + 1)\n  \n  if (is.na(up)) { up <- checker(rev(mm[1:yMin, x]), y, tree, -1) }\n  if (is.na(left)) { left <- checker(rev(mm[y, 1:xMin]), x, tree, -1) }\n  if (is.na(right)) { right <- checker(mm[y, xMax:ncol(mm)], x, tree, 1) }\n  if (is.na(down)) { down <- checker(mm[rowMax:nrow(mm), x], y, tree, 1) }\n  \n  scene <- c(up, left, right, down)\n  scenic[y, x] <<- prod(scene[scene != 0])\n}, grid$row, grid$col) |> invisible()\nmax(scenic)\n\n[1] 321975"
  },
  {
    "objectID": "2022/10/2022-10.html#part-1",
    "href": "2022/10/2022-10.html#part-1",
    "title": "2022-10: Cathode-Ray Tube",
    "section": "Part 1",
    "text": "Part 1\nPart 1 wasn’t too bad. I was a really big dummy and forgot to download the test input then was trying to check my real input as the test input which didn’t work. Other than that, I’m really happy I got to use mistlecode::expand_directions which I only wrote a few hours prior. I did have to make some live modifications, but nothing crazy. Once everything was mostly right, I had a problem where the first five signals were correct, but the last wasn’t. I eventually realized that I needed to lead the add values and that got everything sorted.\n\ndt <-\n  dt |>\n  mutate(\"mag\" = ifelse(X1 == \"noop\", 1, 2)) |>\n  select(\"dir\" = \"X1\", \"mag\", \"X2\") |>\n  mutate(ins = row_number()) |>\n  expand_directions(preserve_data = TRUE) |>\n  data.table()\n\ndt$dup = duplicated(dt$ins, fromLast = TRUE)\ndt$X2 = ifelse(dt$dup, NA, dt$X2)\n\ndt$X3 <- lead(dt$X2, 1)\n\nsapply(c(20, 60, 100, 140, 180, 220), \\(x) {\n  sum(1, sum(dt[1:x, \"X3\"], na.rm = TRUE)) * x\n}) |>\n  sum()\n\n[1] 14260"
  },
  {
    "objectID": "2022/10/2022-10.html#part-2",
    "href": "2022/10/2022-10.html#part-2",
    "title": "2022-10: Cathode-Ray Tube",
    "section": "Part 2",
    "text": "Part 2\nThis was an absolute mess. I didn’t understand the question at all and still don’t really get it. The difference between what I had and what I thought I should have made the solution relatively clear, but only after struggling with it for hours. I do like ggplot-able solutions though. Those are always nice.\n\nm <- matrix(\" \", 6, 40)\n\ndt$X2 <- ifelse(is.na(dt$X2), 0, dt$X2)\ndt$cumsum <- sapply(1:240, \\(x) { sum(1, sum(dt[1:x, \"X2\"], na.rm = TRUE)) })\n\nm <-\n  sapply(1:240, \\(x) {\n    forty <- (x %/% 40)\n    cumsum <- c(dt$cumsum[x] - 1, dt$cumsum[x], dt$cumsum[x] + 1)\n    sprite_pos <- cumsum[!is.na(cumsum)]\n    if (any((sprite_pos + (40 * forty)) == x)) {\n      sprite_pos <- suppressWarnings(min(which(sprite_pos == x), na.rm = TRUE))\n      if (sprite_pos == 1) { sprite_pos <- cumsum[1] }\n      else if (sprite_pos == 3) { sprite_pos <- cumsum[3] }\n      else { sprite_pos <- cumsum[2] }\n      return(sprite_pos + (40 * forty))\n    }\n    return(NA)\n  })\n\nm[240] <- 0\n\nmatrix_to_coords(matrix(m, 6, 40, byrow = TRUE)) |>\n  data.frame() |>\n  filter(!is.na(data)) |>\n  mutate(col = ifelse(col == 40, 0, col)) |>\n  ggplot() +\n  geom_point(aes(x = col, y = -row), size = 5, shape = 15) +\n  coord_fixed()"
  },
  {
    "objectID": "2022/11/2022-11.html#part-1",
    "href": "2022/11/2022-11.html#part-1",
    "title": "2022-11: Monkey in the Middle",
    "section": "Part 1",
    "text": "Part 1\nThis was so much fun! I dipped my toes into S3 classes, made a useful function factory, and did some recursion. I had a bit of trouble making sure my list of monkeys was getting passed around properly and returned because loops can’t change objects in the global environment. That said, I have a bad feeling about part 2.\n\noperation <- function(op, val) {\n  function(old) {\n    if (val == \"old\") { val <- as.integer(old) } \n    else { val <- as.integer(val) }\n    \n    if (op == \"*\") { val <- old * val }\n    else if (op == \"+\") { val <- old + val }\n    \n    return(val)\n  }\n}\n\nnew_monkey <- function(dt, x) {\n  name <- str_extract(dt[1,\"dt\"], \"\\\\d+\")\n  items <- \n    str_split(dt[2,\"dt\"], \":|,\", simplify = TRUE)[1,-1] |> as.numeric()\n  opp <- \n    str_split(dt[3, \"dt\"], \"=\", simplify = TRUE)[1,2] |>\n    str_match(\" (new|old) (\\\\+|\\\\-|\\\\*|\\\\/) (old|\\\\d+)\")\n  op_op <- opp[1,3]\n  op_num <- ifelse(opp[1,4])\n  op <- operation(op = opp[1,3], val = opp[1,4])\n  test <- str_extract(dt[4,\"dt\"], \"\\\\d+\") |> as.integer()\n  case_true <- str_extract(dt[5,\"dt\"], \"\\\\d+\")\n  case_false <- str_extract(dt[6,\"dt\"], \"\\\\d+\")\n  x <- list(\n    \"name\" = name,\n    \"items\" = items,\n    \"operation\" = op,\n    \"test\" = test,\n    \"case_true\" = case_true,\n    \"case_false\" = case_false,\n    \"inspections\" = 0\n  )\n  structure(x, class = \"monkey\")\n}\n\nmonkeys <- \n  lapply(unique(dt$monkey), \\(m) { \n    new_monkey(dt[dt$monkey == m,], m) \n  })\nnames(monkeys) <- sapply(monkeys, \\(m) m$name)\n\nprocess_items <- function(item, monkey, these_monkeys) {\n  if (is.na(monkey$items[item]) | \n      item > length(monkey$items)) { return(these_monkeys) }\n  worry_level <- monkey$operation(monkey$items[item])\n  worry_level <- floor(worry_level / 3)\n  if (worry_level %% monkey$test == 0) {\n    case_true <- \n      c(these_monkeys[[monkey$case_true]]$items, worry_level)\n    these_monkeys[[monkey$case_true]]$items <- \n      case_true[!is.na(case_true)]\n  } else {\n    case_false <- \n      c(these_monkeys[[monkey$case_false]]$items, worry_level)\n    these_monkeys[[monkey$case_false]]$items <- \n      case_false[!is.na(case_false)]\n  }\n  process_items(item + 1, monkey, these_monkeys)\n}\n\nprocess_monkey <- function(i, these_monkeys) {\n  if (i == length(monkeys) + 1) { return(these_monkeys) }\n  monkey <- these_monkeys[[i]]\n  these_monkeys <- process_items(1, monkey, these_monkeys)\n  monkey$inspections <- \n    sum(monkey$inspections, length(monkey$items), na.rm = TRUE)\n  monkey$items <- as.numeric(NA)\n  these_monkeys[[i]] <- monkey\n  process_monkey(i + 1, these_monkeys)\n}\n\nround <- function(these_monkeys, round) {\n  if (round == round_max + 1) { return(these_monkeys) }\n  these_monkeys <- process_monkey(1, these_monkeys)\n  round(these_monkeys, round + 1)\n}\n\n\nround_max <- 20\nm <- round(monkeys, 1)\nsapply(m, \\(m) m$inspections) |>\n  sort(decreasing = TRUE) |>\n  head(2) |>\n  prod()\n\n[1] 316888"
  },
  {
    "objectID": "2022/11/2022-11.html#part-2",
    "href": "2022/11/2022-11.html#part-2",
    "title": "2022-11: Monkey in the Middle",
    "section": "Part 2",
    "text": "Part 2\nI want to scream. I submitted my answer just to see and it’s right, even though the test input was wrong. I could’ve submitted yesterday 😭 So many hours devoted to these monkeys for nothing…\nI figured out the worry_level %% prod(tests) thing pretty quick after part 1, but it took a full day because the test input never lined up, even if I got super close. I still want to figure out why that is, but for now I’m just happy to have the star.\n\nprocess_items <- function(item, monkey, these_monkeys) {\n  if (is.na(monkey$items[item]) | \n      item > length(monkey$items)) { return(these_monkeys) }\n  worry_level <- monkey$operation(monkey$items[item])\n  case <- (worry_level %% monkey$test) == 0\n  worry_level <- worry_level %% prod(tests)\n  if (case) {\n    case_true <- \n      c(these_monkeys[[monkey$case_true]]$items, worry_level)\n    these_monkeys[[monkey$case_true]]$items <- \n      case_true[!is.na(case_true)]\n  } else {\n    case_false <- \n      c(these_monkeys[[monkey$case_false]]$items, worry_level)\n    these_monkeys[[monkey$case_false]]$items <- \n      case_false[!is.na(case_false)]\n  }\n  process_items(item + 1, monkey, these_monkeys)\n}\n\nm <- monkeys\ntests <- sapply(m, \\(m) m$test)\n\nround_max <- 1\ni <- 1\nwhile (i <= 10000) {\n  m <- process_monkey(1, m)\n  i <- i + 1\n}\n\nsapply(m, \\(m) m$inspections) |>\n  sort(decreasing = TRUE) |>\n  head(2) |>\n  prod()\n\n[1] 35270398814"
  },
  {
    "objectID": "2022/14/2022-14.html#part-1",
    "href": "2022/14/2022-14.html#part-1",
    "title": "2022-14: Regolith Reservoir",
    "section": "Part 1",
    "text": "Part 1\nFirst step is always making the matrix way bigger than it needs to be and filling it. Because everything’s a straight line, I can just match the current pair to the next pair and draw a line, essentially. Super easy with matrices. I want to check the bottom row for sand and if there isn’t sand, drop a new one from (1,500) (hooray for R being y,x and non-zero indexed!). Instead of iterating through the whole drop, I can just get the index of the last row in column 500 where there isn’t anything. This saves some computation. If I’m at the bottom, write a piece of sand. From there it’s just iterating over everything just like the instructions say. Lastly, get the amount of sand in the cave then subtract one to account for the last piece of sand that trips the loop.\n\nmaxCol <-\n  dt |>\n  str_extract_all(\"[0-9]{1,3},\") |>\n  suppressWarnings() |>\n  unlist() |>\n  str_remove_all(\",\") |>\n  as.numeric() |>\n  max()\ncave <- createCave(maxCol, maxCol)\nwhile(!any(cave[nrow(cave),] == \"o\")) {\n  col <- 500\n  row <- which(cave[,col] != \" \")[1] - 1\n  breakFlag <- FALSE\n  repeat {\n    if (row + 1 > nrow(cave)) { breakFlag <- TRUE }\n    else {\n      if (cave[row + 1, col] == \" \") {\n        row <- row + 1\n      } else if (col >= 2 & cave[row + 1, col - 1] == \" \") {\n        row <- row + 1; col <- col - 1\n      } else if (col < ncol(cave) & cave[row + 1, col + 1] == \" \") {\n        row <- row + 1; col <- col + 1\n      } else { breakFlag <- TRUE }\n    }\n    if (breakFlag) {\n      cave[row, col] <- \"o\"\n      break\n    }\n  }\n}\nwhich(cave == \"o\") |>\n  length() |>\n  sum(-1)\n\n[1] 961\n\n\n\nmatrix_to_coords(cave) |>\n  data.frame() |>\n  filter(data != \" \") |>\n  mutate(row = as.integer(row), col = as.integer(col)) |>\n  filter(row <= 200) |>\n  ggplot() +\n  geom_tile(aes(x = col, y = -row, fill = data))"
  },
  {
    "objectID": "2022/14/2022-14.html#part-2",
    "href": "2022/14/2022-14.html#part-2",
    "title": "2022-14: Regolith Reservoir",
    "section": "Part 2",
    "text": "Part 2\nOkay. I need to get the highest row, I can’t just make a massive matrix. Then add another row on top of where everything was drawn that will capture the top of the pyramid. Also, make a new column placeholder that can be added if I need to expand to the left or right. Because of that, I also need to track where column 500 is. If I’m going to have a column collision, I need to expand in that direction. Then, it’s business as usual, but now I’m checking to see if that original start point is full, no matter where it is. Lastly, don’t subtract one because the top grain does count now.\n\nmaxRow <-\n  dt |>\n  str_extract_all(\",[0-9]{1,3}\") |>\n  suppressWarnings() |>\n  unlist() |>\n  str_remove_all(\",\") |>\n  as.numeric() |>\n  max()\ncave <- createCave(maxRow + 1, maxCol)\ncave <- rbind(matrix(\" \", 1, ncol(cave)), cave)\nnewCol <- matrix(\" \", nrow(cave), 1)\nstartCol <- 500\nwhile (cave[1,startCol] != \"o\") {\n  col <- startCol\n  row <- which(cave[,col] != \" \")[1] - 1\n  breakFlag <- FALSE\n  repeat {\n    if (col == 2) { \n      cave <- cbind(newCol, cave)\n      startCol <- startCol + 1\n    } else if (col == ncol(cave) - 1) { cave <- cbind(cave, newCol) }\n    \n    if (row + 1 > nrow(cave)) { \n      breakFlag <- TRUE \n    } else {\n      if (cave[row + 1, col] == \" \") {\n        row <- row + 1\n      } else if (col >= 2 & cave[row + 1, col - 1] == \" \") {\n        row <- row + 1; col <- col - 1\n      } else if (col < ncol(cave) & cave[row + 1, col + 1] == \" \") {\n        row <- row + 1; col <- col + 1\n      } else { breakFlag <- TRUE }\n    }\n    if (breakFlag) {\n      cave[row, col] <- \"o\"\n      break\n    }\n  }\n}\nwhich(cave == \"o\") |>\n  length()\n\n[1] 26375\n\n\n\nmatrix_to_coords(cave) |>\n  data.frame() |>\n  filter(data != \" \") |>\n  mutate(row = as.integer(row), col = as.integer(col)) |>\n  filter(row <= maxRow) |>\n  ggplot() +\n  geom_tile(aes(x = col, y = -row, fill = data))"
  },
  {
    "objectID": "2022/20/2022-20.html#part-1",
    "href": "2022/20/2022-20.html#part-1",
    "title": "2022-20: Grove Positioning System",
    "section": "Part 1",
    "text": "Part 1\nPretty straightforward, all things considered. Getting vectors to wrap is always a pain. I also missed the bit about the numbers being after zero, but a quick which took care of that.\n\npos <- 1:length(dt)\n\nshift <- function(pos, x, shift) {\n  if (x == 0) { return(pos) }\n  p <- which(pos == x)\n  pos <- pos[-p]\n  after <- (p - 1 + shift) %% length(pos)\n  after <- ifelse(after == 0, length(pos), after)\n  append(pos, x, after = after)\n}\n\nfor(i in 1:length(dt)) { pos <- shift(pos, i, dt[i]) }\n\nget_sum <- function(dt, pos) {\n  zero <- which(dt[pos] == 0)\n  sapply(c(1e3, 2e3, 3e3), \\(x) {\n    x <- (x + zero) %% length(pos)\n    x <- ifelse(x == 0, length(pos), x)\n    dt[pos[x]]\n  }) |>\n    sum()\n}\n\nget_sum(dt, pos)\n\n[1] 4151"
  },
  {
    "objectID": "2022/20/2022-20.html#part-2",
    "href": "2022/20/2022-20.html#part-2",
    "title": "2022-20: Grove Positioning System",
    "section": "Part 2",
    "text": "Part 2\nBasically the same as Part 1. I was blessed with no integer overflows so that’s nice. Just multiply the vector by a constant, nest the for loop, then get the sum using the function from Part 1.\n\nkey <- 811589153\ndt2 <- dt * key\npos2 <- 1:length(dt)\n\nfor(j in 1:10) {\n  for (i in 1:length(dt2)) { pos2 <- shift(pos2, i, dt2[i]) }\n}\n\nget_sum(dt2, pos2)\n\n[1] 7848878698663"
  },
  {
    "objectID": "2022/21/2022-21.html#part-1",
    "href": "2022/21/2022-21.html#part-1",
    "title": "2022-21: Monkey Math",
    "section": "Part 1",
    "text": "Part 1\nLet’s take a chance to use R7 for the first time! I can build on the bits I learned with S3 in 2022-11. The idea to use a vector of monkey names (index) made it really easy to make sure I was pulling info from the right monkeys, rather than needing to iterate over the entire list. There’s probably a better approach overall with a more recursive solution, but this seems to work fine for Part 1, although I’m worried about Part 2.\n\nmonkey <- new_class(\n  name = \"monkey\",\n  properties = list(\n    name = class_character,\n    val = class_any,\n    op = class_character\n  )\n)\n\nnew_monkey <- function(x) {\n  if (!is.na(suppressWarnings(as.numeric(x[2])))) {\n    val <- as.numeric(x[2])\n    op <- NA_character_\n  } else {\n    val <- NA\n    op <- x[2]\n  }\n  monkey(\n    name = x[1],\n    val = val,\n    op = op\n  )\n}\n\nmonkeys <- lapply(dt, new_monkey)\nmasterMonkeys <- monkeys\nindex <- sapply(monkeys, \\(x) x@name)\n\nmonkey_math <- function(monkeys, op) {\n  m1 <- monkeys[[which(index == op[1])]]@val\n  m2 <- monkeys[[which(index == op[3])]]@val\n  \n  if (!is.na(m1) & !is.na(m2)) {\n    if (op[2] == \"+\") { m1 + m2 }\n    else if (op[2] == \"-\") { m1 - m2 }\n    else if (op[2] == \"*\") { m1 * m2 }\n    else if (op[2] == \"/\") { m1 / m2 }\n  } else { return(NA_integer_) }\n}\n\nprocess_monkeys <- function(monkeys, n = 1) {\n  if (n > length(monkeys)) { return(monkeys) }\n  if (is.na(monkeys[[n]]@val)) {\n    val <- str_split_1(monkeys[[n]]@op, \" \")\n    monkeys[[n]]@val <- monkey_math(monkeys, val)\n  }\n  if (monkeys[[n]]@name == \"root\" & !is.na(monkeys[[n]]@val)) { \n    return(monkeys[[n]]@val) \n  }\n  process_monkeys(monkeys, n + 1)\n}\n\nm <- monkeys\nwhile(is.list(m)) { m <- process_monkeys(m) }\nm\n\n[1] 93813115694560"
  },
  {
    "objectID": "2022/21/2022-21.html#part-2",
    "href": "2022/21/2022-21.html#part-2",
    "title": "2022-21: Monkey Math",
    "section": "Part 2",
    "text": "Part 2\nI tried brute-forcing it… It took a while to fully figure out what I wanted to do, but the idea behind just making a giant equation then solving for humn was there early on. I started by expanding the input by replacing monkeys with their value if they had one or operation if they didn’t. I then replaced all the monkeys with their values, just like in Part 1. This left me with a giant expression where the only variable was humn. I just wasn’t sure how to actually solve equations in R so I kept trying to brute-force it, which kept on not working. I eventually found the Ryacas package which made quick work of everything.\n\nmonkeys <- lapply(dt, new_monkey)\n\nroot_op <- \n  str_extract(monkeys[[which(index == \"root\")]]@op, \"(\\\\+|\\\\-|\\\\*|\\\\/)\")\nmonkeys[[which(index == \"root\")]]@op <- \n  gsub(paste0(\"\\\\\", root_op), \"=\", monkeys[[which(index == \"root\")]]@op)\n\nm1 <- str_split_1(monkeys[[which(index == \"root\")]]@op, \" = \")\nm2 <- m1[2]\nm1 <- m1[1]\n\nreplace_monkey <- function(m) {\n  w <- which(index == m)\n  if (length(w) == 0) { return(m) }\n  v <- monkeys[[w]]@val\n  if (is.na(v)) { return(paste0(\"( \", monkeys[[which(index == m)]]@op, \" )\")) }\n  return(paste0(\"( \", v, \" )\"))\n}\n\n# https://stackoverflow.com/a/14838753\nquotemeta <- function(string) { str_replace_all(string, \"(\\\\W)\", \"\\\\\\\\\\\\1\") }\n\nreduce_string <- function(mm, pattern) {\n  r <-\n    str_extract_all(mm, pattern) |>\n    unlist() |>\n    sapply(\\(r) {\n      if (grepl(\"h\", r)) { return(r) }\n      else { eval(parse(text = r)) }\n    })\n  \n  for (i in 1:length(r)) {\n    mm <- str_replace_all(mm, quotemeta(names(r)[i]), as.character(r[i]))\n  }\n  return(mm)\n}\n\nprocess_string <- function(m) {\n  while (any(grepl(\"([^(h)][a-z])\", m))) {\n    m <- \n      sapply(m, \\(mm) { replace_monkey(mm) }) |>\n      paste0(collapse = \" \") |>\n      str_split_1(\" \")\n  }\n  m <- paste0(m, collapse = \"\")\n  oldM <- 0\n  while (length(m) == 1 && oldM != m) {\n    oldM <- m\n    m <- reduce_string(m, \"\\\\((\\\\d+|h)\\\\)[\\\\+|\\\\-|\\\\*|\\\\/]\\\\((\\\\d+|h)\\\\)\")\n  }\n  return(oldM)\n}\n\nmonkeys[[which(index == \"humn\")]]@val <- \"h\"\nmm1 <- process_string(m1)\nmm2 <- process_string(m2)\n\npaste(\n    reduce_string(mm1, \"\\\\((\\\\d+|h)\\\\)\"), \n    \"==\", \n    reduce_string(mm2, \"\\\\((\\\\d+|h)\\\\)\")\n  ) %>%\n  Ryacas::y_fn(\"Solve\", \"h\") |>\n  Ryacas::yac_str() |>\n  str_extract(\"\\\\d+\") |>\n  as.numeric()\n\n[1] 3910938071092"
  },
  {
    "objectID": "2022/25/2022-25.html#part-1",
    "href": "2022/25/2022-25.html#part-1",
    "title": "2022-25: Full of Hot Air",
    "section": "Part 1",
    "text": "Part 1\nI was able to get Bob’s number pretty quickly. Then I realized I hadn’t fully read the question and I had to translate Bob’s number back into SNAFU. I had a few ideas on how to do it, but really struggled for some reason. I tried a recursive method first, but quickly hit C stack limits and couldn’t quite wrap my mind around how to brute-force it. I did realize that I could jump start the guessing by finding the smallest number greater than Bob’s that’s made entirely out of 2s. By starting there, I could subtract towards my goal, rather than trying to add, which would have been much more difficult. It was then just a matter of getting the code straight in my head, and using the un_snafu function to check my values every cycle.\n\nun_snafu <- function(x) {\n  x <- \n    x |>\n    str_split_1(\"\") |>\n    rev()\n\n  x <- case_when(\n    x == \"-\" ~ -1,\n    x == \"=\" ~ -2,\n    TRUE ~ as.numeric(x)\n  )\n\n  sum((5 ^ (0:(length(x)-1))) * x)\n}\n\nbob <- \n  dt |>\n  sapply(un_snafu) |>\n  suppressWarnings() |>\n  sum()\n\nsubtract <- function(x) {\n  case_when(\n    x == \"2\" ~ \"1\",\n    x == \"1\" ~ \"0\",\n    x == \"0\" ~ \"-\",\n    x == \"-\" ~ \"=\"\n  )\n}\n\nmax_places <-\n  sapply(1:100, \\(x) paste0(rep(\"2\", x), collapse = \"\")) |>\n  sapply(un_snafu)\nx <- names(which(max_places > bob)[1])\nplace <- 1\n\nrepeat {\n  x2 <- x\n  \n  s <- substr(x2, place, place)\n  if (s != \"=\") { substr(x2, place, place) <- subtract(s) } \n  else { place <- place + 1 }\n  \n  u <- un_snafu(x2)\n  if (u > bob) { x <- x2 }\n  else if (u < bob) { place <- place + 1 }\n  else { print(x2); break }\n} |>\n  suppressWarnings()\n\n[1] \"2-02===-21---2002==0\""
  },
  {
    "objectID": "2022/25/2022-25.html#part-2",
    "href": "2022/25/2022-25.html#part-2",
    "title": "2022-25: Full of Hot Air",
    "section": "Part 2",
    "text": "Part 2\n\n\n\n\n\n\nDanger\n\n\n\nThis puzzle does not unlock until you have completed the rest of the year. I’ll be back one day…"
  },
  {
    "objectID": "2021/01/2021-01.html#part-1",
    "href": "2021/01/2021-01.html#part-1",
    "title": "2021-01: Sonar Sweep",
    "section": "Part 1",
    "text": "Part 1\n\ndt$diff <- c(0, diff(dt$V1))\ndt %>%\n  filter(diff > 0) %>%\n  nrow()\n\n[1] 1374"
  },
  {
    "objectID": "2021/01/2021-01.html#part-2",
    "href": "2021/01/2021-01.html#part-2",
    "title": "2021-01: Sonar Sweep",
    "section": "Part 2",
    "text": "Part 2\n\ndt$diff <- c(0, 0, 0, diff(dt$V1, lag = 3))\ndt %>%\n  filter(diff > 0) %>%\n  nrow()\n\n[1] 1418"
  },
  {
    "objectID": "2021/01/2021-01.html#speed-edition",
    "href": "2021/01/2021-01.html#speed-edition",
    "title": "2021-01: Sonar Sweep",
    "section": "Speed Edition",
    "text": "Speed Edition\n\nFastest Solution\n\n# fastest solution\n# data.table was faster until I turned on warn=FALSE in readLines for Base R\ndt <- as.numeric(readLines(\"input.txt\", warn = FALSE))\n# part 1\nsum(diff(dt, lag = 1) > 0)\n\n[1] 1374\n\n# part 2\nsum(diff(dt, lag = 3) > 0)\n\n[1] 1418\n\n\n\n\nBenchmarks\n\nrbenchmark::benchmark(\n  \"First try\" = {\n    library(tidyverse)\n    library(data.table)\n    dt <- data.table(read.table(\"input.txt\", sep = \"\\n\"))\n    # part 1\n    dt$diff <- c(0, diff(dt$V1))\n    dt %>% filter(diff > 0) %>% nrow()\n    # part 2\n    dt$diff <- c(0, 0, 0, diff(dt$V1, lag = 3))\n    dt %>% filter(diff > 0) %>% nrow()\n    },\n  \"Base R\" = {\n    dt <- as.numeric(readLines(\"input.txt\", warn = FALSE))\n    # part 1\n    sum(diff(dt, lag = 1) > 0)\n    # part 2\n    sum(diff(dt, lag = 3) > 0)\n    },\n  \"data.table\" = {\n    # part 1 and 2\n    data.table::fread(\"input.txt\", \n                      sep = \"\\n\")[, .(diff1 = sum(diff(V1, lag = 1) > 0),\n                                      diff3 = sum(diff(V1, lag = 3) > 0))]\n  },\n  replications = 100, columns = c(1:5), order = \"user.self\")\n\n        test replications user.self sys.self elapsed\n2     Base R          100     0.023    0.004   0.027\n3 data.table          100     0.048    0.005   0.055\n1  First try          100     0.426    0.017   0.444"
  },
  {
    "objectID": "2021/02/2021-02.html#part-1",
    "href": "2021/02/2021-02.html#part-1",
    "title": "2021-02: Dive!",
    "section": "Part 1",
    "text": "Part 1\n\ndt <- data.table(read.table(\"input.txt\", sep = \"\\n\"))\ndt <- separate(dt, \"V1\", c(\"d\", \"n\"), sep = \" \", convert = TRUE)\ndt$n <- ifelse(dt$d == \"down\", dt$n * -1, dt$n)\n\nabs(dt[d == \"forward\", .(sum = sum(n))] * \n  as.numeric(dt[d != \"forward\", .(sum = sum(n))]))\n\n       sum\n1: 1635930"
  },
  {
    "objectID": "2021/02/2021-02.html#part-2",
    "href": "2021/02/2021-02.html#part-2",
    "title": "2021-02: Dive!",
    "section": "Part 2",
    "text": "Part 2\n\ndt <- data.table(read.table(\"input.txt\", sep = \"\\n\"))\ndt <- separate(dt, \"V1\", c(\"d\", \"n\"), sep = \" \", convert = TRUE)\n\ndt$aim <- ifelse(dt$d == \"up\" & dt$d != \"forward\", dt$n * -1, dt$n)\ndt$aim <- ifelse(dt$d == \"forward\", 0, dt$aim)\ndt$aim <- cumsum(dt$aim)\n\ndt$h <- ifelse(dt$d == \"forward\", dt$n, 0)\ndt$depth <- ifelse(dt$d == \"forward\", dt$aim * dt$n, 0)\n\nsum(dt$h, na.rm = TRUE) * sum(dt$depth, na.rm = TRUE)\n\n[1] 1781819478"
  },
  {
    "objectID": "2021/02/2021-02.html#speed-edition",
    "href": "2021/02/2021-02.html#speed-edition",
    "title": "2021-02: Dive!",
    "section": "Speed Edition",
    "text": "Speed Edition\nBase R once again beats out data.table by just a little bit. The big difference here was moving from colSums to sum, although readLines instead of fread does play a part.\n\nFastest solution\n\ndtM <- data.frame(\"V1\" = readLines(\"input.txt\"))\ndtM <- tidyr::separate(dtM, \"V1\", c(\"d\", \"n\"), sep = \" \", convert = TRUE)\n\n# part 1\ndt <- dtM\ndt$n <- ifelse(dt$d == \"down\", dt$n * -1, dt$n)\nabs(sum(dt$n[dt$d == \"forward\"]) * sum(dt$n[dt$d != \"forward\"]))\n\n[1] 1635930\n\n# part 2\ndt <- dtM\ndt$aim <- cumsum(ifelse(dt$d == \"up\", dt$n * -1, \n                        ifelse(dt$d == \"forward\", 0, dt$n)))\nsum(ifelse(dt$d == \"forward\", dt$n, 0), na.rm = TRUE) *\n  sum(ifelse(dt$d == \"forward\", dt$aim * dt$n, 0), na.rm = TRUE)\n\n[1] 1781819478\n\n\n\n\nBenchmarks\n\nrbenchmark::benchmark(\n  \"First try\" = {\n    library(data.table)\n    # part 1\n    dt <- data.table(read.table(\"input.txt\", sep = \"\\n\"))\n    dt <- tidyr::separate(dt, \"V1\", c(\"d\", \"n\"), sep = \" \", convert = TRUE)\n    dt$n <- ifelse(dt$d == \"down\", dt$n * -1, dt$n)\n\n    abs(dt[d == \"forward\", .(sum = sum(n))] * \n          as.numeric(dt[d != \"forward\", .(sum = sum(n))]))\n    \n    # part 2\n    dt <- data.table(read.table(\"input.txt\", sep = \"\\n\"))\n    dt <- tidyr::separate(dt, \"V1\", c(\"d\", \"n\"), sep = \" \", convert = TRUE)\n\n    dt$aim <- ifelse(dt$d == \"up\" & dt$d != \"forward\", dt$n * -1, dt$n)\n    dt$aim <- ifelse(dt$d == \"forward\", 0, dt$aim)\n    dt$aim <- cumsum(dt$aim)\n\n    dt$h <- ifelse(dt$d == \"forward\", dt$n, 0)\n    dt$depth <- ifelse(dt$d == \"forward\", dt$aim * dt$n, 0)\n    \n    sum(dt$h, na.rm = TRUE) * sum(dt$depth, na.rm = TRUE)\n    },\n  \"Base R\" = {\n    dtM <- data.frame(\"V1\" = readLines(\"input.txt\"))\n    dtM$n <- na.omit(as.numeric(unlist(strsplit(dtM$V1, \" \"))))\n    dtM$d <- as.character(unlist(strsplit(dtM$V1, \" \")))[\n      is.na(as.numeric(unlist(strsplit(dtM$V1, \" \"))))]\n    \n    # part 1\n    dt <- dtM\n    dt$n <- ifelse(dt$d == \"down\", dt$n * -1, dt$n)\n    abs(sum(dt$n[dt$d == \"forward\"]) * sum(dt$n[dt$d != \"forward\"]))\n    \n    # part 2\n    dt <- dtM\n    dt$aim <- cumsum(ifelse(dt$d == \"up\", dt$n * -1, \n                            ifelse(dt$d == \"forward\", 0, dt$n)))\n    sum(ifelse(dt$d == \"forward\", dt$n, 0), na.rm = TRUE) * \n      sum(ifelse(dt$d == \"forward\", dt$aim * dt$n, 0), na.rm = TRUE)\n    },\n  \"data.table\" = {\n    library(data.table)\n    dtM <- fread(\"input.txt\", sep = \"\\n\", header = FALSE)\n    dtM <- tidyr::separate(dtM, \"V1\", c(\"d\", \"n\"), sep = \" \", convert = TRUE)\n\n    # part 1\n    dt <- dtM\n    dt$n <- ifelse(dt$d == \"down\", dt$n * -1, dt$n)\n    abs(colSums(dt[d == \"forward\", .(n)]) * colSums(dt[d != \"forward\", .(n)]))\n    \n    # part 2\n    dt <- dtM\n    dt$aim <- cumsum(ifelse(dt$d == \"up\", dt$n * -1, \n                            ifelse(dt$d == \"forward\", 0, dt$n)))\n    sum(ifelse(dt$d == \"forward\", dt$n, 0), na.rm = TRUE) * \n      sum(ifelse(dt$d == \"forward\", dt$aim * dt$n, 0), na.rm = TRUE)\n    },\n  replications = 100, columns = c(1:5), order = \"user.self\")\n\n        test replications user.self sys.self elapsed\n2     Base R          100     0.228    0.007   0.234\n3 data.table          100     0.829    0.056   0.885\n1  First try          100     1.588    0.117   1.706"
  },
  {
    "objectID": "2021/03/2021-03.html#part-1",
    "href": "2021/03/2021-03.html#part-1",
    "title": "2021-03: Binary Diagnostic",
    "section": "Part 1",
    "text": "Part 1\n\n# part 1\ndt <- data.frame(fread(\"input.txt\", sep = \"\\n\", colClasses = c(\"character\")))\ndt <- tidyr::separate(dt, \"V1\", paste0(\"V\", 1:13), sep = \"\", convert = TRUE)\n\nget_mode <- function(x)\n  return(names(sort(table(x), decreasing = T, na.last = T)[1]))\no <- c()\nfor(i in 2:13)\n  o <- append(o, get_mode(dt[,i]))\n\no <- unbinary(paste(o, collapse = \"\"))\n\nget_mode <- function(x)\n  return(names(sort(table(x), na.last = T)[1]))\nc <- c()\nfor(i in 2:13)\n  c <- append(c, get_mode(dt[,i]))\nc <- unbinary(paste(c, collapse = \"\"))\n\no * c\n\n[1] 4174964"
  },
  {
    "objectID": "2021/03/2021-03.html#part-2",
    "href": "2021/03/2021-03.html#part-2",
    "title": "2021-03: Binary Diagnostic",
    "section": "Part 2",
    "text": "Part 2\n\n# part 2\ndtM <- data.frame(fread(\"input.txt\", sep = \"\\n\", colClasses = c(\"character\")))\ndtM <- tidyr::separate(dtM, \"V1\", paste0(\"V\", 1:13), sep = \"\", convert = TRUE)\ndtM <- dtM %>% select(-\"V1\")\ndt <- dtM\n\nget_modeMax <- function(x){\n  temp <- sort(table(x), decreasing = T, na.last = T)\n  ifelse(temp[1] == temp[2], return(1), names(temp[1]))\n}\no <- c()\n\nfor(i in 1:12) {\n  dt <- dt %>%\n    filter_at(i, all_vars(.==get_modeMax(dt[,i])))\n  if(nrow(dt) == 1) {\n    oxygen <- paste(as.character(dt[1,]), collapse = \"\")\n    break\n  }\n}\n\ndt <- dtM\nget_modeMin <- function(x){\n  temp <- sort(table(x), na.last = T)\n  ifelse(temp[1] == temp[2], return(0), names(temp[1]))\n}\nc <- c()\n\nfor(i in 1:12) {\n  dt <- dt %>%\n    filter_at(i, all_vars(.==get_modeMin(dt[,i])))\n  if(nrow(dt) == 1) {\n    co2 <- paste(as.character(dt[1,]), collapse = \"\")\n    break\n  }\n}\n\nunbinary(oxygen) * unbinary(co2)\n\n[1] 4474944"
  },
  {
    "objectID": "2021/03/2021-03.html#speed-edition",
    "href": "2021/03/2021-03.html#speed-edition",
    "title": "2021-03: Binary Diagnostic",
    "section": "Speed Edition",
    "text": "Speed Edition\nToday was bad. I misread the instructions, forgot a bunch of basic functions, and so much more. I couldn’t get any of the base reading functions to read my input properly so I ended up with fread from data.table. I also haven’t been able to make any significant speed improvements from my initial solution.\nI’m not sure why readLines wasn’t working last night but I also switched to str_split_fixed from stringr and it’s so much faster now.\n\nFastest solution\n\nlibrary(dplyr)\n# part 1\ndt <- stringr::str_split_fixed(readLines(\"input.txt\"), pattern = \"\", n = 12)\ndt <- data.frame(apply(dt, 2, as.integer))\n\ngetModeMin <- function(x)\n  return(ifelse(mean(x) > .5, 0, 1))\ngetModeMax <- function(x)\n  return(ifelse(mean(x) > .5, 1, 0))\n\nstrtoi(paste(apply(dt, 2, getModeMax), collapse = \"\"), base = 2) *\n  strtoi(paste(apply(dt, 2, getModeMin), collapse = \"\"), base = 2)\n\n[1] 4174964\n\n# part 2\ndto <- dt\ndtc <- dt\n\nfor (i in 1:12) {\n  if (nrow(dto) > 1)\n    dto <- dto |>\n      filter_at(i, all_vars(. == ifelse(mean(dto[, i]) >= .5, 1, 0)))\n  if (nrow(dtc) > 1)\n    dtc <- dtc |>\n      filter_at(i, all_vars(. == ifelse(mean(dtc[, i]) < .5, 1, 0)))\n}\n\nstrtoi(paste(as.character(dto[1,]), collapse = \"\"), base = 2) *\n  strtoi(paste(as.character(dtc[1,]), collapse = \"\"), base = 2)\n\n[1] 4474944\n\n\n\n\nBenchmarks\n\nrbenchmark::benchmark(\n  \"First try\" = {\n    library(tidyverse)\n    library(data.table)\n    library(compositions)\n    \n    # part 1\n    dt <- data.frame(fread(\"input.txt\", sep = \"\\n\", \n                           colClasses = c(\"character\")))\n    dt <- tidyr::separate(dt, \"V1\", paste0(\"V\", 1:13), \n                          sep = \"\", convert = TRUE)\n    \n    get_mode <- function(x)\n      return(names(sort(table(x), decreasing = T, na.last = T)[1]))\n    o <- c()\n    for (i in 2:13)\n      o <- append(o, get_mode(dt[, i]))\n    o <- unbinary(paste(o, collapse = \"\"))\n    \n    get_mode <- function(x)\n      return(names(sort(table(x), na.last = T)[1]))\n    c <- c()\n    for (i in 2:13)\n      c <- append(c, get_mode(dt[, i]))\n    c <- unbinary(paste(c, collapse = \"\"))\n    \n    o * c\n    \n    # part 2\n    dtM <- data.frame(fread(\"input.txt\", sep = \"\\n\",\n                            colClasses = c(\"character\")))\n    dtM <- tidyr::separate(dtM, \"V1\", paste0(\"V\", 1:13),\n                           sep = \"\", convert = TRUE)\n    dtM <- dtM %>% select(-\"V1\")\n    dt <- dtM\n\n    get_modeMax <- function(x) {\n      temp <- sort(table(x), decreasing = T, na.last = T)\n      ifelse(temp[1] == temp[2], return(1), names(temp[1]))\n    }\n    o <- c()\n    for (i in 1:12) {\n      dt <- dt %>% filter_at(i, all_vars(. == get_modeMax(dt[, i])))\n      if (nrow(dt) == 1) {\n        oxygen <- paste(as.character(dt[1, ]), collapse = \"\")\n        break\n      }\n    }\n\n    dt <- dtM\n    get_modeMin <- function(x) {\n      temp <- sort(table(x), na.last = T)\n      ifelse(temp[1] == temp[2], return(0), names(temp[1]))\n    }\n    c <- c()\n    for (i in 1:12) {\n      dt <- dt %>% filter_at(i, all_vars(. == get_modeMin(dt[, i])))\n      if (nrow(dt) == 1) {\n        co2 <- paste(as.character(dt[1, ]), collapse = \"\")\n        break\n      }\n    }\n\n    unbinary(oxygen) * unbinary(co2)\n    },\n    \"Second try\" = {\n      library(tidyverse)\n      library(data.table)\n      library(compositions)\n      \n      # part 1\n      dt <- fread(\"input.txt\", sep = \"\\n\", colClasses = c(\"character\")) %>%\n        as.data.frame() %>%\n        tidyr::separate(\"V1\", paste0(\"V\", 1:13), sep = \"\", convert = TRUE) %>%\n        select(-\"V1\")\n      \n      getModeMin <- function(x)\n        return(names(sort(table(x), na.last = T)[1]))\n      getModeMax <- function(x)\n        return(names(sort(\n          table(x), decreasing = T, na.last = T\n        )[1]))\n      \n      o <- unbinary(paste(apply(dt, 2, getModeMax), collapse = \"\"))\n      \n      c <- unbinary(paste(apply(dt, 2, getModeMin), collapse = \"\"))\n      \n      o * c\n      \n      # part 2\n      dtM <-\n        fread(\"input.txt\", sep = \"\\n\", colClasses = c(\"character\")) %>%\n        as.data.frame() %>%\n        tidyr::separate(\"V1\", paste0(\"V\", 1:13), sep = \"\", convert = TRUE) %>%\n        select(-\"V1\")\n      dto <- dtM\n      dtc <- dtM\n      \n      getModeMin <- function(x) {\n        temp <- sort(table(x), na.last = T)\n        ifelse(temp[1] == temp[2], return(0), names(temp[1]))\n      }\n      getModeMax <- function(x) {\n        temp <- sort(table(x), decreasing = T, na.last = T)\n        ifelse(temp[1] == temp[2], return(1), names(temp[1]))\n      }\n      \n      for (i in 1:12) {\n        if (nrow(dto) > 1)\n          dto <-\n            dto %>% filter_at(i, all_vars(. == getModeMax(dto[, i])))\n        if (nrow(dtc) > 1)\n          dtc <-\n            dtc %>% filter_at(i, all_vars(. == getModeMin(dtc[, i])))\n        if (nrow(dto) == 1 & nrow(dtc) == 1) {\n          oxygen <- paste(as.character(dto[1,]), collapse = \"\")\n          co2 <- paste(as.character(dtc[1,]), collapse = \"\")\n          break\n        }\n      }\n      \n      unbinary(oxygen) * unbinary(co2)\n    }, \n  \"Third try\" = {\n    library(dplyr)\n    # part 1\n    dt <- \n      stringr::str_split_fixed(readLines(\"input.txt\"), pattern = \"\", n = 12)\n    dt <- data.frame(apply(dt, 2, as.integer))\n    \n    getModeMin <- function(x)\n      return(ifelse(mean(x) > .5, 0, 1))\n    getModeMax <- function(x)\n      return(ifelse(mean(x) > .5, 1, 0))\n    \n    strtoi(paste(apply(dt, 2, getModeMax), collapse = \"\"), base = 2) *\n      strtoi(paste(apply(dt, 2, getModeMin), collapse = \"\"), base = 2)\n    \n    # part 2\n    dto <- dt\n    dtc <- dt\n    \n    for (i in 1:12) {\n      if (nrow(dto) > 1)\n        dto <- dto |>\n          filter_at(i, all_vars(. == ifelse(mean(dto[, i]) >= .5, 1, 0)))\n      if (nrow(dtc) > 1)\n        dtc <- dtc |>\n          filter_at(i, all_vars(. == ifelse(mean(dtc[, i]) < .5, 1, 0)))\n    }\n    \n    strtoi(paste(as.character(dto[1, ]), collapse = \"\"), base = 2) *\n      strtoi(paste(as.character(dtc[1, ]), collapse = \"\"), base = 2)\n  }, \n  replications = 100, columns = c(1:5), order = \"user.self\")\n\n        test replications user.self sys.self elapsed\n2 Second try          100    16.956    0.346  17.304\n1  First try          100    17.130    0.360  17.492\n3  Third try          100    20.403    0.318  20.740"
  },
  {
    "objectID": "2021/04/2021-04.html#part-1",
    "href": "2021/04/2021-04.html#part-1",
    "title": "2021-04: Giant Squid",
    "section": "Part 1",
    "text": "Part 1\n\n# part 1\ndt <- data.frame(fread(\"input2.txt\"))\ncall <- c(84,28,29,75,58,71,26,6,73,74,41,39,87,37,16,79,55,60,62,80,64,95,46,15,5,47,2,35,32,78,89,90,96,33,4,69,42,30,54,85,65,83,44,63,20,17,66,81,67,77,36,68,82,93,10,25,9,34,24,72,91,88,11,38,3,45,14,56,22,61,97,27,12,48,18,1,31,98,86,19,99,92,8,43,52,23,21,0,7,50,57,70,49,13,51,40,76,94,53,59)\nbingo <- FALSE\n\nfor(i in 1:length(call)) {\n  dt$V1[dt$V1 == call[i]] <- NA\n  dt$V2[dt$V2 == call[i]] <- NA\n  dt$V3[dt$V3 == call[i]] <- NA\n  dt$V4[dt$V4 == call[i]] <- NA\n  dt$V5[dt$V5 == call[i]] <- NA\n  \n  for(R in seq(1, nrow(dt), 5)) {\n    for(r in R:(R+4)) {\n      if(sum(is.na(dt[r,])) == 5) {\n        bingo <- TRUE\n        break\n      }\n    }\n    for(c in 1:5) {\n      if(sum(is.na(dt[R:(R+4),c])) == 5) {\n        bingo <- TRUE\n        break\n      }\n    }\n    if(bingo)\n      break\n  }\n  if(bingo)\n    break\n}\nsum(dt[R:(R+4),], na.rm = TRUE) * call[i]\n\n[1] 29440"
  },
  {
    "objectID": "2021/04/2021-04.html#part-2",
    "href": "2021/04/2021-04.html#part-2",
    "title": "2021-04: Giant Squid",
    "section": "Part 2",
    "text": "Part 2\n\n# part 2\ndt <- data.frame(fread(\"input2.txt\"))\ncall <- c(84,28,29,75,58,71,26,6,73,74,41,39,87,37,16,79,55,60,62,80,64,95,46,15,5,47,2,35,32,78,89,90,96,33,4,69,42,30,54,85,65,83,44,63,20,17,66,81,67,77,36,68,82,93,10,25,9,34,24,72,91,88,11,38,3,45,14,56,22,61,97,27,12,48,18,1,31,98,86,19,99,92,8,43,52,23,21,0,7,50,57,70,49,13,51,40,76,94,53,59)\nbingo <- 0\nbingoTF <- FALSE\nboards <- nrow(dt) / 5\n\nfor(i in 1:length(call)) {\n  dt$V1[dt$V1 == call[i]] <- NA\n  dt$V2[dt$V2 == call[i]] <- NA\n  dt$V3[dt$V3 == call[i]] <- NA\n  dt$V4[dt$V4 == call[i]] <- NA\n  dt$V5[dt$V5 == call[i]] <- NA\n  \n  for (R in seq(1, nrow(dt), 5)) {\n    if (sum(is.na(dt[R:(R + 4), 1:5])) != 25) {\n      for (r in R:(R + 4)) {\n        if (sum(is.na(dt[r, ])) == 5) {\n          dt[r, ] <- NA\n          bingo <- append(bingo, i)\n          bingoTF <- TRUE\n          break\n        }\n      }\n      for (c in 1:5) {\n        if (sum(is.na(dt[R:(R + 4), c])) == 5) {\n          dt[R:(R + 4), c] <- NA\n          bingo <- append(bingo, i)\n          bingoTF <- TRUE\n          break\n        }\n      }\n      \n      if (bingoTF) {\n        dt[R:(R + 4),] <- NA\n        bingo <- append(bingo, i)\n        bingoTF <- FALSE\n      }\n    }\n  }\n}\n\ndt <- data.frame(fread(\"input2.txt\"))\nbingoTF <- FALSE\n\nfor(i in 1:(bingo[length(bingo)]-1)) {\n  dt$V1[dt$V1 == call[i]] <- NA\n  dt$V2[dt$V2 == call[i]] <- NA\n  dt$V3[dt$V3 == call[i]] <- NA\n  dt$V4[dt$V4 == call[i]] <- NA\n  dt$V5[dt$V5 == call[i]] <- NA\n  \n  for (R in seq(1, nrow(dt), 5)) {\n    if (sum(is.na(dt[R:(R + 4), 1:5])) != 25) {\n      for (r in R:(R + 4)) {\n        if (sum(is.na(dt[r, ])) == 5) {\n          dt[r, ] <- NA\n          bingoTF <- TRUE\n          break\n        }\n      }\n      for (c in 1:5) {\n        if (sum(is.na(dt[R:(R + 4), c])) == 5) {\n          dt[R:(R + 4), c] <- NA\n          bingoTF <- TRUE\n          break\n        }\n      }\n      \n      if (bingoTF) {\n        dt[R:(R + 4),] <- NA\n        bingoTF <- FALSE\n      }\n    }\n  }\n}\n\ndt <- tail(dt[rowSums(dt, na.rm = TRUE) != 0,], 5)\ni <- i + 1\ndt$V1[dt$V1 == call[i]] <- NA\ndt$V2[dt$V2 == call[i]] <- NA\ndt$V3[dt$V3 == call[i]] <- NA\ndt$V4[dt$V4 == call[i]] <- NA\ndt$V5[dt$V5 == call[i]] <- NA\nsum(dt, na.rm = TRUE) * call[i]\n\n[1] 13884"
  },
  {
    "objectID": "2021/05/2021-05.html#part-1",
    "href": "2021/05/2021-05.html#part-1",
    "title": "2021-05: Hydrothermal Venture",
    "section": "Part 1",
    "text": "Part 1\n\n# part 1\ndt <- data.frame(fread(\"input.txt\"))\ndt <- data.table(\"x1\" = dt[, \"V1\"] + 1,\n                 \"y1\" = as.numeric(str_split(dt$V2, \" -> \", \n                                             simplify = TRUE)[,1]) + 1,\n                 \"x2\" = as.numeric(str_split(dt$V2, \" -> \", \n                                             simplify = TRUE)[,2]) + 1,\n                 \"y2\" = dt[, \"V3\"] + 1)[x1 == x2 | y1 == y2,]\nmx <- data.frame(matrix(data = 0, nrow = max(dt), ncol = max(dt)))\n\nfor(r in 1:nrow(dt)) {\n  mx[dt$x1[r]:dt$x2[r], dt$y1[r]:dt$y2[r]] <- \n    mx[dt$x1[r]:dt$x2[r], dt$y1[r]:dt$y2[r]] + 1\n}\n\nlength(mx[mx > 1])\n\n[1] 4728"
  },
  {
    "objectID": "2021/05/2021-05.html#part-2",
    "href": "2021/05/2021-05.html#part-2",
    "title": "2021-05: Hydrothermal Venture",
    "section": "Part 2",
    "text": "Part 2\n\n# part 2\ndt <- data.frame(fread(\"input.txt\"))\ndt <- data.table(\"x1\" = dt[, \"V1\"] + 1,\n                 \"y1\" = as.numeric(str_split(dt$V2, \" -> \", \n                                             simplify = TRUE)[,1]) + 1,\n                 \"x2\" = as.numeric(str_split(dt$V2, \" -> \", \n                                             simplify = TRUE)[,2]) + 1,\n                 \"y2\" = dt[, \"V3\"] + 1) %>%\n  .[, at :=  (x1 == y2 & x2 == y1) |\n             (x1 == y1 & x2 == y2) | \n             (abs(x2 - x1) == abs(y2 - y1))] \nmx <- matrix(data = 0, nrow = max(dt), ncol = max(dt))\n\nfor(r in 1:nrow(dt)) {\n  ifelse(dt$at[r],\n    diag(mx[dt$x1[r]:dt$x2[r], dt$y1[r]:dt$y2[r]]) <- \n      diag(mx[dt$x1[r]:dt$x2[r], dt$y1[r]:dt$y2[r]]) + 1,\n    mx[dt$x1[r]:dt$x2[r], dt$y1[r]:dt$y2[r]] <- \n      mx[dt$x1[r]:dt$x2[r], dt$y1[r]:dt$y2[r]] + 1)\n}\n\nlength(mx[mx > 1])\n\n[1] 17717"
  },
  {
    "objectID": "2021/06/2021-06.html#part-1",
    "href": "2021/06/2021-06.html#part-1",
    "title": "2021-06: Lanternfish",
    "section": "Part 1",
    "text": "Part 1\n\ndt2 <- as.numeric(data.table::fread(\"input.txt\", header = FALSE)[1])\n\nt <- table(dt2)\nv <- c(0, 0, t, rep(0, 8 - length(t)))\n\nfor(i in 1:80)\n  v <- c(v[2:7], v[8] + v[1], v[9:10], v[2])\nsum(v)\n\n[1] 363101"
  },
  {
    "objectID": "2021/06/2021-06.html#part-2",
    "href": "2021/06/2021-06.html#part-2",
    "title": "2021-06: Lanternfish",
    "section": "Part 2",
    "text": "Part 2\n\ndt2 <- as.numeric(data.table::fread(\"input.txt\", header = FALSE)[1])\n\nt <- table(dt2)\nv <- c(0, 0, t, rep(0, 8 - length(t)))\n\nfor(i in 1:256)\n  v <- c(v[2:7], v[8] + v[1], v[9:10], v[2])\noptions(scipen=999)\nsum(v)\n\n[1] 1644286074024"
  },
  {
    "objectID": "2021/06/2021-06.html#speed-edition",
    "href": "2021/06/2021-06.html#speed-edition",
    "title": "2021-06: Lanternfish",
    "section": "Speed Edition",
    "text": "Speed Edition\n\nThis was a classic Advent Of Code misdirection. Once I figured it out, my solution was quick to write and execute.\n\n\nFastest solution\n\n# part 1 and 2\ndt2 <- c(1,3,3,4,5,1,1,1,1,1,1,2,1,4,1,1,1,5,2,2,4,3,1,1,2,5,4,2,2,3,1,2,3,2,1,\n         1,4,4,2,4,4,1,2,4,3,3,3,1,1,3,4,5,2,5,1,2,5,1,1,1,3,2,3,3,1,4,1,1,4,1,\n         4,1,1,1,1,5,4,2,1,2,2,5,5,1,1,1,1,2,1,1,1,1,3,2,3,1,4,3,1,1,3,1,1,1,1,\n         3,3,4,5,1,1,5,4,4,4,4,2,5,1,1,2,5,1,3,4,4,1,4,1,5,5,2,4,5,1,1,3,1,3,1,\n         4,1,3,1,2,2,1,5,1,5,1,3,1,3,1,4,1,4,5,1,4,5,1,1,5,2,2,4,5,1,3,2,4,2,1,\n         1,1,2,1,2,1,3,4,4,2,2,4,2,1,4,1,3,1,3,5,3,1,1,2,2,1,5,2,1,1,1,1,1,5,4,\n         3,5,3,3,1,5,5,4,4,2,1,1,1,2,5,3,3,2,1,1,1,5,5,3,1,4,4,2,4,2,1,1,1,5,1,\n         2,4,1,3,4,4,2,1,4,2,1,3,4,3,3,2,3,1,5,3,1,1,5,1,2,2,4,4,1,2,3,1,2,1,1,\n         2,1,1,1,2,3,5,5,1,2,3,1,3,5,4,2,1,3,3,4)\n\nfishTable <- c(0, 0, table(dt2), rep(0, 8 - max(dt2)))\n\nfish <- function(v, d) {\n  if (d == 0) {\n    return(sum(v, digits = 999))\n  } else if (d == 176) {\n    print(sum(v))\n  }\n  fish(c(v[2:7], v[8] + v[1], v[9:10], v[2]), d - 1)\n}\nfish(fishTable, 256)\n\n[1] 363101\n\n\n[1] 1644286075023\n\n\n\n\nBenchmark\n\nbench <- rbenchmark::benchmark(\n  \"First try\" = {\n    # part 1\n    dt <- as.numeric(unlist(stringr::str_split(readLines(\"input.txt\"), \",\")))\n    dt2 <- dt\n    for(d in 1:80) {\n      dt2 <- dt2 - 1\n      if(sum(dt2 == -1) > 0) {\n        dt2 <- append(dt2, rep(8, sum(dt2 == -1)))\n        dt2[dt2 == -1] <- 6\n        }\n      }\n    s <- length(dt2)\n\n    # part 2\n    dt <- as.numeric(unlist(stringr::str_split(readLines(\"input2.txt\"), \",\")))\n    dt2 <- dt\n\n    dt <- data.frame(\"m\" = 0, \"zero\" = 0, \"one\" = 0, \"two\" = 0,\n                     \"three\" = 0, \"four\" = 0, \"five\" = 0, \"six\" = 0,\n                     \"seven\" = 0, \"eight\" = 0)\n\n    for(i in 1:length(dt2)) {\n      if(dt2[i] == 0) {dt$zero[1] <- dt$zero[1] + 1}\n      if(dt2[i] == 1) {dt$one[1] <- dt$one[1] + 1}\n      if(dt2[i] == 2) {dt$two[1] <- dt$two[1] + 1}\n      if(dt2[i] == 3) {dt$three[1] <- dt$three[1] + 1}\n      if(dt2[i] == 4) {dt$four[1] <- dt$four[1] + 1}\n      if(dt2[i] == 5) {dt$five[1] <- dt$five[1] + 1}\n      if(dt2[i] == 6) {dt$six[1] <- dt$six[1] + 1}\n      if(dt2[i] == 7) {dt$seven[1] <- dt$seven[1] + 1}\n      if(dt2[i] == 8) {dt$eight[1] <- dt$eight[1] + 1}\n    }\n\n    for (i in 1:255) {\n      dt$zero[1] <- dt$one[1]\n      dt$one[1] <- dt$two[1]\n      dt$two[1] <- dt$three[1]\n      dt$three[1] <- dt$four[1]\n      dt$four[1] <- dt$five[1]\n      dt$five[1] <- dt$six[1]\n      dt$six[1] <- dt$seven[1] + dt$m[1]\n      dt$seven[1] <- dt$eight[1]\n\n      dt$eight[1] <- dt$m[1]\n      dt$m[1] <- dt$zero[1]\n    }\n\n    options(scipen = 999)\n    s <- sum(dt[1, ])\n    },\n  \"Third try\" = {\n      # part 1 and 2\n      dt2 <- as.numeric(data.table::fread(\"input.txt\", header = FALSE)[1])\n\n      t <- table(dt2)\n      v <- c(0, 0, t, rep(0, 8 - length(t)))\n\n      for (i in 1:256) {\n        v <- c(v[2:7], v[8] + v[1], v[9:10], v[2])\n        if(i == 80)\n          s <- sum(v)\n      }\n      options(scipen = 999)\n      s <- sum(v)\n    },\n  \"With recursion!\" = {\n    # part 1 and 2\n    dt2 <- c(1,3,3,4,5,1,1,1,1,1,1,2,1,4,1,1,1,5,2,2,4,3,1,1,2,5,4,2,2,3,1,2,3,\n             2,1,1,4,4,2,4,4,1,2,4,3,3,3,1,1,3,4,5,2,5,1,2,5,1,1,1,3,2,3,3,1,4,\n             1,1,4,1,4,1,1,1,1,5,4,2,1,2,2,5,5,1,1,1,1,2,1,1,1,1,3,2,3,1,4,3,1,\n             1,3,1,1,1,1,3,3,4,5,1,1,5,4,4,4,4,2,5,1,1,2,5,1,3,4,4,1,4,1,5,5,2,\n             4,5,1,1,3,1,3,1,4,1,3,1,2,2,1,5,1,5,1,3,1,3,1,4,1,4,5,1,4,5,1,1,5,\n             2,2,4,5,1,3,2,4,2,1,1,1,2,1,2,1,3,4,4,2,2,4,2,1,4,1,3,1,3,5,3,1,1,\n             2,2,1,5,2,1,1,1,1,1,5,4,3,5,3,3,1,5,5,4,4,2,1,1,1,2,5,3,3,2,1,1,1,\n             5,5,3,1,4,4,2,4,2,1,1,1,5,1,2,4,1,3,4,4,2,1,4,2,1,3,4,3,3,2,3,1,5,\n             3,1,1,5,1,2,2,4,4,1,2,3,1,2,1,1,2,1,1,1,2,3,5,5,1,2,3,1,3,5,4,2,1,\n             3,3,4)\n\n    fishTable <- c(0, 0, table(dt2), rep(0, 8 - max(dt2)))\n    \n    fish <- function(v, d) {\n      if (d == 0) {\n        return(sum(v, digits = 999))\n      } else if (d == 176) {\n        s <- sum(v)\n      }\n      fish(c(v[2:7], v[8] + v[1], v[9:10], v[2]), d - 1)\n    }\n    s <- fish(fishTable, 256)\n  }, \n  replications = 100, columns = c(1:5), order = \"user.self\")\n\nbench$per <- bench$user.self / bench$replications\nbench\n\n             test replications user.self sys.self elapsed     per\n3 With recursion!          100     0.079    0.001   0.079 0.00079\n2       Third try          100     0.437    0.012   0.450 0.00437\n1       First try          100     7.977    1.149   9.155 0.07977"
  },
  {
    "objectID": "2021/07/2021-07.html#part-1",
    "href": "2021/07/2021-07.html#part-1",
    "title": "2021-07: The Treachery of Whales",
    "section": "Part 1",
    "text": "Part 1\n\ndt2 <- data.table(\"start\" = dt)\ns <- c()\nfor(i in -max(dt):max(dt)) {\n  dt2 <- data.table(\"start\" = dt)\n  dt2[, mean := floor(mean(start))][, diff := abs(start - mean + i)]\n  s <- append(s, sum(dt2$diff))\n}\nmin(s)\n\n[1] 342730"
  },
  {
    "objectID": "2021/07/2021-07.html#part-2",
    "href": "2021/07/2021-07.html#part-2",
    "title": "2021-07: The Treachery of Whales",
    "section": "Part 2",
    "text": "Part 2\n\ndt2 <- data.table(\"start\" = dt)\ns <- c()\n\nfor(i in -max(dt):max(dt)) {\n  dt2 <- data.table(\"start\" = dt)\n  dt2[, mean := floor(mean(start))]\n  for(r in 1:nrow(dt2))\n    dt2$diff[r] <- sum(1:(abs(dt2$start[r] - dt2$mean[r] - i)))\n  s <- append(s, sum(dt2$diff))\n}\nmin(s)\n\n[1] 92335207"
  },
  {
    "objectID": "2021/07/2021-07.html#speed-edition",
    "href": "2021/07/2021-07.html#speed-edition",
    "title": "2021-07: The Treachery of Whales",
    "section": "Speed Edition",
    "text": "Speed Edition\nPlease don’t look at this. It’s embarrassing.\nI only did one rep because my first try is too slow.\n\nFastest solution\n\nlibrary(stringr)\nlibrary(tidyverse)\nlibrary(data.table)\n\n\ndt <- as.numeric(data.table::fread(\"input.txt\", header = FALSE)[1])\n# part 1\ns <- max(dt) ^ length(dt)\nfor (i in-ceiling(max(dt) / 2):ceiling(max(dt) / 2)) {\n  dt2 <-\n    data.table(\"start\" = dt)[, mean := floor(mean(start))][, diff := abs(start - mean - i)]\n  dtDiff <- sum(dt2$diff)\n  s <- data.table::fifelse(dtDiff < s, dtDiff, s)\n}\ns <- c(s)\n\n# part 2\ncSum <- function(y) {\n  eval(parse(text = y))\n}\ndt2 <- data.table(\"start\" = dt)\ndt2[, mean := mean(dt2$start, na.rm = TRUE)]\ndt2$abs <- abs(dt2$start - dt2$mean)\ndt2$meanC <- ceiling(dt2$mean)\ndt2$meanF <- floor(dt2$mean)\ndt2$absC <- abs(dt2$start - dt2$meanC)\ndt2$absF <- abs(dt2$start - dt2$meanF)\ndt2$diffC <- sapply(paste0(\"sum(1:\", dt2$absC, \")\"), cSum)\ndt2$diffF <- sapply(paste0(\"sum(1:\", dt2$absF, \")\"), cSum)\ns <- min(sum(dt2$diffC), sum(dt2$diffF))\n\n\n\nBenchmark\n\nbench <- rbenchmark::benchmark(\n  \"first\" = {\n    library(stringr)\n    library(tidyverse)\n    library(data.table)\n    dt <-\n      as.numeric(data.table::fread(\"input.txt\", header = FALSE)[1])\n    # part 1\n    dt2 <- data.table(\"start\" = dt)\n    s <- c()\n    for (i in-max(dt):max(dt)) {\n      dt2 <- data.table(\"start\" = dt)\n      dt2[, mean := floor(mean(start))][, diff := abs(start - mean + i)]\n      s <- append(s, sum(dt2$diff))\n    }\n    s <- min(s)\n    \n    # part 2\n    dt2 <- data.table(\"start\" = dt)\n    s <- c()\n    \n    for (i in-max(dt):max(dt)) {\n      dt2 <- data.table(\"start\" = dt)\n      dt2[, mean := floor(mean(start))]\n      for (r in 1:nrow(dt2))\n        dt2$diff[r] <- sum(1:(abs(dt2$start[r] - dt2$mean[r] - i)))\n      s <- append(s, sum(dt2$diff))\n    }\n    s <- min(s)\n  },\n  \"second\" = {\n    library(stringr)\n    library(tidyverse)\n    library(data.table)\n    dt <-\n      as.numeric(data.table::fread(\"input.txt\", header = FALSE)[1])\n    # part 1\n    s <- max(dt) ^ length(dt)\n    for (i in-ceiling(max(dt) / 2):ceiling(max(dt) / 2)) {\n      dt2 <-\n        data.table(\"start\" = dt)[, mean := floor(mean(start))][, diff := abs(start - mean - i)]\n      dtDiff <- sum(dt2$diff)\n      s <- data.table::fifelse(dtDiff < s, dtDiff, s)\n    }\n    s <- c(s)\n    \n    cSum <- function(y) {\n      eval(parse(text = y))\n    }\n    dt2 <- data.table(\"start\" = dt)\n    dt2[, mean := mean(dt2$start, na.rm = TRUE)]\n    dt2$abs <- abs(dt2$start - dt2$mean)\n    dt2$meanC <- ceiling(dt2$mean)\n    dt2$meanF <- floor(dt2$mean)\n    dt2$absC <- abs(dt2$start - dt2$meanC)\n    dt2$absF <- abs(dt2$start - dt2$meanF)\n    dt2$diffC <- sapply(paste0(\"sum(1:\", dt2$absC, \")\"), cSum)\n    dt2$diffF <- sapply(paste0(\"sum(1:\", dt2$absF, \")\"), cSum)\n    min(sum(dt2$diffC), sum(dt2$diffF))\n  },\n  replications = 1,\n  columns = 1:5,\n  order = \"user.self\"\n)\n\nbench$per <- bench$user.self / bench$replications\nbench\n\n    test replications user.self sys.self elapsed     per\n2 second            1     0.863    0.005   0.870   0.863\n1  first            1   125.937   11.166 138.154 125.937"
  },
  {
    "objectID": "2021/08/2021-08.html#part-1",
    "href": "2021/08/2021-08.html#part-1",
    "title": "2021-08: Seven Segment Search",
    "section": "Part 1",
    "text": "Part 1\n\ndt2 <- data.table(\"output\" = dt$V2)\ndt2 <- as.character(unlist(strsplit(dt2$output, \" \")))\nlength(dt2[nchar(dt2) %in% c(2, 3, 4, 7)])\n\n[1] 392\n\n\n\nThis is how I laid out my positions"
  },
  {
    "objectID": "2021/08/2021-08.html#part-2",
    "href": "2021/08/2021-08.html#part-2",
    "title": "2021-08: Seven Segment Search",
    "section": "Part 2",
    "text": "Part 2\n\ndf <- data.table::fread(\"input.txt\", header = FALSE)\ndt1 <- data.table(\"input\" = df$V1)\ndt1 <- data.table(str_split(dt1$input, \" \", simplify = TRUE))\ndt2 <- data.table(\"output\" = df$V2)\ndt2 <- data.table(str_split(dt2$output, \" \", simplify = TRUE))\ndf <- cbind(dt1, dt2)\n\nsortV <- function(x) {\n  sapply(lapply(strsplit(x, NULL), sort), paste, collapse=\"\")\n}\n\ngetNumber <- function(x1) {\n  display <- c(\"p1\" = \"\",\n               \"p2\" = \"\",\n               \"p3\" = \"\",\n               \"p4\" = \"\",\n               \"p5\" = \"\",\n               \"p6\" = \"\",\n               \"p7\" = \"\")\n  x <- as.character(x1[1:10])\n  one <- \"\"\n  four <- \"\"\n  seven <- \"\"\n  eight <- \"\"\n  \n  for (i in 1:10) {\n    if (nchar(x[i]) == 2) one <- x[i]\n    if (nchar(x[i]) == 3) seven <- x[i]\n    if (nchar(x[i]) == 4) four <- x[i]\n    if (nchar(x[i]) == 7) eight <- x[i]\n  }\n  \n  # determine p1\n  display[\"p1\"] <- str_split(seven, \"\", simplify = TRUE)[\n    !(str_split(seven, \"\", simplify = TRUE) %in% \n        str_split(one, \"\", simplify = TRUE))]\n  \n  # determine p57\n  p57 <- paste0(seven, four, collapse = \"\")\n  p57 <- str_split(p57, \"\", simplify = TRUE)\n  p27 <- as.character(unlist(str_split(x[nchar(x) == 5], \"\")))\n  p27 <- p27[!(p27 %in% p57)]\n  display[\"p5\"] <- names(sort(table(p27)))[1]\n  display[\"p7\"] <- names(sort(table(p27)))[2]\n  \n  # determine p36\n  p24 <- str_split(eight, \"\", simplify = TRUE)[\n    !(str_split(eight, \"\", simplify = TRUE) %in% \n        str_split(one, \"\", simplify = TRUE))]\n  p24 <- p24[!(p24 %in% display)]\n  p <- as.character(unlist(str_split(x[nchar(x) == 6], \"\")))\n  p <- p[!(p %in% p24)]\n  p <- sort(table(p))\n  p36 <- p[(names(p) %in% str_split(one, \"\", simplify = TRUE))]\n  display[\"p3\"] <- names(p36)[1]\n  display[\"p6\"] <- names(p36)[2]\n  \n  # determine p24\n  p24 <- unlist(str_split(x[nchar(x) == 5], \"\"))\n  p24 <- sort(table(p24[!(p24 %in% display)]))\n  display[\"p2\"] <- names(p24)[1]\n  display[\"p4\"] <- names(p24)[2]\n  display\n  \n  zero <- paste0(sort(display[c(1:3,5:7)]), collapse = \"\")\n  one <- paste0(sort(display[c(3,6)]), collapse = \"\")\n  two <- paste0(sort(display[c(1,3,4:5,7)]), collapse = \"\")\n  three <- paste0(sort(display[c(1,3:4,6:7)]), collapse = \"\")\n  four <- paste0(sort(display[c(2:4,6)]), collapse = \"\")\n  five <- paste0(sort(display[c(1:2,4,6:7)]), collapse = \"\")\n  six <- paste0(sort(display[c(1:2,4:7)]), collapse = \"\")\n  seven <- paste0(sort(display[c(1,3,6)]), collapse = \"\")\n  eight <- paste0(sort(display[c(1:7)]), collapse = \"\")\n  nine <- paste0(sort(display[c(1:4,6:7)]), collapse = \"\")\n  \n  x <- as.character(x1[11:14])\n  x <- sapply(x, sortV)\n  \n  returnNumber <- function(x) {\n    return(case_when(\n      x == zero ~ 0,\n      x == one ~ 1,\n      x == two ~ 2,\n      x == three ~ 3,\n      x == four ~ 4,\n      x == five ~ 5,\n      x == six ~ 6,\n      x == seven ~ 7,\n      x == eight ~ 8,\n      x == nine ~ 9\n    ))\n  }\n  \n  x <- paste0(sapply(x, returnNumber), collapse = \"\")\n  return(as.numeric(x))\n}\n\nsum(apply(df, 1, getNumber))\n\n[1] 1004688"
  },
  {
    "objectID": "2021/09/2021-09.html#part-1",
    "href": "2021/09/2021-09.html#part-1",
    "title": "2021-09: Smoke Basin",
    "section": "Part 1",
    "text": "Part 1\n\ndt2 <- dt\n\ncoordX <- c()\ncoordY <- c()\nrLow <- c()\nfor(r in 2:(nrow(dt2) - 1)) {\n  for(c in 2:(ncol(dt2) - 1)) {\n    if(dt2[r,c] == min(dt[(r-1):(r+1),(c-1):(c+1)])) {\n      rLow <- append(rLow, dt2[r,c])\n      coordX <- append(coordX, c)\n      coordY <- append(coordY, r)\n    }\n  }\n}\n\ns <- 0\nfor(n in 1:length(rLow)) {\n  s <- s + (rLow[n] + 1)\n}\ns\n\n[1] 575"
  },
  {
    "objectID": "2021/09/2021-09.html#part-2",
    "href": "2021/09/2021-09.html#part-2",
    "title": "2021-09: Smoke Basin",
    "section": "Part 2",
    "text": "Part 2\n\ndt2 <- dt\ndt2[dt2 == 9 | dt2 == 10] <- NA\n\ncoordX <- c()\ncoordY <- c()\nrLow <- c()\nfor(r in 2:(nrow(dt2) - 1)) {\n  for(c in 2:(ncol(dt2) - 1)) {\n    if(!is.na(dt2[r,c])) {\n      rLow <- append(rLow, dt2[r,c])\n      coordX <- append(coordX, c)\n      coordY <- append(coordY, r)\n    }\n  }\n}\n\ndt3 <- data.frame(\"x\" = coordX, \"y\" = coordY, \"d\" = rLow)\ndt3 <- dt3[dt3$d <= 8,]\ndb <- dbscan(dt3[,1:2], eps = 1, minPts = 0)\ndt3$cluster <- db$cluster\ndt <- dt3 %>%\n  group_by(cluster) %>%\n  count() %>%\n  filter(cluster != 0) %>%\n  arrange(desc(n)) %>%\n  head(3)\nprod(dt$n)\n\n[1] 1019700\n\ndt3$cluster <- ifelse(dt3$cluster %in% dt$cluster, dt3$cluster, 0)\ndt3 %>%\n  mutate(cluster = as.factor(cluster)) %>%\n  ggplot() +\n  geom_point(aes(x = x, y = y, color = cluster))\n\n\n\nggsave(\"cluster.png\")\n\nSaving 7 x 5 in image"
  },
  {
    "objectID": "2021/10/2021-10.html#part-1",
    "href": "2021/10/2021-10.html#part-1",
    "title": "2021-10: Syntax Scoring",
    "section": "Part 1",
    "text": "Part 1\n\ndt2 <- dt\n\nmonkeyBall <- function(x, n) {\n  x <- str_replace_all(x, \"\\\\(\\\\)|\\\\[\\\\]|\\\\{\\\\}|\\\\<\\\\>\", \"\")\n  if(nchar(x) == n) {\n    t <- as.character(str_split(str_replace_all(x, \"[\\\\(\\\\[\\\\{\\\\<]\", \"\"),\n                   \"\",\n                   simplify = TRUE)[1,])\n    t <- t[1]\n    return(t)\n  }\n  return(monkeyBall(x, nchar(x)))\n}\n\nt <- c()\nfor(r in 1:nrow(dt2)) {\n  x <- dt2[r,1]\n  n <- nchar(x)\n  t <- append(t, monkeyBall(x, n))\n}\nt <- table(t)\nif (is.na(t[\")\"]))\n  t[\")\"] <- 0\nif (is.na(t[\"]\"]))\n  t[\"]\"] <- 0\nif (is.na(t[\"}\"]))\n  t[\"}\"] <- 0\nif (is.na(t[\">\"]))\n  t[\">\"] <- 0\n(3 * t[\")\"]) + (57 * t[\"]\"]) + (1197 * t[\"}\"]) + (25137 * t[\">\"])\n\n     ) \n311949"
  },
  {
    "objectID": "2021/10/2021-10.html#part-2",
    "href": "2021/10/2021-10.html#part-2",
    "title": "2021-10: Syntax Scoring",
    "section": "Part 2",
    "text": "Part 2\n\ndt2 <- dt\n\nmonkeyBall <- function(x, n) {\n  x <- str_replace_all(x, \"\\\\(\\\\)|\\\\[\\\\]|\\\\{\\\\}|\\\\<\\\\>\", \"\")\n  if(nchar(x) == n) {\n    if(!grepl(\"\\\\)|\\\\]|\\\\}|\\\\>\", x, perl = TRUE))\n      return(x)\n    return(\"\")\n  }\n  return(monkeyBall(x, nchar(x)))\n}\n\nt <- c()\nfor(r in 1:nrow(dt2)) {\n  x <- dt2[r,1]\n  n <- nchar(x)\n  t <- append(t, monkeyBall(x, n))\n}\nt <- t[nchar(t) > 0]\ns <- c()\nfor(i in t) {\n  miniS <- 0\n  miniT <- rev(str_split(i, \"\", simplify = TRUE)[1,])\n  for(l in miniT) {\n    miniS <- (5 * miniS) + case_when(l == \"(\" ~ 1,\n                                     l == \"[\" ~ 2,\n                                     l == \"{\" ~ 3,\n                                     l == \"<\" ~ 4)\n  }\n  s <- append(s, miniS)\n}\ns <- s[!is.na(s)]\nmedian(s)\n\n[1] 3042730309"
  },
  {
    "objectID": "2021/11/2021-11.html#part-1",
    "href": "2021/11/2021-11.html#part-1",
    "title": "2021-11: Dumbo Octopus",
    "section": "Part 1",
    "text": "Part 1\n\noctopus <- octopusM |>\n  strsplit(\"\") %>%\n  do.call(rbind, .) |>\n  as.matrix() |>\n  apply(1, as.numeric) |>\n  t()\n\noctopusCol <- ncol(octopus)\noctopusRow <- nrow(octopus)\n\nflash_counter <- 0\n\nget_adjacent <- function(xx, yy, ncol, nrow) {\n  x <- xx; y <- yy\n  x <- (x-1):(x+1); y <- (y-1):(y+1)\n  \n  x <- x[sapply(x, \\(j) between(j, 1, ncol))]\n  y <- y[sapply(y, \\(j) between(j, 1, nrow))]\n\n  expand.grid(\"col\" = x, \"row\" = y) |>\n    filter(!(col == xx & row == yy)) |>\n    as.matrix()\n}\n\nfor(i in 1:100) {\n  octopus <- octopus + 1\n  \n  while(any(octopus > 9)) {\n    flash <- which(octopus > 9, arr.ind = TRUE)\n    octopus[octopus > 9] <- 0\n    for(x in 1:nrow(flash)) {\n      adj <- \n        get_adjacent(flash[x, \"col\"], flash[x, \"row\"], octopusCol, octopusRow)\n      \n      octopus[adj[,\"row\"], adj[,\"col\"]] <- \n        apply(octopus[adj[,\"row\"], adj[,\"col\"]], c(1, 2), \n              \\(x) { ifelse(x == 0, 0, x + 1) })\n    }\n  }\n  flash_counter <<- flash_counter + length(octopus[octopus == 0])\n}\nflash_counter\n\n[1] 1603"
  },
  {
    "objectID": "2021/11/2021-11.html#part-2",
    "href": "2021/11/2021-11.html#part-2",
    "title": "2021-11: Dumbo Octopus",
    "section": "Part 2",
    "text": "Part 2\n\noctopus <- octopusM |>\n  strsplit(\"\") %>%\n  do.call(rbind, .) |>\n  as.matrix() |>\n  apply(1, as.numeric) |>\n  t()\n\ni <- 1\n\nwhile(TRUE) {\n  octopus <- octopus + 1\n  \n  while(any(octopus > 9)) {\n    flash <- which(octopus > 9, arr.ind = TRUE)\n    octopus[octopus > 9] <- 0\n    for(x in 1:nrow(flash)) {\n      adj <- \n        get_adjacent(flash[x, \"col\"], flash[x, \"row\"], octopusCol, octopusRow)\n      \n      octopus[adj[,\"row\"], adj[,\"col\"]] <- \n        apply(octopus[adj[,\"row\"], adj[,\"col\"]], c(1, 2), \n              \\(x) { ifelse(x == 0, 0, x + 1) })\n    }\n  }\n  if (length(octopus[octopus == 0]) == octopusRow * octopusCol) {\n    print(i)\n    break\n  } else { i <- i + 1 }\n}\n\n[1] 222"
  },
  {
    "objectID": "2021/13/2021-13.html#part-1",
    "href": "2021/13/2021-13.html#part-1",
    "title": "2021-13: Transparent Origami",
    "section": "Part 1",
    "text": "Part 1\n\nfold <- function(dir, n, paper) {\n  if (dir == \"x\") {\n    paper1 <- paper[,1:(n)]\n    paper2 <- paper[,(n+2):ncol(paper)]\n    paper2 <- t(apply(paper2, 1, rev))\n  } else if (dir == \"y\") {\n    paper1 <- paper[1:(n),]\n    paper2 <- paper[(n+2):nrow(paper), ]\n    paper2 <- apply(paper2, 2, rev)\n  }\n\n  return(ifelse(paper1 | paper2, TRUE, FALSE))\n}\n\nfolded <- fold(folds$X1[1], folds$X2[1], paper)\nlength(which(folded))\n\n[1] 684"
  },
  {
    "objectID": "2021/13/2021-13.html#part-2",
    "href": "2021/13/2021-13.html#part-2",
    "title": "2021-13: Transparent Origami",
    "section": "Part 2",
    "text": "Part 2\n\nfold <- function(dir, n, paper) {\n  if (dir == \"x\") {\n    paper1 <- paper[,1:(n)]\n    paper2 <- paper[,(n+2):ncol(paper)]\n    paper2 <- t(apply(paper2, 1, rev))\n  } else if (dir == \"y\") {\n    paper1 <- paper[1:(n),]\n    paper2 <- paper[(n+2):nrow(paper), ]\n    paper2 <- apply(paper2, 2, rev)\n  }\n  \n  return(ifelse(paper1 | paper2, TRUE, FALSE))\n}\n\nfor(i in 1:nrow(folds)) {\n  paper <- fold(folds$X1[i], folds$X2[i], paper)\n  \n  coordX <- c()\n  coordY <- c()\n  for(r in 1:nrow(paper)) {\n    for(c in 1:ncol(paper)) {\n      if(paper[r,c]) {\n        coordX <- append(coordX, r)\n        coordY <- append(coordY, c)\n      }\n    }\n  }\n  \n  points <- data.frame(cbind(coordX, coordY)) %>%\n    ggplot() +\n    geom_point(aes(x = coordY, y = -coordX)) +\n    xlim(0, max(c(coordX, coordY))) +\n    ylim(-max(c(coordX, coordY)), 0)\n  if(i == nrow(folds))\n    print(points)\n}"
  },
  {
    "objectID": "2021/14/2021-14.html#part-1",
    "href": "2021/14/2021-14.html#part-1",
    "title": "2022-14: Extended Polymerization",
    "section": "Part 1",
    "text": "Part 1\n\ndt <- readLines(\"input.txt\")\npolymer <- dt[!grepl(\" -> \", dt)][1]\npolymer <- str_split(polymer, \"\", simplify = TRUE)[1,]\npairs <- data.frame(str_split(dt[grepl(\" -> \", dt)], \" -> \", simplify = TRUE))\n\nfor(d in 1:10) {\n  pos <- data.frame(\"let\" = NA, \"pos\" = NA)\n  for (i in 1:(length(polymer) - 1)) {\n    pos <- rbind(pos, data.frame(\"let\" =\n                                   pairs$X2[pairs$X1 == paste0(polymer[i:(i + 1)],\n                                                               collapse = \"\")],\n                                 \"pos\" = i))\n  }\n  pos <- pos[-1, ]\n  \n  for (r in 1:nrow(pos)) {\n    polymer <-\n      R.utils::insert(x = polymer,\n                      values = pos$let[r],\n                      ats = r + pos$pos[r])\n  }\n  # print((table(polymer)))\n}\nt <- sort(table(polymer), decreasing = TRUE)\nt[1] - rev(t)[1]\n\n   S \n3230"
  },
  {
    "objectID": "2021/14/2021-14.html#part-2",
    "href": "2021/14/2021-14.html#part-2",
    "title": "2022-14: Extended Polymerization",
    "section": "Part 2",
    "text": "Part 2\n\ndt <- readLines(\"input.txt\")\npolymer <- dt[!grepl(\" -> \", dt)][1]\npolymer <- str_split(polymer, \"\", simplify = TRUE)[1,]\npairs <- \n  data.frame(str_split(dt[grepl(\" -> \", dt)], \" -> \", simplify = TRUE))\n\ndt <-\n  data.frame(\"x\" = polymer[-length(polymer)], \"y\" = polymer[-1]) %>%\n  mutate(\"z\" = paste0(x, y, sep = \"\")) %>%\n  select(\"z\") %>%\n  group_by(z) %>%\n  count()\n  \ncounts <- unique(unlist(strsplit(pairs$X1, \"\")))\ncounts <- \n  rep(0, length(counts)) %>%\n  `names<-`(sort(unique(counts))) %>%\n  data.frame() %>%\n  rownames_to_column(var = \"value\") %>%\n  `colnames<-`(c(\"value\", \"n\")) %>%\n  rbind(table(polymer) |> data.frame() |> `colnames<-`(c(\"value\", \"n\"))) %>%\n  group_by(value) |>\n    summarise(n = sum(n)) |>\n    ungroup()\n\nbuild_poly <- function(dt, counts, i = 1) {\n  if (i == 40 + 1) { return(counts) }\n  dt <- dt %>%\n    right_join(pairs, by = c(\"z\" = \"X1\")) %>%\n    filter(!is.na(n))\n  \n  counts <-\n    dt %>%\n    group_by(X2) %>%\n      summarise(n = sum(n)) %>%\n    ungroup() %>%\n    `colnames<-`(c(\"value\", \"n\")) %>%\n    rbind(counts) %>%\n    group_by(value) %>%\n      summarise(n = sum(n)) %>%\n    ungroup() %>%\n    filter(!is.na(n))\n  \n  dt <- dt %>%\n    separate(\"z\", into = c(\"x\", \"y\"), sep = 1) %>%\n    mutate(x = paste(x, X2, sep = \"\"),\n           y = paste(X2, y, sep = \"\")) %>%\n    select(-X2) %>%\n    pivot_longer(cols = c(x, y)) %>%\n    select(-name) %>%\n    group_by(value) %>%\n      summarise(n = sum(n)) %>%\n    ungroup() %>%\n    rename(\"z\" = value)\n  \n  build_poly(dt, counts, i + 1)\n}\n\noptions(digits = 20)\n\ntab <- \n  build_poly(dt, counts) |>\n  deframe() |>\n  sort()\n\ntab[length(tab)] - tab[1]\n\n            S \n3542388214529"
  },
  {
    "objectID": "2020/01/2020-01.html#part-1",
    "href": "2020/01/2020-01.html#part-1",
    "title": "2020-01: Report Repair",
    "section": "Part 1",
    "text": "Part 1\n\nkey <- NA\n\nfor(x in 1:200) {\n  for(y in 1:200) {\n    if((df$values[x] + df$values[y]) == 2020) {\n      print(paste(df$values[x], df$values[y]))\n      key <- df$values[x] * df$values[y]\n      print(key)\n    }\n    if(!is.na(key))\n      break\n  }\n}\n\n[1] \"1825 195\"\n[1] 355875"
  },
  {
    "objectID": "2020/01/2020-01.html#part-2",
    "href": "2020/01/2020-01.html#part-2",
    "title": "2020-01: Report Repair",
    "section": "Part 2",
    "text": "Part 2\n\nkey <- NA\n\nfor(x in 1:200) {\n  for(y in 1:200) {\n    for(z in 1:200) {\n      if((df$values[x] + df$values[y]) + df$values[z] == 2020) {\n        print(paste(df$values[x], df$values[y], df$values[z]))\n        key <- df$values[x] * df$values[y] * df$values[z]\n        print(key)\n      }\n      if(!is.na(key))\n        break\n    }\n  }\n}\n\n[1] \"346 1380 294\"\n[1] 140379120"
  },
  {
    "objectID": "2020/02/2020-02.html#part-1",
    "href": "2020/02/2020-02.html#part-1",
    "title": "2020-02: Password Philosophy",
    "section": "Part 1",
    "text": "Part 1\n\ncount <- 0\n\nfor(i in 1:nrow(df)) {\n  if(str_count(df$password[i], as.character(df$letter[i])) >= df$min[i] & \n     str_count(df$password[i], as.character(df$letter[i])) <= df$max[i])\n    count <- count + 1\n}\n\ncount\n\n[1] 548"
  },
  {
    "objectID": "2020/02/2020-02.html#part-2",
    "href": "2020/02/2020-02.html#part-2",
    "title": "2020-02: Password Philosophy",
    "section": "Part 2",
    "text": "Part 2\n\ncount <- 0\n\nfor(i in 1:nrow(df)) {\n  sub <- paste(substr(df$password[i], df$min[i], df$min[i]), \n               substr(df$password[i], df$max[i], df$max[i]))\n  if(str_count(sub, as.character(df$letter[i])) == 1)\n    count <- count + 1\n}\n\ncount\n\n[1] 502"
  },
  {
    "objectID": "2020/03/2020-03.html#part-1",
    "href": "2020/03/2020-03.html#part-1",
    "title": "2020-03: Toboggan Trajectory",
    "section": "Part 1",
    "text": "Part 1\n\nx <- 1\npounds <- \"\"\nxVals <- c()\n\nfor(y in 1:323) {\n  pounds <- paste(pounds, as.character(df[y, x]), sep = \"\")\n  if(x + 3 > 31)\n    x <- x + 3 - 31\n  else\n    x <- x + 3\n  xVals <- append(xVals, as.character(x))\n}\n\nstr_count(pounds, \"#\")\n\n[1] 228"
  },
  {
    "objectID": "2020/03/2020-03.html#part-2",
    "href": "2020/03/2020-03.html#part-2",
    "title": "2020-03: Toboggan Trajectory",
    "section": "Part 2",
    "text": "Part 2\n\nover <- c(1, 3, 5, 7, 1)\ndown <- c(1, 1, 1, 1, 2)\nrunning_total <- 1\n\nfor(z in 1:5) {\n  x <- 1\n  pounds <- \"\"\n\n  for(y in seq(1, 323, by = down[z])) {\n    pounds <- paste(pounds, as.character(df[y, x]), sep = \"\")\n    if(x + over[z] > 31)\n      x <- x + over[z] - 31\n    else\n      x <- x + over[z]\n  }\n  running_total <- running_total * str_count(pounds, \"#\")\n}\nrunning_total\n\n[1] 6818112000"
  },
  {
    "objectID": "2020/04/2020-04.html#part-1",
    "href": "2020/04/2020-04.html#part-1",
    "title": "2020-04: Passport Processing",
    "section": "Part 1",
    "text": "Part 1\n\ncount <- 0\n\ntestDF <- df[1,]\n\nrow <- 1\ncolumn <- 1\nfor(r in 1:1169) {\n  for(c in 1:8) {\n    if(c == 1 & is.na(df[r,c])) {\n      column <- 1\n      row <- row + 1\n    }\n    if(!is.na(df[r,c])) {\n      testDF[row,column] <- df[r,c]\n      column <- column + 1\n    }\n  }\n}\n\npassports <- testDF\n\n\ncount <- 0\n\nfor(r in 1:299) {\n  if(rowSums(is.na(passports[r,])) == 0)\n      count <- count + 1\n  else if(!(apply(passports[r,], 1, function(x) {\n      any(substr(x, 1, 3) %in% \"cid\")\n    })) & rowSums(is.na(passports[r,])) == 1)\n      count <- count + 1\n}\ncount\n\n[1] 247"
  },
  {
    "objectID": "2020/04/2020-04.html#part-2",
    "href": "2020/04/2020-04.html#part-2",
    "title": "2020-04: Passport Processing",
    "section": "Part 2",
    "text": "Part 2\n\ncount <- 0\ndone <- FALSE\nfields <- c(\"byr\", \"iyr\", \"eyr\", \"hgt\", \"hcl\", \"ecl\", \"pid\", \"cid\")\nneeded <- c(\"byr\", \"iyr\", \"eyr\", \"hgt\", \"hcl\", \"ecl\", \"pid\")\npassport <- c()\n\ntestDF <- df[1,]\n\nrow <- 1\ncolumn <- 1\nfor(r in 1:1169) {\n  for(c in 1:8) {\n    if(c == 1 & is.na(df[r,c])) {\n      column <- 1\n      row <- row + 1\n    }\n    if(!is.na(df[r,c])) {\n      testDF[row,column] <- df[r,c]\n      column <- column + 1\n    }\n  }\n}\n\npassports <- testDF\npassports\n\n# A tibble: 299 × 8\n   X1          X2            X3            X4            X5    X6    X7    X8   \n   <chr>       <chr>         <chr>         <chr>         <chr> <chr> <chr> <chr>\n 1 byr:2024    iyr:2016      eyr:2034      ecl:zzz       pid:… hcl:… hgt:… cid:…\n 2 hgt:66cm    pid:152cm     hcl:cfb18a    eyr:1947      byr:… ecl:… iyr:… <NA> \n 3 ecl:gry     hcl:#888785   eyr:2023      cid:63        iyr:… hgt:… pid:… <NA> \n 4 pid:#5e832a ecl:dne       hcl:#7d3b0c   byr:2018      eyr:… hgt:… iyr:… cid:…\n 5 hcl:#888785 ecl:oth       eyr:2025      pid:597580472 iyr:… hgt:… byr:… cid:…\n 6 eyr:2029    cid:145       iyr:2026      pid:178cm     hgt:… ecl:… hcl:… byr:…\n 7 eyr:2024    ecl:amb       pid:349191561 iyr:2018      hgt:… byr:… hcl:… <NA> \n 8 byr:1998    pid:408617933 hcl:#fffffd   hgt:193cm     eyr:… ecl:… iyr:… <NA> \n 9 eyr:1964    byr:2026      hcl:#cfa07d   hgt:154cm     pid:… cid:… iyr:… ecl:…\n10 hgt:161cm   pid:021086946 iyr:2020      ecl:blu       eyr:… byr:… <NA>  <NA> \n# … with 289 more rows\n\n\n\nmatt <- passports[1,]\nmatt$valid <- NA\n\nfor(r in 1:299) {\n  temp <- passports[r,]\n  if(rowSums(is.na(passports[r,])) == 0 | \n     !(apply(passports[r,], 1, function(x) any(substr(x, 1, 3) %in% \"cid\"))) & \n     rowSums(is.na(passports[r,])) == 1)\n    temp$valid <- TRUE\n  else\n    temp$valid <- FALSE\n  matt <- rbind(matt, temp)\n}\nmatt <- matt[-1,]\n\nnewmatt <- matt[1,]\n\nfor(r in 1:299) {\n  for(c in 1:8) {\n    if(!is.na(matt[r,c])) {\n      if(substr(matt[r,c], 1, 3) == \"byr\")\n        newmatt[r,1] <- matt[r,c]\n      \n      else if(substr(matt[r,c], 1, 3) == \"iyr\") \n        newmatt[r,2] <- matt[r,c]\n      \n      else if(substr(matt[r,c], 1, 3) == \"eyr\")\n        newmatt[r,3] <- matt[r,c]\n      \n      else if(substr(matt[r,c], 1, 3) == \"hgt\") \n        newmatt[r,4] <- matt[r,c]\n    \n      else if(substr(matt[r,c], 1, 5) == \"hcl:#\") \n        newmatt[r,5] <- matt[r,c]\n      \n      else if(substr(matt[r,c], 1, 3) == \"ecl\") \n        newmatt[r,6] <- matt[r,c]\n      \n      else if(substr(matt[r,c], 1, 3) == \"pid\") \n        newmatt[r,7] <- matt[r,c]\n      \n      else if(substr(matt[r,c], 1, 3) == \"cid\")\n        newmatt[r,8] <- matt[r,c]\n      \n    }\n    else\n      newmatt[r,c] <- NA\n  }\n  newmatt[r,9] <- matt[r,9]\n}\n\n#sorted <- sorted[-1,]\n\nnewmatt$X1 <- str_replace_all(newmatt$X1, \"[a-z:]\", \"\")\nnewmatt$X2 <- str_replace_all(newmatt$X2, \"[a-z:]\", \"\")\nnewmatt$X3 <- str_replace_all(newmatt$X3, \"[a-z:]\", \"\")\nnewmatt$X4 <- substr(newmatt$X4, 5, nchar(newmatt$X4))\nnewmatt$X5 <- substr(newmatt$X5, 5, nchar(newmatt$X5))\nnewmatt$X6 <- substr(newmatt$X6, 5, nchar(newmatt$X6))\nnewmatt$X7 <- substr(newmatt$X7, 5, nchar(newmatt$X7))\nnewmatt$X8[!is.na(newmatt$X8)] <- TRUE\n\nnewmatt$X1 <- as.numeric(newmatt$X1)\nnewmatt$X2 <- as.numeric(newmatt$X2)\nnewmatt$X3 <- as.numeric(newmatt$X3)\n#newmatt$X7 <- as.numeric(newmatt$X7)\n\nnewmatt <- newmatt %>% filter(valid == TRUE)\nnewmatt$valid <- TRUE\n\n#the ants go marching one by one...\nnewmatt$flag <- 0\n\nnewmatt$valid <- ifelse(newmatt$X1 >= 1920 & newmatt$X1 <= 2002 & \n                          newmatt$valid == TRUE, TRUE, FALSE) #197\nnewmatt$valid <- ifelse(newmatt$X2 >= 2010 & newmatt$X2 <= 2020 & \n                          newmatt$valid == TRUE, TRUE, FALSE) #174\nnewmatt$valid <- ifelse(newmatt$X3 >= 2020 & newmatt$X3 <= 2030 & \n                          newmatt$valid == TRUE, TRUE, FALSE) #160\nnewmatt$flag <- \n  ifelse(newmatt$valid == TRUE & grepl(\"cm\", newmatt$X4) & \n           as.numeric(str_replace_all(newmatt$X4, \"[a-z]\", \"\")) >= 150 & \n           as.numeric(str_replace_all(newmatt$X4, \"[a-z]\", \"\")) <= 193, \n         newmatt$flag + 1, newmatt$flag)\nnewmatt$flag <- \n  ifelse(newmatt$valid == TRUE & grepl(\"in\", newmatt$X4) & \n           as.numeric(str_replace_all(newmatt$X4, \"[a-z]\", \"\")) >= 59 & \n           as.numeric(str_replace_all(newmatt$X4, \"[a-z]\", \"\")) <= 76, \n         newmatt$flag + 1, newmatt$flag)\nnewmatt$valid <- ifelse(newmatt$flag == 1, TRUE, FALSE)\nnewmatt$valid <- \n  ifelse(substr(newmatt$X5, 1, 1) == \"#\" & \n           grepl(\"[0-9a-f#]\", substr(newmatt$X5, 2, nchar(newmatt$X5) - 1)) & \n           nchar(newmatt$X5) == 7 & newmatt$valid == TRUE, TRUE, FALSE)\nnewmatt$valid <- \n  ifelse(grepl(\"(amb|blu|brn|gry|grn|hzl|oth)\", newmatt$X6) & \n           newmatt$valid == TRUE, TRUE, FALSE)\nnewmatt$valid <- \n  ifelse(nchar(newmatt$X7) == 9 & grepl(\"[0-9]\", newmatt$X7) & \n           newmatt$valid == TRUE, TRUE, FALSE)\n\nnewmatt %>%\n  filter(valid == TRUE) %>%\n  nrow()\n\n[1] 145"
  },
  {
    "objectID": "2020/05/2020-05.html#part-1",
    "href": "2020/05/2020-05.html#part-1",
    "title": "2020-05: Binary Boarding",
    "section": "Part 1",
    "text": "Part 1\n\ndf$rowbin <- df$X1\ndf$rowbin <- str_replace_all(df$rowbin, \"F\", \"0\")\ndf$rowbin <- str_replace_all(df$rowbin, \"B\", \"1\")\ndf$rownum <- BinToDec(df$rowbin)\n\ndf$colbin <- df$X2\ndf$colbin <- str_replace_all(df$colbin, \"L\", \"0\")\ndf$colbin <- str_replace_all(df$colbin, \"R\", \"1\")\ndf$colnum <- BinToDec(df$colbin)\n\n\ndf$seatid <- (df$rownum * 8) + df$colnum\nmax(df$seatid)\n\n[1] 828\n\nwrite.csv(df, \"input2.csv\")"
  },
  {
    "objectID": "2020/05/2020-05.html#part-2",
    "href": "2020/05/2020-05.html#part-2",
    "title": "2020-05: Binary Boarding",
    "section": "Part 2",
    "text": "Part 2\n\ndf <- df[order(df$seatid),]\n\n\nfor(i in 804:1) {\n  if(df$seatid[i + 1] - df$seatid[i] != 1) {\n    myseat <- df$seatid[i + 1] - 1\n    break\n  }\n}\n\nmyseat\n\n[1] 565"
  },
  {
    "objectID": "2020/06/2020-06.html#part-1",
    "href": "2020/06/2020-06.html#part-1",
    "title": "2020-06: Custom Customs",
    "section": "Part 1",
    "text": "Part 1\nRecycling this from D4P2\n\ndf <- dt\ntestDF <- df[1,]\ndfRow <- 1\ndfColumn <- 1\nfor(r in 1:2001) {\n  if(!is.na(df[r,1])) {\n    testDF[dfRow, dfColumn] <- df[r,1]\n    dfColumn <- dfColumn + 1\n  }\n  else {\n    dfRow <- dfRow + 1\n    dfColumn <- 1\n  }\n}\ndf <- testDF\ndf\n\n# A tibble: 456 × 5\n   X1                X1                 X1                 X1              X1   \n   <chr>             <chr>              <chr>              <chr>           <chr>\n 1 tr                rt                 tr                 rt              tr   \n 2 fdrhu             gwuksvro           <NA>               <NA>            <NA> \n 3 tesnouwyrdf       twofuspcmvenh      <NA>               <NA>            <NA> \n 4 cnxpsmuqiaw       cxovminqpawus      qwaxjmupnsic       <NA>            <NA> \n 5 anpskchzojyeguwr  soqauprxzgmycvef   sorplgezycau       ngrecposyizwau  ayep…\n 6 mvwcl             vlcwxm             uwcflhpkjor        blnvwtic        wcmzl\n 7 hyvowmqzixc       lacsrjdyxiz        fyczpbxlti         <NA>            <NA> \n 8 qxjhrgefbkm       eqrgbfhjxkcm       <NA>               <NA>            <NA> \n 9 catsrkyjulmfzvixe teyxvimulfkczqrjsa xrtlyaqemsucjzkifv drjlmncsiftxae… <NA> \n10 ocgrnldhja        jicwgntvuhk        cxgajhln           <NA>            <NA> \n# … with 446 more rows\n\n\n\ndf[is.na(df)] <- \"\"\ndf$all <- \"\"\nfor(r in 1:456) {\n  df$all[r] <- paste(df[r,1], df[r,2], df[r,3], df[r,4], df[r,5], sep = \"\")\n  df$count[r] <- length(unique(unlist(strsplit(df$all[r], \"\"))))\n}\n\nWarning: Unknown or uninitialised column: `count`.\n\ndf\n\n# A tibble: 456 × 7\n   X1                X1                 X1               X1    X1    all   count\n   <chr>             <chr>              <chr>            <chr> <chr> <chr> <int>\n 1 tr                rt                 \"tr\"             \"rt\"  \"tr\"  trrt…     2\n 2 fdrhu             gwuksvro           \"\"               \"\"    \"\"    fdrh…    11\n 3 tesnouwyrdf       twofuspcmvenh      \"\"               \"\"    \"\"    tesn…    16\n 4 cnxpsmuqiaw       cxovminqpawus      \"qwaxjmupnsic\"   \"\"    \"\"    cnxp…    14\n 5 anpskchzojyeguwr  soqauprxzgmycvef   \"sorplgezycau\"   \"ngr… \"aye… anps…    24\n 6 mvwcl             vlcwxm             \"uwcflhpkjor\"    \"bln… \"wcm… mvwc…    19\n 7 hyvowmqzixc       lacsrjdyxiz        \"fyczpbxlti\"     \"\"    \"\"    hyvo…    21\n 8 qxjhrgefbkm       eqrgbfhjxkcm       \"\"               \"\"    \"\"    qxjh…    12\n 9 catsrkyjulmfzvixe teyxvimulfkczqrjsa \"xrtlyaqemsucjz… \"drj… \"\"    cats…    21\n10 ocgrnldhja        jicwgntvuhk        \"cxgajhln\"       \"\"    \"\"    ocgr…    17\n# … with 446 more rows\n\n\n\nsum(df$count)\n\n[1] 6310"
  },
  {
    "objectID": "2020/06/2020-06.html#part-2",
    "href": "2020/06/2020-06.html#part-2",
    "title": "2020-06: Custom Customs",
    "section": "Part 2",
    "text": "Part 2\n\ndf <- dt\ntestDF <- df[1,]\ndfRow <- 1\ndfColumn <- 1\nfor(r in 1:2001) {\n  if(!is.na(df[r,1])) {\n    testDF[dfRow, dfColumn] <- df[r,1]\n    dfColumn <- dfColumn + 1\n  }\n  else {\n    dfRow <- dfRow + 1\n    dfColumn <- 1\n  }\n}\ndf <- testDF\ndf\n\n# A tibble: 456 × 5\n   X1                X1                 X1                 X1              X1   \n   <chr>             <chr>              <chr>              <chr>           <chr>\n 1 tr                rt                 tr                 rt              tr   \n 2 fdrhu             gwuksvro           <NA>               <NA>            <NA> \n 3 tesnouwyrdf       twofuspcmvenh      <NA>               <NA>            <NA> \n 4 cnxpsmuqiaw       cxovminqpawus      qwaxjmupnsic       <NA>            <NA> \n 5 anpskchzojyeguwr  soqauprxzgmycvef   sorplgezycau       ngrecposyizwau  ayep…\n 6 mvwcl             vlcwxm             uwcflhpkjor        blnvwtic        wcmzl\n 7 hyvowmqzixc       lacsrjdyxiz        fyczpbxlti         <NA>            <NA> \n 8 qxjhrgefbkm       eqrgbfhjxkcm       <NA>               <NA>            <NA> \n 9 catsrkyjulmfzvixe teyxvimulfkczqrjsa xrtlyaqemsucjzkifv drjlmncsiftxae… <NA> \n10 ocgrnldhja        jicwgntvuhk        cxgajhln           <NA>            <NA> \n# … with 446 more rows\n\n\nCredit to Matthew McMillan for the idea of using sets\n\nfor(r in 1:456)\n  for(c in 2:5)\n    if(is.na(df[r,c]))\n      df[r,c] <- df[r,1]\ndf$matthew <- NA_integer_\nfor(r in 1:456) {\n  df$matthew[r] <-\n    length(unique(\n      set_intersection(\n        unique(unlist(strsplit(\n          as.character(df[r, 1]), \"\"\n        ))),\n        unique(unlist(strsplit(\n          as.character(df[r, 2]), \"\"\n        ))),\n        unique(unlist(strsplit(\n          as.character(df[r, 3]), \"\"\n        ))),\n        unique(unlist(strsplit(\n          as.character(df[r, 4]), \"\"\n        ))),\n        unique(unlist(strsplit(\n          as.character(df[r, 5]), \"\"\n        )))\n      )\n    ))\n}\n\ndf\n\n# A tibble: 456 × 6\n   X1                X1                 X1                 X1      X1    matthew\n   <chr>             <chr>              <chr>              <chr>   <chr>   <int>\n 1 tr                rt                 tr                 rt      tr          2\n 2 fdrhu             gwuksvro           fdrhu              fdrhu   fdrhu       2\n 3 tesnouwyrdf       twofuspcmvenh      tesnouwyrdf        tesnou… tesn…       8\n 4 cnxpsmuqiaw       cxovminqpawus      qwaxjmupnsic       cnxpsm… cnxp…      11\n 5 anpskchzojyeguwr  soqauprxzgmycvef   sorplgezycau       ngrecp… ayep…      11\n 6 mvwcl             vlcwxm             uwcflhpkjor        blnvwt… wcmzl       3\n 7 hyvowmqzixc       lacsrjdyxiz        fyczpbxlti         hyvowm… hyvo…       5\n 8 qxjhrgefbkm       eqrgbfhjxkcm       qxjhrgefbkm        qxjhrg… qxjh…      11\n 9 catsrkyjulmfzvixe teyxvimulfkczqrjsa xrtlyaqemsucjzkifv drjlmn… cats…      17\n10 ocgrnldhja        jicwgntvuhk        cxgajhln           ocgrnl… ocgr…       5\n# … with 446 more rows\n\n\n\nsum(df$matthew)\n\n[1] 3193"
  },
  {
    "objectID": "2020/07/2020-07.html#part-1",
    "href": "2020/07/2020-07.html#part-1",
    "title": "2020-07: Handy Haversacks",
    "section": "Part 1",
    "text": "Part 1\n\nlongerDF <- data.frame(parent = \"\", nChild = 0, cChild = \"\")\n\nfor(col in seq(3, 9, by = 2)) {\n  for(r in 1:nrow(df)) {\n    if(!is.na(df[r,col-1]))\n      for(i in 1:df[r,col-1]) {\n        longerDF <- rbind(longerDF, data.frame(parent = df[r,1], \n                                               nChild = df[r,col-1], \n                                               cChild = df[r,col]))\n    }\n  }\n}\nlongerDF <- longerDF[-1,]\n\n\nshinygoldDF <- \n  longerDF[longerDF$cChild == \"shiny gold\" | longerDF$parent == \"shiny gold\",]\n\n\nlevel <- c(\"shiny gold\")\noldRows <- 0\n\nwhile(oldRows != nrow(shinygoldDF)) {\n  oldRows <- nrow(shinygoldDF)\n  level <- unlist(shinygoldDF$parent)\n  shinygoldDF <-\n    df[as.character(df$parent) %in% level |\n         as.character(df$child1C) %in% level |\n         as.character(df$child2C) %in% level |\n         as.character(df$child3C) %in% level |\n         as.character(df$child4C) %in% level, ]\n}\nnrow(shinygoldDF) - 1\n\n[1] 164"
  },
  {
    "objectID": "2020/07/2020-07.html#part-2",
    "href": "2020/07/2020-07.html#part-2",
    "title": "2020-07: Handy Haversacks",
    "section": "Part 2",
    "text": "Part 2\n\n\n\n\n\n\nDanger\n\n\n\nThis solution is still under construction.\n\n\n\nlibrary(tidyverse)\nlibrary(data.table)\n\n\nAttaching package: 'data.table'\n\n\nThe following objects are masked from 'package:dplyr':\n\n    between, first, last\n\n\nThe following object is masked from 'package:purrr':\n\n    transpose\n\nlibrary(stringr)\nlibrary(foreach)\n\n\nAttaching package: 'foreach'\n\n\nThe following objects are masked from 'package:purrr':\n\n    accumulate, when\n\n\n\ndf <- readLines(\"test.txt\")\ndt <- data.table(\"parent\" = \"\", \"child\" = \"\")\n# str_split(df, \" bags contain | bags, | bags\\\\.\")\nbags <- \n  str_extract_all(df, \"(no other|\\\\d) (\\\\w* \\\\w*)|(\\\\w* \\\\w*) bags\") |>\n  lapply(\\(x) {\n    l <- sapply(x[-1], \\(y) {\n        if (y == \"no other bags\") { return(y) }\n        count <- as.numeric(str_extract_all(y, \"\\\\d \")[[1]])\n        y <- rep(gsub(\"\\\\d \", \"\", y), count)\n        return(y)\n      })\n    \n      if (is.matrix(l)) { l <- as.vector(l) }\n    \n      l <-\n        l |>\n        unname() |>\n        unlist() |>\n        list() |>\n        `names<-`(gsub(\" bags\", \"\", x[1]))\n      \n      return(l)\n  }) |>\n  unlist(recursive = FALSE) |>\n  lapply(\\(x) {\n    if (any(grepl(\"shiny gold\", x))) { return(NULL) }\n    x\n  })\n\nbags <- bags[!sapply(bags, is.null)]\n\n# bags |>\n#   unlist() |>\n#   data.frame() |>\n#   rownames_to_column() |>\n#   filter(rowname == \"shiny gold\" | unlist.bags. == \"shiny gold\")\n\n# get_contents <- function(bag, pBag = \"shiny gold\") {\n#   if (is.null(bag) | length(bag) == 0 | any(grepl(\"no other bags\", bag))) { return(pBag) }\n#   else { lapply(bag, \\(n) get_contents(bags[[n]], pBag = n)) |> unlist() }\n# \n# }\n\nget_contents <- function(.x, .y) {\n  bag <- .x\n  pBag <- .y\n  if (pBag %in% names(which(bags == \"no other bags\"))) { return(get_contents(.y, \"no other bags\")) }\n  furrr:::future_map2(bags[[bag]], pBag, \\(.x, .y) { get_contents(.x, .y) })\n}\n\nn <- names(bags)\nn <- c(\"shiny gold\", n[n != \"shiny gold\"])\n\nl <-\n  lapply(n, \\(x) {\n    bags[[x]] |>\n      list() |>\n      `names<-`(x)\n  }) |>\n  # unlist(recursive = FALSE) |>\n  lapply(\\(x) {\n    y <- unlist(x)\n    names(y) <- c(rep(names(x), length(y)))\n    \n    y\n  }) |>\n  unlist() |> \n  as.list()\nfuture::plan(\n  list(future::tweak(future::multicore, workers = 12)),\n  list(future::tweak(future::sequential))\n)\n\nprogressr::with_progress({\n  p <- progressr::progressor(steps = length(l))\n  l <-\n    furrr::future_map2(l, names(l), \\(.x, .y) {\n      p()\n      bag <- get_contents(.x, .y)\n      if (is.null(bag)) { bag <- .x }\n      else { bag <- .y }\n      return(bag)\n      })\n})\n\nl |> unlist(recursive = FALSE)\n\n# tb <-\n#   table(bags[[\"shiny gold\"]]) |>\n#   data.frame() |>\n#   `colnames<-`(c(\"parent\", \"n\"))\n# \n# # l\n# data.frame(\"parent\" = names(l), \"child\" = l) |>\n#   mutate(parent = str_remove_all(parent, \"\\\\d\")) |>\n#   filter(parent == \"shiny gold\") |>\n#   nrow()\n# \n# bags[[\"dark red\"]]\n\n\ndf <- readLines(\"input.txt\")\ndt <- data.table(\"parent\" = \"\", \"child\" = \"\")\n# str_split(df, \" bags contain | bags, | bags\\\\.\")\nbags <- \n  str_extract_all(df, \"(no other|\\\\d) (\\\\w* \\\\w*)|(\\\\w* \\\\w*) bags\") |>\n  lapply(\\(x) {\n    l <- sapply(x[-1], \\(y) {\n        if (y == \"no other bags\") { return(y) }\n        count <- as.numeric(str_extract_all(y, \"\\\\d \")[[1]])\n        y <- rep(gsub(\"\\\\d \", \"\", y), count)\n        return(y)\n      })\n    \n      if (is.matrix(l)) { l <- as.vector(l) }\n    \n      l <-\n        l |>\n        unname() |>\n        unlist() |>\n        list() |>\n        `names<-`(gsub(\" bags\", \"\", x[1]))\n      \n      return(l)\n  }) |>\n  unlist(recursive = FALSE) |>\n  lapply(\\(x) {\n    if (any(grepl(\"shiny gold\", x))) { return(NULL) }\n    x\n  })\n\nbags <- bags[!sapply(bags, is.null)]\n\nno_others <- names(which(bags == \"no other bags\"))\n\nget_contents <- function(bag, pBag = \"shiny gold\") {\n  print(paste(bag, pBag))\n  if (length(pBag) == 0 | pBag %in% no_others) { return(c(\"no other bags\" = pBag)) }\n  # bag <- bag[!(bag %in% names(which(bags == \"no other bags\")))]\n  # lapply(bag, \\(n) list(n, get_contents(bags[[n]], pBag = n)))\n  # print(unique_bag)\n  get_contents(bag, pBag = names(bag))\n}\n\nn <- names(bags)\nn <- c(\"shiny gold\", n[n != \"shiny gold\"])\n\nl <-\n  lapply(n, \\(x) {\n    bags[[x]] |>\n      list() |>\n      `names<-`(x)\n  }) |>\n  # unlist(recursive = FALSE) |>\n  lapply(\\(x) {\n    y <- unlist(x)\n    names(y) <- c(rep(names(x), length(y)))\n    \n    y\n  }) |>\n  unlist() |> \n  as.list()\n\nlapply(l, \\(l) { get_contents(l, \"shiny gold\") })\n\nlapply(l, \\(l) {  })\n\ncl <- parallel::makeCluster(6)\nparallel::clusterExport(cl, c(\"bags\", \"l\", \"get_contents\"))\nl <- \n  pbapply::pblapply(l, get_contents, cl = cl) |>\n  unlist()\nparallel::stopCluster(cl)\n\ntb <-\n  table(bags[[\"shiny gold\"]]) |>\n  data.frame() |>\n  `colnames<-`(c(\"parent\", \"n\"))\n\n# l\ndata.frame(\"parent\" = names(l), \"child\" = l) |>\n  mutate(parent = str_remove_all(parent, \"\\\\d\")) |>\n  filter(parent == \"shiny gold\") |>\n  nrow()\n\n\ndf <- readLines(\"input.txt\")\ndt <- data.table(\"parent\" = \"\", \"child\" = \"\")\n# str_split(df, \" bags contain | bags, | bags\\\\.\")\nbags <- \n  str_extract_all(df, \"(no other|\\\\d) (\\\\w* \\\\w*)|(\\\\w* \\\\w*) bags\") |>\n  lapply(\\(x) {\n    l <- sapply(x[-1], \\(y) {\n        if (y == \"no other bags\") { return(y) }\n        count <- as.numeric(str_extract_all(y, \"\\\\d \")[[1]])\n        y <- rep(gsub(\"\\\\d \", \"\", y), count)\n        return(y)\n      })\n    \n      if (is.matrix(l)) { l <- as.vector(l) }\n    \n      l <-\n        l |>\n        unname() |>\n        unlist() |>\n        list() |>\n        `names<-`(gsub(\" bags\", \"\", x[1]))\n      \n      return(l)\n  }) |>\n  unlist(recursive = FALSE) |>\n  lapply(\\(x) {\n    if (any(grepl(\"shiny gold|no other bags\", x))) { return(NULL) }\n    x\n  })\n\nbags <- bags[!sapply(bags, is.null)]\n\n# bags |>\n#   unlist() |>\n#   data.frame() |>\n#   rownames_to_column() |>\n#   filter(rowname == \"shiny gold\" | unlist.bags. == \"shiny gold\")\n\n# get_contents <- function(bag, pBag = \"shiny gold\") {\n#   if (is.null(bag) | length(bag) == 0 | any(grepl(\"no other bags\", bag))) { return(pBag) }\n#   else { lapply(bag, \\(n) get_contents(bags[[n]], pBag = n)) |> unlist() }\n# \n# }\n\nget_contents <- function(bag, pBag = \"shiny gold\") {\n  if (pBag %in% names(which(bags == \"no other bags\"))) { return(c(\"no other bags\" = pBag)) }\n  bag <- bag[!(bag %in% names(which(bags == \"no other bags\")))]\n  # lapply(bag, \\(n) list(n, get_contents(bags[[n]], pBag = n)))\n  length_bag <- length(bag)\n  unique_bag <- unique(bag)\n  # print(unique_bag)\n  unique_bag <- lapply(unique_bag, \\(n) list(n, get_contents(bags[[n]], pBag = n)))\n  rep(unique_bag, length_bag)\n}\n\n# get_contents <- function(bag, pBag = \"shiny gold\") {\n#   if (pBag %in% names(which(bags == \"no other bags\"))) { return(c(\"no other bags\" = pBag)) }\n#   bag <- bag[!(bag %in% names(which(bags == \"no other bags\")))]\n#   lapply(bag, \\(n) list(n, get_contents(bags[[n]], pBag = n)))\n# }\n\nn <- names(bags)\nn <- c(\"shiny gold\", n[n != \"shiny gold\"])\n\nl <-\n  lapply(n, \\(x) {\n    bags[[x]] |>\n      list() |>\n      `names<-`(x)\n  }) |>\n  unlist(recursive = FALSE)\n\ncl <- parallel::makeCluster(6)\nparallel::clusterExport(cl, c(\"bags\", \"l\", \"get_contents\"))\nl <- \n  pbapply::pblapply(l, get_contents, cl = cl) |>\n  unlist()\nparallel::stopCluster(cl)\n\ntb <-\n  table(bags[[\"shiny gold\"]]) |>\n  data.frame() |>\n  `colnames<-`(c(\"parent\", \"n\"))\n\n# l\ndata.frame(\"parent\" = names(l), \"child\" = l) |>\n  mutate(parent = str_remove_all(parent, \"\\\\d\")) |>\n  filter(parent == \"shiny gold\") |>\n  nrow()\n\n6268 6286"
  },
  {
    "objectID": "2020/08/2020-08.html#part-1",
    "href": "2020/08/2020-08.html#part-1",
    "title": "2020-08: Handheld Halting",
    "section": "Part 1",
    "text": "Part 1\n\ndf <- masterDF\ndf$ipa <- NA\ndf$ipa[1] <- 0\nacc <- 0\nr <- 1\nflag <- TRUE\n\nwhile(flag == TRUE) {\n  if(as.character(df$ope[r]) == \"acc\" & r <= 626 & r >= 1) {\n    acc <- acc + df$arg[r]\n    flag <- is.na(df$ipa[r + 1])\n    df$ipa[r + 1] <- r\n    r <- r + 1\n    }\n  else if(as.character(df$ope[r]) == \"jmp\" & r + df$arg[r] <= 626 & r + df$arg[r] >= 1) {\n    flag <- is.na(df$ipa[r + df$arg[r]])\n    df$ipa[r + df$arg[r]] <- r\n    r <- r + df$arg[r]\n    }\n  else if(as.character(df$ope[r]) == \"nop\" & r <= 626 & r >= 1) {\n    flag <- is.na(df$ipa[r + 1])\n    df$ipa[r + 1] <- r\n    r <- r + 1\n    }\n}\n\nacc\n\n[1] 1317"
  },
  {
    "objectID": "2020/08/2020-08.html#part-2",
    "href": "2020/08/2020-08.html#part-2",
    "title": "2020-08: Handheld Halting",
    "section": "Part 2",
    "text": "Part 2\n\nfor(i in 1:626) {\n  df <- masterDF\n  \n  df$ipa <- NA\n  df$ipa[1] <- 0\n  \n  acc <- 0\n  r <- 1\n  \n  flag <- TRUE\n  breakFlag <- FALSE\n  \n  if(as.character(df$ope[i]) == \"nop\")\n    df$ope[i] <- \"jmp\"\n  else if(as.character(df$ope[i]) == \"jmp\")\n    df$ope[i] <- \"nop\"\n  \n  if(as.character(df$ope[i]) != \"acc\") {\n    while(flag) {\n      if(as.character(df$ope[r]) == \"acc\" & r <= 626 & r >= 1) {\n        acc <- acc + df$arg[r]\n        flag <- is.na(df$ipa[r + 1])\n        df$ipa[r + 1] <- r\n        r <- r + 1\n        }\n      else if(as.character(df$ope[r]) == \"jmp\" & r + df$arg[r] <= 626 & r + df$arg[r] >= 1) {\n        flag <- is.na(df$ipa[r + df$arg[r]])\n        df$ipa[r + df$arg[r]] <- r\n        r <- r + df$arg[r]\n        }\n      else if(as.character(df$ope[r]) == \"nop\" & r <= 626 & r >= 1) {\n        flag <- is.na(df$ipa[r + 1])\n        df$ipa[r + 1] <- r\n        r <- r + 1\n      }\n    \n      if(r == 626) {\n        breakFlag <- TRUE\n        break\n        }\n    }\n  }\n  if(breakFlag)\n    break\n}\n\nacc\n\n[1] 1033"
  },
  {
    "objectID": "2020/09/2020-09.html#part-1",
    "href": "2020/09/2020-09.html#part-1",
    "title": "2020-09: Encoding Error",
    "section": "Part 1",
    "text": "Part 1\n\ngoodNum <- FALSE\nfor(i in 26:1000) {\n  for(r1 in (i-25):(i-1)) {\n    if(df[r1,1] < df[i,1])\n      for(r2 in (i-25):(i-1))\n        if(df[i,1] - df[r1,1] == df[r2,1]) {\n          goodNum <- TRUE\n          break\n        }\n    if(goodNum)\n      break\n  }\n  if(!goodNum) {\n    print(df[i,1])\n    break\n  }\n  goodNum <- FALSE\n}\n\n[1] 69316178"
  },
  {
    "objectID": "2020/09/2020-09.html#part-2",
    "href": "2020/09/2020-09.html#part-2",
    "title": "2020-09: Encoding Error",
    "section": "Part 2",
    "text": "Part 2\n\ngoalNum <- 0\ngoodNum <- FALSE\nfor(i in 26:1000) {\n  for(r1 in (i-25):(i-1)) {\n    if(df[r1,1] < df[i,1])\n      for(r2 in (i-25):(i-1))\n        if(df[i,1] - df[r1,1] == df[r2,1]) {\n          goodNum <- TRUE\n          break\n        }\n    if(goodNum)\n      break\n  }\n  if(!goodNum) {\n    goalNum <- df[i,1]\n    break\n  }\n  goodNum <- FALSE\n}\n\n\nbreakFlag <- FALSE\nfor(start in 1:1000) {\n  for(end in start:1000) {\n    if(sum(df$num[start:end]) == goalNum) {\n      breakFlag <- TRUE\n      break\n    }\n  }\n  if(breakFlag)\n    break\n}\n\n\nsmallest <- max(df$num)\nlargest <- min(df$num)\n\nfor(r in start:end) {\n  if(df$num[r] < smallest)\n    smallest <- df$num[r]\n  if(df$num[r] > largest)\n    largest <- df$num[r]\n}\n\nsmallest + largest\n\n[1] 9351526"
  },
  {
    "objectID": "2020/10/2020-10.html#part-1",
    "href": "2020/10/2020-10.html#part-1",
    "title": "2020-10: Adapter Array",
    "section": "Part 1",
    "text": "Part 1\n\ndf <- df[order(df$jolts),]\ncount1 <- 0\ncount3 <- 0\nfor(r in 1:(nrow(df) - 1)) {\n  if(df[r+1,1] - df[r,1] == 1)\n    count1 <- count1 + 1\n  else if(df[r+1,1] - df[r,1] == 3)\n    count3 <- count3 + 1\n}\ncount1 * count3\n\n[1] 2414"
  },
  {
    "objectID": "2020/10/2020-10.html#part-2",
    "href": "2020/10/2020-10.html#part-2",
    "title": "2020-10: Adapter Array",
    "section": "Part 2",
    "text": "Part 2\n\ndf$paths <- 0\ndf$paths[1] <- 1\nfor(i in 2:nrow(df))\n  for(x in 1:3)\n    if((df$jolts[i] - x) %in% df$jolts)\n      df$paths[i] <- df$paths[i] + df$paths[match(df$jolts[i] - x, df$jolts)]\nformat(df$paths[nrow(df) - 1], scientific=FALSE)\n\n[1] \"21156911906816\""
  },
  {
    "objectID": "2019/01/2019-01.html#part-1",
    "href": "2019/01/2019-01.html#part-1",
    "title": "2019-01: The Tyranny of the Rocket Equation",
    "section": "Part 1",
    "text": "Part 1\n\nsum(floor(dt / 3) - 2)\n\n[1] 3512133"
  },
  {
    "objectID": "2019/01/2019-01.html#part-2",
    "href": "2019/01/2019-01.html#part-2",
    "title": "2019-01: The Tyranny of the Rocket Equation",
    "section": "Part 2",
    "text": "Part 2\n\nx <- 1\ntotal <- 0\nsapply(dt, function(x) {\n  total <- 0\n  val <- x\n  while (floor(val / 3) - 2 >= 0) {\n    val <- floor(val / 3) - 2\n    total <- total + val\n  }\n  return(total)\n}) |>\n  sum()\n\n[1] 5265294"
  },
  {
    "objectID": "2019/02/2019-02.html#part-1",
    "href": "2019/02/2019-02.html#part-1",
    "title": "2019-02: 1202 Program Alarm",
    "section": "Part 1",
    "text": "Part 1\n\ndt <- dtM\ndt[1 + 1] <- 12\ndt[2 + 1] <- 2\nd <- 0\nx <- 1\nwhile(d != 99) {\n  if (dt[x] == 1) { dt[dt[x + 3] + 1] <- dt[dt[x + 1] + 1] + dt[dt[x + 2] + 1] }\n  else if (dt[x] == 2) { dt[dt[x + 3] + 1] <- dt[dt[x + 1] + 1] * dt[dt[x + 2] + 1] }\n  x <- x + 4\n  d <- dt[x]\n}\ndt[1]\n\n[1] 3706713\n\nx\n\n[1] 125"
  },
  {
    "objectID": "2019/02/2019-02.html#part-2",
    "href": "2019/02/2019-02.html#part-2",
    "title": "2019-02: 1202 Program Alarm",
    "section": "Part 2",
    "text": "Part 2\n\nbreakFlag <- FALSE\nfor (i in 0:99) {\n  for (j in 0:99) {\n    dt <- dtM\n    dt[1 + 1] <- i\n    dt[2 + 1] <- j\n    d <- 0\n    x <- 1\n    while (d != 99) {\n      if (dt[x] == 1) {\n        dt[dt[x + 3] + 1] <- dt[dt[x + 1] + 1] + dt[dt[x + 2] + 1]\n      }\n      else if (dt[x] == 2) {\n        dt[dt[x + 3] + 1] <- dt[dt[x + 1] + 1] * dt[dt[x + 2] + 1]\n      }\n      x <- x + 4\n      d <- dt[x]\n    }\n    if (dt[1] == 19690720) {\n      breakFlag <- TRUE\n      break\n    }\n  }\n  if (breakFlag) { break }\n}\n100 * dt[1 + 1] + dt[2 + 1]\n\n[1] 8609"
  },
  {
    "objectID": "2019/03/2019-03.html#part-1",
    "href": "2019/03/2019-03.html#part-1",
    "title": "2019-03: Crossed Wires",
    "section": "Part 1",
    "text": "Part 1\n\ndtM <- lapply(dtMM, expand_directions, preserve_data = TRUE)\n\ndtM[[1]] <- follow_directions(dtM[[1]], 0, 0, preserve_data = TRUE)\ndtM[[2]] <- follow_directions(dtM[[2]], 0, 0, preserve_data = TRUE)\n\ninner_join(dtM[[1]], dtM[[2]], by = c(\"row\", \"col\")) |>\n  mutate(dist = abs(row) + abs(col)) |>\n  arrange(dist) |>\n  head(1) |>\n  pull(dist)\n\n[1] 1264"
  },
  {
    "objectID": "2019/03/2019-03.html#part-2",
    "href": "2019/03/2019-03.html#part-2",
    "title": "2019-03: Crossed Wires",
    "section": "Part 2",
    "text": "Part 2\n\ndtM[[1]] <- \n  dtM[[1]] |>\n  mutate(step = row_number())\ndtM[[2]] <- \n  dtM[[2]] |>\n  mutate(step = row_number())\n\ninner_join(dtM[[1]], dtM[[2]], by = c(\"row\", \"col\")) |>\n  mutate(steps = step.x + step.y) |>\n  arrange(steps) |>\n  head(1) |>\n  pull(steps)\n\n[1] 37390"
  },
  {
    "objectID": "2019/04/2019-04.html",
    "href": "2019/04/2019-04.html",
    "title": "2019-04: Secure Container",
    "section": "",
    "text": "Part 1"
  },
  {
    "objectID": "2019/04/2019-04.html#part-2",
    "href": "2019/04/2019-04.html#part-2",
    "title": "2019-04: Secure Container",
    "section": "Part 2",
    "text": "Part 2\n\ns2 <-\n  sapply(dt, \\(s) {\n    s <- str_split(s, \"\") |> unlist() |> table()\n    s <- ifelse(any(s == 2), TRUE, FALSE)\n    return(s)\n  })\nsum(s2)\n\n[1] 763"
  },
  {
    "objectID": "2018/01/2018-01.html#part-1",
    "href": "2018/01/2018-01.html#part-1",
    "title": "2018-01: Chronal Calibration",
    "section": "Part 1",
    "text": "Part 1\n\nsum(dt$V1)\n\n[1] 425"
  },
  {
    "objectID": "2018/01/2018-01.html#part-2",
    "href": "2018/01/2018-01.html#part-2",
    "title": "2018-01: Chronal Calibration",
    "section": "Part 2",
    "text": "Part 2\n\nbreakFlag <- FALSE\nre_pete <- 1\nwhile (!breakFlag) {\n  vec <- cumsum(rep(dt$V1, re_pete))\n  \n  twice <- vec[duplicated(vec)]\n  \n  if (length(twice >= 1)) {\n    print(twice[1])\n    breakFlag <- TRUE\n  } else {\n    re_pete <- re_pete + 1\n  }\n}\n\n[1] 57538"
  },
  {
    "objectID": "2018/02/2018-02.html#part-1",
    "href": "2018/02/2018-02.html#part-1",
    "title": "2018-02: Inventory Management System",
    "section": "Part 1",
    "text": "Part 1\n\nsapply(strsplit(dt$V1, \"\"), function(x) {\n  x <- table(x)\n  x <- unique(x[x %in% 2:3])\n}) |>\n  unlist() |>\n  unname() |>\n  table() |>\n  prod()\n\n[1] 8118"
  },
  {
    "objectID": "2018/02/2018-02.html#part-2",
    "href": "2018/02/2018-02.html#part-2",
    "title": "2018-02: Inventory Management System",
    "section": "Part 2",
    "text": "Part 2\n\nmat <- adist(dt$V1)\nmat <- as.character(expand.grid(dt$V1, dt$V1)[which(mat == 1),][,1])\nmat <- strsplit(mat, \"\")\npaste0(mat[[1]][mat[[1]] == mat[[2]]], collapse = \"\")\n\n[1] \"jbbenqtlaxhivmwyscjukztdp\""
  },
  {
    "objectID": "2018/03/2018-03.html#part-1",
    "href": "2018/03/2018-03.html#part-1",
    "title": "2018-03: No Matter How You Slice It",
    "section": "Part 1",
    "text": "Part 1\n\nmat <- matrix(0, 1000, 1000)\nfor(x in 1:nrow(dt)) {\n  xPos <- dt$xPos[x] + 1\n  xSize <- dt$xSize[x] - 1\n  yPos <- dt$yPos[x] + 1\n  ySize <- dt$ySize[x] - 1\n  mat[xPos:(xPos + xSize), yPos:(yPos + ySize)] <- \n    mat[xPos:(xPos + xSize), yPos:(yPos + ySize)] + 1\n}\nlength(mat[mat >= 2])\n\n[1] 98005"
  },
  {
    "objectID": "2018/03/2018-03.html#part-2",
    "href": "2018/03/2018-03.html#part-2",
    "title": "2018-03: No Matter How You Slice It",
    "section": "Part 2",
    "text": "Part 2\n\nfor(x in 1:nrow(dt)) {\n  xPos <- dt$xPos[x] + 1\n  xSize <- dt$xSize[x] - 1\n  yPos <- dt$yPos[x] + 1\n  ySize <- dt$ySize[x] - 1\n  if (all(mat[xPos:(xPos + xSize), yPos:(yPos + ySize)] == 1)) { print(x) }\n}\n\n[1] 331"
  },
  {
    "objectID": "2018/04/2018-04.html#part-1",
    "href": "2018/04/2018-04.html#part-1",
    "title": "2018-04: Repose Record",
    "section": "Part 1",
    "text": "Part 1\n\ndata.table(\"day\" =\n             rep(seq.Date(as.Date(min(dt$time)), \n                          as.Date(max(dt$time)), \n                          by = \"day\"), \n                 each = 60),\n           \"minute\" = 0:59) |>\n  left_join(dt, by = c(\"day\", \"minute\")) |>\n  select(-time) |>\n  arrange(day, minute) |>\n  fill(action, guard) |>\n  filter(action == \"asleep\") |>\n  dcast(guard ~ minute, value.var = \"action\", fun.aggregate = length) -> saved\nsaved %>%\n  mutate(total = rowSums(.) - guard) |>\n  filter(total == max(total)) |>\n  select(-total) |>\n  as.vector() |>\n  unlist() -> vec\n\nunname(vec[\"guard\"] * as.numeric(names(which.max(vec[-1]))))\n\n[1] 146622"
  },
  {
    "objectID": "2018/04/2018-04.html#part-2",
    "href": "2018/04/2018-04.html#part-2",
    "title": "2018-04: Repose Record",
    "section": "Part 2",
    "text": "Part 2\n\nsaved |>\n  pivot_longer(cols = matches(\"[0-9]{1,2}\"), names_to = \"minute\", values_to = \"times\") |>\n  filter(times == max(times)) |>\n  mutate(value = guard * as.numeric(minute)) |>\n  pull(value)\n\n[1] 31848"
  },
  {
    "objectID": "2018/05/2018-05.html#part-1",
    "href": "2018/05/2018-05.html#part-1",
    "title": "2018-05: Alchemical Reduction",
    "section": "Part 1",
    "text": "Part 1\n\nreduced <- TRUE\nwhile(reduced) {\n  old <- length(dt)\n  for (x in 1:(old - 1)) {\n    if (dt[x] != dt[x + 1] & toupper(dt[x]) == toupper(dt[x + 1])) {\n      dt[c(x, x + 1)] <- \"\"\n      reduced <- TRUE\n    }\n  }\n  dt <- dt[dt != \"\"]\n  if(old == length(dt)) {\n    reduced <- FALSE\n  }\n}\nlength(dt)\n\n[1] 10598"
  },
  {
    "objectID": "2018/05/2018-05.html#part-2",
    "href": "2018/05/2018-05.html#part-2",
    "title": "2018-05: Alchemical Reduction",
    "section": "Part 2",
    "text": "Part 2\n\nsapply(1:26, function(l) {\n  tmp <- stri_replace_all_regex(dt, paste0(letters[l], \"|\", LETTERS[l]), \"\")\n  reduced <- TRUE\n  while (reduced) {\n    old <- length(tmp)\n    for (x in 1:(old - 1)) {\n      if (tmp[x] != tmp[x + 1] & toupper(tmp[x]) == toupper(tmp[x + 1])) {\n        tmp[c(x, x + 1)] <- \"\"\n        reduced <- TRUE\n      }\n    }\n    tmp <- tmp[tmp != \"\"]\n    if (old == length(tmp)) {\n      reduced <- FALSE\n    }\n  }\n  length(tmp)\n}) |>\n  min()\n\n[1] 5312"
  },
  {
    "objectID": "2018/06/2018-06.html#part-1",
    "href": "2018/06/2018-06.html#part-1",
    "title": "2018-06: Chronal Coordinates",
    "section": "Part 1",
    "text": "Part 1\n\nsize <- max(max(dt$x), max(dt$y))\nmat <- matrix(NA, size, size)\nmat[as.matrix(dt[, 1:2])] <- dt$id\n\nfor(x in 1:ncol(mat)) {\n  for(y in 1:nrow(mat)) {\n    distX <- abs(x - dt$x)\n    distY <- abs(y - dt$y)\n    dist <- (distX + distY) / 2\n    closest <- dist[dist == min(dist)]\n    mat[x,y] <- ifelse(length(closest) == 1, which.min(dist), NA)\n  }\n}\n\nedges <- unique(c(mat[1, ], mat[,1], mat[nrow(mat), ], mat[, ncol(mat)]))\nmat[mat %in% edges] <- NA\nmax(table(mat))\n\n[1] 4166"
  },
  {
    "objectID": "2018/06/2018-06.html#part-2",
    "href": "2018/06/2018-06.html#part-2",
    "title": "2018-06: Chronal Coordinates",
    "section": "Part 2",
    "text": "Part 2\n\ngrid <- expand.grid(1:size, 1:size)\nsapply(1:nrow(grid), function(i) {\n  dist <- abs(dt$x - grid$Var1[i]) + abs(dt$y - grid$Var2[i])\n  if(sum(dist) < 10000) { return(i) }\n  else { return(NA) }\n}) |> \n  na.exclude() |>\n  length()\n\n[1] 42250"
  },
  {
    "objectID": "2017/01/2017-01.html#part-1",
    "href": "2017/01/2017-01.html#part-1",
    "title": "2017-01: Inverse Captcha",
    "section": "Part 1",
    "text": "Part 1\n\ndata.table(\n  \"input\" = c(dt),\n  \"test\" = c(dt[-1], dt[1])\n) %>%\n  .[, \"valid\" := ifelse(input == test, TRUE, FALSE)] %>%\n  .[valid == TRUE, test] %>%\n  sum()\n\n[1] 1031"
  },
  {
    "objectID": "2017/01/2017-01.html#part-2",
    "href": "2017/01/2017-01.html#part-2",
    "title": "2017-01: Inverse Captcha",
    "section": "Part 2",
    "text": "Part 2\n\nlen <- length(dt) / 2\ndata.table(\n  \"input\" = c(dt),\n  \"test\" = c(dt[(len + 1):length(dt)], dt[1:len])\n) %>%\n  .[, \"valid\" := ifelse(input == test, TRUE, FALSE)] %>%\n  .[valid == TRUE, test] %>%\n  sum()\n\n[1] 1080"
  },
  {
    "objectID": "2017/02/2017-02.html#part-1",
    "href": "2017/02/2017-02.html#part-1",
    "title": "2017-02: Corruption Checksum",
    "section": "Part 1",
    "text": "Part 1\n\ndt %>%\n  rowwise() %>%\n  mutate(\n    \"min\" = min(across()),\n    \"max\" = max(across())\n  ) %>%\n  mutate(\"diff\" = max - min) %>%\n  pull(diff) %>%\n  sum()\n\n[1] 36174"
  },
  {
    "objectID": "2017/02/2017-02.html#part-2",
    "href": "2017/02/2017-02.html#part-2",
    "title": "2017-02: Corruption Checksum",
    "section": "Part 2",
    "text": "Part 2\n\napply(dt, 1, function(x) {\n  expand.grid(x, x) %>%\n    filter(Var1 != Var2) %>%\n    mutate(\"valid\" = ifelse(Var1 %% Var2 == 0, TRUE, FALSE)) %>%\n    filter(valid) %>%\n    mutate(\"val\" = Var1 / Var2) %>%\n    pull(val)\n}) %>%\n  sum()\n\n[1] 244"
  },
  {
    "objectID": "2016/01/2016-01.html#part-1",
    "href": "2016/01/2016-01.html#part-1",
    "title": "2016-01: No Time for a Taxicab",
    "section": "Part 1",
    "text": "Part 1\n\ndt$deg <- 0\nfor(i in 2:nrow(dt)) {\n  if(dt$dir[i] == \"R\") { dt$deg[i] <- dt$deg[i-1] + 90 }\n  else {dt$deg[i] <- dt$deg[i-1] - 90}\n}\ndt |>\n  mutate(deg = deg %% 360, \n         dis = ifelse(deg %in% c(180, 270), -dis, dis)) |>\n  group_by(deg) |>\n  summarise(n = sum(dis)) |>\n  pull(n) |>\n  sum()\n\n[1] 250"
  },
  {
    "objectID": "2016/01/2016-01.html#part-2",
    "href": "2016/01/2016-01.html#part-2",
    "title": "2016-01: No Time for a Taxicab",
    "section": "Part 2",
    "text": "Part 2\n\npoints <- matrix(c(ifelse(dt$dir[1] == \"R\", dt$dis[1], -dt$dis[1]), 0), 1, 2)\nfor (j in 2:nrow(dt)) {\n  tmp <- dt[1:j,]\n  tmp$deg <- 0\n  for (i in 2:j) {\n    if (tmp$dir[i] == \"R\") { tmp$deg[i] <- tmp$deg[i - 1] + 90 }\n    else {  tmp$deg[i] <- tmp$deg[i - 1] - 90 }\n  }\n  tmp |>\n    mutate(deg = deg %% 360,\n           dis = ifelse(deg %in% c(180, 270), -dis, dis)) |>\n    group_by(deg) |>\n      summarise(n = sum(dis)) |>\n      ungroup() |>\n    mutate(deg = ifelse(deg %% 360 %in% c(0, 180), TRUE, FALSE)) |>\n    group_by(deg) |>\n      summarise(n = sum(n)) |>\n      ungroup() |>\n    pull(n) -> point\n  points <- rbind(points, unname(point))\n}\npoints <- rbind(t(c(0, 0)), points)\n\ntmp <- t(c(NA, NA))\n\nfor(i in 1:(nrow(points) - 1)) {\n  tmp <- \n    rbind(tmp, cbind(points[i,1]:points[i+1,1], points[i,2]:points[i+1,2]))\n}\n\nWarning in cbind(points[i, 1]:points[i + 1, 1], points[i, 2]:points[i + : number\nof rows of result is not a multiple of vector length (arg 1)\n\ntmp <- tmp[-1,]\nfor(i in 1:(nrow(tmp) - 1)) {\n  if(all(tmp[i,] == tmp[i+1,])) {\n    tmp[i,] <- t(c(NA, NA))\n  }\n}\ntmp <- na.omit(tmp)\nsum(tmp[duplicated(tmp),][1,])\n\n[1] 151"
  },
  {
    "objectID": "2016/02/2016-02.html#part-1",
    "href": "2016/02/2016-02.html#part-1",
    "title": "2016-02: Bathroom Security",
    "section": "Part 1",
    "text": "Part 1\n\nmat <- matrix(1:9, 3, 3)\n\nstartX <<- 2\nstartY <<- 2\napply(dt, 1, function(x) {\n  sapply(unlist(stri_match_all_regex(x, \"[ULRD]\")), function(y) {\n    if (y == \"U\") { startY <<- startY - 1 }\n    else if (y == \"D\") { startY <<- startY + 1 }\n    else if (y == \"L\") { startX <<- startX - 1 }\n    else { startX <<- startX + 1 }\n    \n    if(startX == 0) { startX <<- 1 }\n    else if (startX == 4) {startX <<- 3}\n    \n    if(startY == 0) { startY <<- 1 }\n    else if (startY == 4) {startY <<- 3}\n  })\n  return(rbind(startX, startY))\n}) |> \n  t() |>\n  apply(1, function(x) {\n    return(mat[x[1], x[2]])\n  }) |>\n  paste0(collapse = \"\")\n\n[1] \"82958\""
  },
  {
    "objectID": "2016/02/2016-02.html#part-2",
    "href": "2016/02/2016-02.html#part-2",
    "title": "2016-02: Bathroom Security",
    "section": "Part 2",
    "text": "Part 2\n\nmat <- as.matrix(fread(\"grid2.csv\", header = FALSE, na.strings = \"\"))\n\nstartX <<- 3\nstartY <<- 1\n\napply(dt, 1, function(x) {\n  sapply(unlist(stri_match_all_regex(x, \"[ULRD]\")), function(y) {\n    if (y == \"L\") { \n      startY <<- startY - 1\n      if (startY == 0 || is.na(mat[startX,startY])) { startY <<- startY + 1 }\n    } else if (y == \"R\") { \n      startY <<- startY + 1 \n      if (startY == 6 || is.na(mat[startX,startY])) { startY <<- startY - 1 }\n    } else if (y == \"U\") { \n      startX <<- startX - 1 \n      if (startX == 0 || is.na(mat[startX,startY])) { startX <<- startX + 1 }\n    } else { \n      startX <<- startX + 1 \n      if (startX == 6 || is.na(mat[startX,startY])) { startX <<- startX - 1 }\n    }\n  })\n  return(rbind(startX, startY))\n}) |> \n  t() |>\n  apply(1, function(x) {\n    return(mat[x[1], x[2]])\n  }) |>\n  paste0(collapse = \"\") |>\n  stri_replace_all_regex(\" \", \"\")\n\n[1] \"B3DB8\""
  },
  {
    "objectID": "2016/03/2016-03.html#part-1",
    "href": "2016/03/2016-03.html#part-1",
    "title": "2016-03: Squares With Three Sides",
    "section": "Part 1",
    "text": "Part 1\n\ndt <- dtM\ndt$valid <- ifelse(dt$a + dt$b > dt$c &\n                     dt$a + dt$c > dt$b &\n                     dt$b + dt$c > dt$a, TRUE, FALSE)\ntable(dt$valid)[\"TRUE\"]\n\nTRUE \n 862"
  },
  {
    "objectID": "2016/03/2016-03.html#part-2",
    "href": "2016/03/2016-03.html#part-2",
    "title": "2016-03: Squares With Three Sides",
    "section": "Part 2",
    "text": "Part 2\n\ndt <- dtM\ndt <- data.table(t(matrix(c(dt$a, dt$b, dt$c), 3, nrow(dt)))) |>\n  `colnames<-`(c(letters[1:3]))\n\ndt$valid <- ifelse(dt$a + dt$b > dt$c & \n                     dt$a + dt$c > dt$b &\n                     dt$b + dt$c > dt$a, TRUE, FALSE)\ntable(dt$valid)[\"TRUE\"]\n\nTRUE \n1577"
  },
  {
    "objectID": "2016/04/2016-04.html#part-1",
    "href": "2016/04/2016-04.html#part-1",
    "title": "2016-04: Security Through Obscurity",
    "section": "Part 1",
    "text": "Part 1\n\nstri_extract_all_regex(dt, \"[a-z]+\") |>\n  lapply(function(x) {\n    x <- paste0(x, collapse = \"\") |>\n      strsplit(\"\") |>\n      unlist()\n    check <- x[(length(x) - 4):length(x)]\n    x <- x[1:(length(x) - 4)]\n    x <- sort(table(x), decreasing = TRUE)[1:5]\n    \n    check <- paste0(check, collapse = \"\")\n    x <- paste0(names(x), collapse = \"\")\n    \n    if(x == check) { return(TRUE) }\n    return(FALSE)\n  }) |>\n  unlist() -> tmp\n\ndt[tmp] |>\n  stri_extract_all_regex(\"[0-9]*\", simplify = TRUE) |>\n  as.numeric() |>\n  sum(na.rm = TRUE)\n\n[1] 361724"
  },
  {
    "objectID": "2016/04/2016-04.html#part-2",
    "href": "2016/04/2016-04.html#part-2",
    "title": "2016-04: Security Through Obscurity",
    "section": "Part 2",
    "text": "Part 2\n\nx <- lapply(dt[tmp], function(x) {\n  x <- unlist(stri_match_all(x , regex = \"(.*)-([0-9]*)\"))\n  y <- as.numeric(x[3])\n  x <- unlist(strsplit(x[2], \"-\"))\n  x <- cipheR::caesar(x[-length(x)], n = y, preset = \"lowercase\")\n  return(paste(x, collapse = \" \"))\n}) |>\n  unlist()\n\nas.numeric(stri_extract(dt[tmp][which(x == \"northpole object\")], \n                        regex = \"([0-9]{3})\"))\n\n[1] 482"
  },
  {
    "objectID": "2015/01/2015-01.html#part-1",
    "href": "2015/01/2015-01.html#part-1",
    "title": "2015-01: Not Quite Lisp",
    "section": "Part 1",
    "text": "Part 1\n\nstr_count(dt, \"\\\\(\") - str_count(dt, \"\\\\)\")\n\n[1] 138"
  },
  {
    "objectID": "2015/01/2015-01.html#part-2",
    "href": "2015/01/2015-01.html#part-2",
    "title": "2015-01: Not Quite Lisp",
    "section": "Part 2",
    "text": "Part 2\n\ndt <- data.frame(\"paren\" = t(str_split_fixed(dt, \"\", nchar(dt))))\ndt$val <- ifelse(dt$paren == \"(\", 1, -1)\nwhich(cumsum(dt$val) == -1)[1]\n\n[1] 1771"
  },
  {
    "objectID": "2015/02/2015-02.html#part-1",
    "href": "2015/02/2015-02.html#part-1",
    "title": "2015-02: I Was Told There Would Be No Math",
    "section": "Part 1",
    "text": "Part 1\n\n# part 1\ntmp <- dt %>%\n  .[, c(\"l\", \"w\", \"h\") := .(V1 * V2, V2 * V3, V1 * V3)] %>%\n  .[, min := ifelse(l <= w & l <= h, l, \n                    ifelse(w <= l & w <= h, w, h))] %>%\n  .[, sq := 2*l + 2*w + 2*h + min]\nsum(tmp$sq, na.rm = TRUE)\n\n[1] 1598415"
  },
  {
    "objectID": "2015/02/2015-02.html#part-2",
    "href": "2015/02/2015-02.html#part-2",
    "title": "2015-02: I Was Told There Would Be No Math",
    "section": "Part 2",
    "text": "Part 2\n\ntmp <- dt %>%\n  .[, c(\"l\", \"w\", \"h\") := .(V1 * V2, V2 * V3, V1 * V3)]\ntmp <- tmp[, c(\"l\", \"w\", \"h\") := .(V1, V2, V3)] %>%\n  .[, max := apply(dt[, .(l, w, h)], 1, max)] %>%\n  rowwise() %>%\n  mutate(test = list(c(l, w, h)))\ntmp$min1 <- t(data.frame(sapply(tmp$test, sort)))[,1]\ntmp$min2 <- t(data.frame(sapply(tmp$test, sort)))[,2]\n\ntmp <- data.table::data.table(tmp)[,rib := ((2*min1 + 2*min2) + (V1 * V2 * V3))]\nsum(tmp$rib, na.rm = TRUE)\n\n[1] 3812909"
  },
  {
    "objectID": "2015/03/2015-03.html#part-1",
    "href": "2015/03/2015-03.html#part-1",
    "title": "2015-03: Perfectly Spherical Houses in a Vacuum",
    "section": "Part 1",
    "text": "Part 1\n\ndirX <- function(x) {\n  case_when(\n    x == \"^\" ~ 0,\n    x == \">\" ~ 1,\n    x == \"<\" ~ -1,\n    x == \"v\" ~ 0\n  )\n}\ndirY <- function(x) {\n  case_when(\n    x == \"^\" ~ 1,\n    x == \">\" ~ 0,\n    x == \"<\" ~ 0,\n    x == \"v\" ~ -1\n  )\n}\n\ndf <- data.frame(\"x\" = 0, \"y\" = 0)\nfor(i in 1:nchar(dt))\n  df <- rbind(df, data.frame(\"x\" = dirX(substr(dt, i, i)),\n                             \"y\" = dirY(substr(dt, i, i))))\ndf <- data.table::data.table(df)\ndf$cumX <- cumsum(df$x)\ndf$cumY <- cumsum(df$y)\ndf <- df[, .(cumX, cumY)]\nnrow(unique(df))\n\n[1] 2565"
  },
  {
    "objectID": "2015/03/2015-03.html#part-2",
    "href": "2015/03/2015-03.html#part-2",
    "title": "2015-03: Perfectly Spherical Houses in a Vacuum",
    "section": "Part 2",
    "text": "Part 2\n\ndfR <- data.frame(\"x\" = 0, \"y\" = 0)\ndfS <- data.frame(\"x\" = 0, \"y\" = 0)\nfor(i in seq(1, nchar(dt), 2))\n  dfS <- rbind(dfS, data.frame(\"x\" = dirX(substr(dt, i, i)),\n                               \"y\" = dirY(substr(dt, i, i))))\nfor(i in seq(2, nchar(dt), 2))\n  dfR <- rbind(dfR, data.frame(\"x\" = dirX(substr(dt, i, i)),\n                               \"y\" = dirY(substr(dt, i, i))))\n\ndts <- data.table::data.table(dfS)\ndts$cumX <- cumsum(dts$x)\ndts$cumY <- cumsum(dts$y)\ndtr <- data.table::data.table(dfR)\ndtr$cumX <- cumsum(dtr$x)\ndtr$cumY <- cumsum(dtr$y)\n\ndf <- data.table::data.table(rbind(dts, dtr))\n\ndf <- df[, .(cumX, cumY)]\nnrow(unique(df))\n\n[1] 2639"
  },
  {
    "objectID": "2015/04/2015-04.html#part-1",
    "href": "2015/04/2015-04.html#part-1",
    "title": "2015-04: The Ideal Stocking Stuffer",
    "section": "Part 1",
    "text": "Part 1\n\ni <- 0\nwhile(substr(digest(paste0(dt, i), algo = \"md5\", serialize = FALSE), 1, 5) != \"00000\")\n  i <- i + 1\ndigest(paste0(dt, i), algo = \"md5\", serialize = FALSE)\n\n[1] \"000004b30d481662b9cb0c105f6549b2\"\n\ni\n\n[1] 254575"
  },
  {
    "objectID": "2015/04/2015-04.html#part-2",
    "href": "2015/04/2015-04.html#part-2",
    "title": "2015-04: The Ideal Stocking Stuffer",
    "section": "Part 2",
    "text": "Part 2\n\ni <- 0\nwhile(substr(digest(paste0(dt, i), algo = \"md5\", serialize = FALSE), 1, 6) != \"000000\")\n  i <- i + 1\ndigest(paste0(dt, i), algo = \"md5\", serialize = FALSE)\n\n[1] \"000000b1b64bf5eb55aad89986126953\"\n\ni\n\n[1] 1038736"
  },
  {
    "objectID": "2015/05/2015-05.html#part-1",
    "href": "2015/05/2015-05.html#part-1",
    "title": "2015-05: Doesn’t He Have Intern-Elves For This?",
    "section": "Part 1",
    "text": "Part 1\n\ndt <- df\ndt <- dt[!grepl(\"(ab)|(cd)|(pq)|(xy)\", dt)]\ndt <- dt[grepl(\"(\\\\w*[aeuio]\\\\w*){3,}\", dt)]\ndt <- dt[grepl(\"(.)\\\\1+\", dt)]\nlength(dt)\n\n[1] 255"
  },
  {
    "objectID": "2015/05/2015-05.html#part-2",
    "href": "2015/05/2015-05.html#part-2",
    "title": "2015-05: Doesn’t He Have Intern-Elves For This?",
    "section": "Part 2",
    "text": "Part 2\n\ndt <- df\ndt <- dt[grepl(\"(..).*(\\\\1)\", dt, perl = TRUE)]\ndt <- dt[grepl(\"(.)(.)(\\\\1)\", dt, perl = TRUE)]\nlength(dt)\n\n[1] 55"
  },
  {
    "objectID": "2015/06/2015-06.html#part-1",
    "href": "2015/06/2015-06.html#part-1",
    "title": "2015-06: Probably a Fire Hazard",
    "section": "Part 1",
    "text": "Part 1\n\ndt <- data.frame(\"dir\" = str_extract(dt, \"off|on|toggle\"),\n                 \"from\" = str_extract(dt, \"[0-9]{1,3},[0-9]{1,3}\"),\n                 \"to\" = str_extract(dt, \"[0-9]{1,3},[0-9]{1,3}$\"))\nfrom <- str_split(dt$from, \",\", simplify = TRUE)\ndt$fromX <- as.numeric(from[,1]) + 1\ndt$fromY <- as.numeric(from[,2]) + 1\n\nto <- str_split(dt$to, \",\", simplify = TRUE)\ndt$toX <- as.numeric(to[,1]) + 1\ndt$toY <- as.numeric(to[,2]) + 1\n\nlights <- data.frame(\"x\" = rep(1:1000, 1000), \n                     \"y\" = rep(1:1000, each = 1000),\n                     \"stat\" = as.integer(0))\n\nfor(i in 1:nrow(dt)) {\n  if(dt$dir[i] == \"on\") {\n    lights$stat[dt$fromX[i] <= lights$x & \n                  dt$toX[i] >= lights$x & \n                  dt$fromY[i] <= lights$y & \n                  dt$toY[i] >= lights$y] <- 1\n  }\n  if(dt$dir[i] == \"off\") {\n    lights$stat[dt$fromX[i] <= lights$x & \n                  dt$toX[i] >= lights$x & \n                  dt$fromY[i] <= lights$y & \n                  dt$toY[i] >= lights$y] <- 0\n  }\n  if(dt$dir[i] == \"toggle\") {\n    lights$stat[dt$fromX[i] <= lights$x & dt$toX[i] >= lights$x & \n                  dt$fromY[i] <= lights$y & dt$toY[i] >= lights$y] <- \n      ifelse(lights$stat[dt$fromX[i] <= lights$x & dt$toX[i] >= lights$x & \n                  dt$fromY[i] <= lights$y & dt$toY[i] >= lights$y] == 1, 0, 1)\n  }\n}\n\nnrow(lights[lights$stat == 1,])\n\n[1] 400410"
  },
  {
    "objectID": "2015/06/2015-06.html#part-2",
    "href": "2015/06/2015-06.html#part-2",
    "title": "2015-06: Probably a Fire Hazard",
    "section": "Part 2",
    "text": "Part 2\n\n# part 2\nlights <- data.frame(\"x\" = rep(1:1000, 1000), \n                     \"y\" = rep(1:1000, each = 1000),\n                     \"stat\" = as.integer(0))\n\nfor(i in 1:nrow(dt)) {\n  if(dt$dir[i] == \"on\") {\n    lights$stat[dt$fromX[i] <= lights$x & \n                  dt$toX[i] >= lights$x & \n                  dt$fromY[i] <= lights$y & \n                  dt$toY[i] >= lights$y] <- lights$stat[dt$fromX[i] <= lights$x & \n                  dt$toX[i] >= lights$x & \n                  dt$fromY[i] <= lights$y & \n                  dt$toY[i] >= lights$y] + 1\n  }\n  if(dt$dir[i] == \"off\") {\n    lights$stat[dt$fromX[i] <= lights$x & dt$toX[i] >= lights$x & \n                  dt$fromY[i] <= lights$y & dt$toY[i] >= lights$y] <- \n      ifelse(lights$stat[dt$fromX[i] <= lights$x & dt$toX[i] >= lights$x & \n                  dt$fromY[i] <= lights$y & dt$toY[i] >= lights$y] == 0, \n             lights$stat[dt$fromX[i] <= lights$x & dt$toX[i] >= lights$x & \n                  dt$fromY[i] <= lights$y & dt$toY[i] >= lights$y], \n             lights$stat[dt$fromX[i] <= lights$x & dt$toX[i] >= lights$x & \n                  dt$fromY[i] <= lights$y & dt$toY[i] >= lights$y] - 1)\n  }\n  if(dt$dir[i] == \"toggle\") {\n    lights$stat[dt$fromX[i] <= lights$x & \n                  dt$toX[i] >= lights$x & \n                  dt$fromY[i] <= lights$y & \n                  dt$toY[i] >= lights$y] <- lights$stat[dt$fromX[i] <= lights$x & \n                  dt$toX[i] >= lights$x & \n                  dt$fromY[i] <= lights$y & \n                  dt$toY[i] >= lights$y] + 2\n  }\n}\n\nsum(lights$stat)\n\n[1] 15343601"
  },
  {
    "objectID": "2015/07/2015-07.html#part-1",
    "href": "2015/07/2015-07.html#part-1",
    "title": "2015-07: Some Assembly Required",
    "section": "Part 1",
    "text": "Part 1\nI initially tried just writing to a file then sourcing it, but quickly discovered that my statements were out of order. I figured a loop would be fast enough, then I can use a tryCatch to skip over any errors, paring down the statements until they all run. I had a bit of trouble with my eval statement until I remembered I have to parse the dang thing first.\n\n(a <- run(dt))\n\n[1] 3176"
  },
  {
    "objectID": "2015/07/2015-07.html#part-2",
    "href": "2015/07/2015-07.html#part-2",
    "title": "2015-07: Some Assembly Required",
    "section": "Part 2",
    "text": "Part 2\nThis bit was easy. Just had to copy to a new object for some reason then it was a simple replacement with the value from part 1.\n\ndt2 <- dt\ndt2[str_detect(dt2, \"-> b$\")] <- glue::glue(\"{a} -> b\")\nrun(dt2)\n\n[1] 14710"
  },
  {
    "objectID": "2015/08/2015-08.html#part-1",
    "href": "2015/08/2015-08.html#part-1",
    "title": "2015-08: Matchsticks",
    "section": "Part 1",
    "text": "Part 1\nGetting the regex right was the worst part, just like I thought. \\\\ is the worst part about R.\n\nliteral_length <- \n  dt |>\n  nchar() |>\n  sum()\n\nmemory_length <-\n  dt |>\n  str_sub(start = 2) |>\n  str_sub(end = -2) |>\n  str_replace_all('\\\\\\\\x[0-9a-f]{2}', ' ') |>\n  str_replace_all('\\\\\\\\\\\\\"', ' ') |>\n  str_replace_all('\\\\\\\\\\\\\\\\', ' ') |>\n  nchar() |>\n  sum()\n\nliteral_length - memory_length\n\n[1] 1371"
  },
  {
    "objectID": "2015/08/2015-08.html#part-2",
    "href": "2015/08/2015-08.html#part-2",
    "title": "2015-08: Matchsticks",
    "section": "Part 2",
    "text": "Part 2\nTurns out R also auto-converts double spaces to tabs so to get two characters, you need three spaces…\n\ntotal_length <-\n  dt |>\n  str_escape() |>\n  str_replace_all('^\"|\"$', '   ') |>\n  str_replace_all('\\\\\\\\x[0-9a-f]{2}', '    ') |>\n  str_replace_all('\\\\\\\\\\\\\"', '   ') |>\n  str_replace_all('\\\\\\\\', ' ') |>\n  nchar() |>\n  sum()\ntotal_length - literal_length\n\n[1] 2117"
  },
  {
    "objectID": "2015/09/2015-09.html#part-1",
    "href": "2015/09/2015-09.html#part-1",
    "title": "2015-09: All in a Single Night",
    "section": "Part 1",
    "text": "Part 1\nI figured with R the way it is, there had to be a package that can solve it. Sure enough, TSP exists. Creating the symmetric matrix was a bit of a pain, but then I was getting solutions for the test input but not the real input. Ugh. I slept on the problem then tried replacing the diagonal with NA, rather than zeroes. That seemed to do the trick.\n\nm <-\n  expand.grid(stops, stops) |>\n  data.table() |>\n  `colnames<-`(c(\"start\", \"end\")) |>\n  left_join(dt, by = c(\"start\", \"end\")) |>\n  mutate(dist = ifelse(start == end, NA_integer_, dist)) |>\n  dcast(start ~ end, value.var = \"dist\") |>\n  data.frame() |>\n  `rownames<-`(stops) |>\n  select(-start) |>\n  as.matrix()\n\nm <-\n  map2_dbl(m, t(m), \\(x, y) {\n    if(is.na(x) & !is.na(y)) return(y) else return(x)\n  }) |>\n  matrix(length(stops), length(stops)) |>\n  `colnames<-`(stops) |>\n  `rownames<-`(stops) |>\n  as.matrix() \n\nstops <- get_stops(m)\n\nWarning: executing %dopar% sequentially: no parallel backend registered\n\nget_dist(m, stops)\n\n[1] 251"
  },
  {
    "objectID": "2015/09/2015-09.html#part-2",
    "href": "2015/09/2015-09.html#part-2",
    "title": "2015-09: All in a Single Night",
    "section": "Part 2",
    "text": "Part 2\nOh boy. I think I have an easy solution for this! If I can re-scale the values so that the smallest numbers are biggest and the biggest numbers are smallest, I can just re-run to get the cities in order, then use the original distances. A quick apply with \\(\\frac{1}{x}\\) and I’m on my way. Just need to throw everything into functions and there we go!\n\nstops <-\n  m |>\n  apply(c(1, 2), \\(x) 1 / x) |>\n  get_stops()\nget_dist(m, stops)\n\n[1] 898"
  },
  {
    "objectID": "2015/10/2015-10.html#part-1",
    "href": "2015/10/2015-10.html#part-1",
    "title": "2015-10: Elves Look, Elves Say",
    "section": "Part 1",
    "text": "Part 1\nI got stuck trying to think of the smart way to do this so I’m brute-forcing it with recursion instead.\n\nexpand <- function(x, max, i = 1) {\n  if (i == (max + 1)) { return(nchar(x)) }\n  x <-\n    x |>\n    strsplit(\"\") |>\n    unlist() |>\n    data.table() |>\n    `colnames<-`(\"input\") |>\n    mutate(group = rleid(input)) |>\n    group_by(group, input) |>\n    summarise(count = n(), .groups = \"drop\") |>\n    mutate(string = glue::glue(\"{count}{input}\")) |>\n    pull(string) |>\n    paste0(collapse = \"\")\n  p()\n  return(expand(x, max, i + 1))\n}\n\ntimes <- 40\nwith_progress({ \n  p <- progressor(steps = times)\n  expand(dt, times) \n})\n\n[1] 252594"
  },
  {
    "objectID": "2015/10/2015-10.html#part-2",
    "href": "2015/10/2015-10.html#part-2",
    "title": "2015-10: Elves Look, Elves Say",
    "section": "Part 2",
    "text": "Part 2\nI thought it was going to be 100 iterations. I can’t believe I’m glad for just 50… But I think I can brute-force this too. I definitely have enough RAM. I just modified the function a bit to take a max iteration input argument as well.\n\ntimes <- 50\nwith_progress({ \n  p <- progressor(steps = times)\n  expand(dt, times) \n})\n\n[1] 3579328"
  },
  {
    "objectID": "2015/11/2015-11.html#part-1",
    "href": "2015/11/2015-11.html#part-1",
    "title": "2015-11: Corporate Policy",
    "section": "Part 1",
    "text": "Part 1\nI struggled for so long with some half-baked quasi-recursive solution that worked on one of the test inputs. I eventually realized that I needed my replacement function to be recursive (I was working with string indexes before) and then it all fell into place. Not my fastest computationally, but it gets the job done.\n\ncheck_consecutive <- function(x) {\n  x <- paste0(x, collapse = \"\")\n  letters |>\n    runner(k = 3, f = paste0, collapse = \"\") |>\n    tail(-2) |>\n    map_lgl(~ str_detect(x, .x)) |>\n    any()\n}\n\ncheck_confusing <- function(x) { !any(c(\"i\", \"o\", \"l\") %in% x) }\n\ncheck_pairs <- function(x) {\n  x <- \n    data.frame(\n      \"a\" = x,\n      \"b\" = lead(x)\n    ) |>\n    filter(a == b) |>\n    group_by(a, b) |>\n    count() |>\n    nrow()\n  return(x >= 2)\n}\n\ncheck <- function(x) {\n  return(\n    check_consecutive(x) & \n    check_confusing(x) &\n    check_pairs(x)\n  )\n}\n\nno_iol <- letters[!(letters %in% c(\"i\", \"o\", \"l\"))]\n\nreplace <- function(x, pos) {\n  l <- which(no_iol == x[pos]) + 1\n  if (l > length(no_iol)) {\n    x[pos] <- \"a\"\n    x <- replace(x, pos - 1)\n  } else {\n    x[pos] <- no_iol[l]\n  }\n  return(x)\n}\n\nsplit_dt <- str_split(dt, \"\")[[1]]\n\nrepeat {\n  if (check(split_dt)) { break }\n  split_dt <- replace(split_dt, length(split_dt))\n}\npaste0(split_dt, collapse = \"\")\n\n[1] \"hxbxxyzz\""
  },
  {
    "objectID": "2015/11/2015-11.html#part-2",
    "href": "2015/11/2015-11.html#part-2",
    "title": "2015-11: Corporate Policy",
    "section": "Part 2",
    "text": "Part 2\nHmmm. I suppose my solution from part 1 wouldn’t work right away. That would be too easy. I could just say that’s no longer a valid solution then it’ll keep going. Kinda dumb but it should work.\nIt’s me. I’m back. It was taking too long. I think I can speed this up just by thinking about it. If xx changes to xy, that whole branch becomes invalid no matter what comes after because it won’t have a sequence available. Same with yy or zz. So that means that b has to increase to c. Here we have some more options. In fact, we have a whole alphabet’s worth. We want to minimize the value so let’s go with a. Same for the next character. Now we only have three spots left and we need to complete our sequence of three letters and get another double. If we do bbc, we don’t have the sequence so we have to do bcc to complete the sequence and get the last double.\n\n\"hxcaabcc\"\n\n[1] \"hxcaabcc\""
  },
  {
    "objectID": "2015/12/2015-12.html#part-1",
    "href": "2015/12/2015-12.html#part-1",
    "title": "2015-12: JSAbacusFramework.io",
    "section": "Part 1",
    "text": "Part 1\nSurprisingly easy. Just had a small regex typo with ? instead of +.\n\ndt |>\n  str_extract_all(\"(-?[0-9]+)\") |>\n  unlist() |>\n  as.numeric() |>\n  sum(na.rm = TRUE)\n\n[1] 191164"
  },
  {
    "objectID": "2015/12/2015-12.html#part-2",
    "href": "2015/12/2015-12.html#part-2",
    "title": "2015-12: JSAbacusFramework.io",
    "section": "Part 2",
    "text": "Part 2\nWhat a nightmare! I got the answer wrong 16 times and tried so many things. String replacement, string reduction, listing, unlisting, whatever I could think of. I eventually remembered rrapply and had a wacky solution that didn’t work at all. I took a break for a few days and really read the documentation on how = \"recurse\". Then it was just a matter of realizing that .xname in the documentation is not the same as names(x) and I was good to go!\n\ndt |>\n  parse_json() |>\n  list() |>\n  rrapply::rrapply(\n    \\(o) { any(o == \"red\") & any(names(o) %in% letters) },\n    \\(x) { return(list(\"a\" = \"red\")) }, \n    how = \"recurse\",\n    classes = \"list\") |>\n  unlist() |>\n  as.numeric() |>\n  suppressWarnings() |>\n  sum(na.rm = TRUE)\n\n[1] 87842"
  }
]