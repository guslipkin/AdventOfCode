[
  {
    "objectID": "2022/14/2022-14.html",
    "href": "2022/14/2022-14.html",
    "title": "Regolith Reservoir",
    "section": "",
    "text": "This doesn’t actually look too terrible.\nlibrary(mistlecode)\ndt &lt;- \n  readLines(\"input.txt\") |&gt;\n  str_split(\" -&gt; \")\nThis was a standalone in Part 1, but I moved it to a function for Part 2.\ncreateCave &lt;- function(maxRow, maxCol) {\n  cave &lt;- matrix(\" \", maxRow, maxCol)\n  \n  for (j in dt) {\n    for (i in 2:length(j)) {\n      x &lt;-\n        str_split(j[i - 1], \",\", simplify = TRUE)[1, ] |&gt;\n        as.numeric()\n      y &lt;-\n        str_split(j[i], \",\", simplify = TRUE)[1, ] |&gt;\n        as.numeric()\n      \n      cave[x[2]:y[2], x[1]:y[1]] &lt;- \"█\"\n    }\n  }\n  return(cave)\n}"
  },
  {
    "objectID": "2022/14/2022-14.html#part-1",
    "href": "2022/14/2022-14.html#part-1",
    "title": "Regolith Reservoir",
    "section": "Part 1",
    "text": "Part 1\nFirst step is always making the matrix way bigger than it needs to be and filling it. Because everything’s a straight line, I can just match the current pair to the next pair and draw a line, essentially. Super easy with matrices. I want to check the bottom row for sand and if there isn’t sand, drop a new one from (1,500) (hooray for R being y,x and non-zero indexed!). Instead of iterating through the whole drop, I can just get the index of the last row in column 500 where there isn’t anything. This saves some computation. If I’m at the bottom, write a piece of sand. From there it’s just iterating over everything just like the instructions say. Lastly, get the amount of sand in the cave then subtract one to account for the last piece of sand that trips the loop.\n\nmaxCol &lt;-\n  dt |&gt;\n  str_extract_all(\"[0-9]{1,3},\") |&gt;\n  suppressWarnings() |&gt;\n  unlist() |&gt;\n  str_remove_all(\",\") |&gt;\n  as.numeric() |&gt;\n  max()\ncave &lt;- createCave(maxCol, maxCol)\nwhile(!any(cave[nrow(cave),] == \"o\")) {\n  col &lt;- 500\n  row &lt;- which(cave[,col] != \" \")[1] - 1\n  breakFlag &lt;- FALSE\n  repeat {\n    if (row + 1 &gt; nrow(cave)) { breakFlag &lt;- TRUE }\n    else {\n      if (cave[row + 1, col] == \" \") {\n        row &lt;- row + 1\n      } else if (col &gt;= 2 & cave[row + 1, col - 1] == \" \") {\n        row &lt;- row + 1; col &lt;- col - 1\n      } else if (col &lt; ncol(cave) & cave[row + 1, col + 1] == \" \") {\n        row &lt;- row + 1; col &lt;- col + 1\n      } else { breakFlag &lt;- TRUE }\n    }\n    if (breakFlag) {\n      cave[row, col] &lt;- \"o\"\n      break\n    }\n  }\n}\nwhich(cave == \"o\") |&gt;\n  length() |&gt;\n  sum(-1)\n\n[1] 961\n\n\n\nmatrix_to_coords(cave) |&gt;\n  data.frame() |&gt;\n  filter(data != \" \") |&gt;\n  mutate(row = as.integer(row), col = as.integer(col)) |&gt;\n  filter(row &lt;= 200) |&gt;\n  ggplot() +\n  geom_tile(aes(x = col, y = -row, fill = data))"
  },
  {
    "objectID": "2022/14/2022-14.html#part-2",
    "href": "2022/14/2022-14.html#part-2",
    "title": "Regolith Reservoir",
    "section": "Part 2",
    "text": "Part 2\nOkay. I need to get the highest row, I can’t just make a massive matrix. Then add another row on top of where everything was drawn that will capture the top of the pyramid. Also, make a new column placeholder that can be added if I need to expand to the left or right. Because of that, I also need to track where column 500 is. If I’m going to have a column collision, I need to expand in that direction. Then, it’s business as usual, but now I’m checking to see if that original start point is full, no matter where it is. Lastly, don’t subtract one because the top grain does count now.\n\nmaxRow &lt;-\n  dt |&gt;\n  str_extract_all(\",[0-9]{1,3}\") |&gt;\n  suppressWarnings() |&gt;\n  unlist() |&gt;\n  str_remove_all(\",\") |&gt;\n  as.numeric() |&gt;\n  max()\ncave &lt;- createCave(maxRow + 1, maxCol)\ncave &lt;- rbind(matrix(\" \", 1, ncol(cave)), cave)\nnewCol &lt;- matrix(\" \", nrow(cave), 1)\nstartCol &lt;- 500\nwhile (cave[1,startCol] != \"o\") {\n  col &lt;- startCol\n  row &lt;- which(cave[,col] != \" \")[1] - 1\n  breakFlag &lt;- FALSE\n  repeat {\n    if (col == 2) { \n      cave &lt;- cbind(newCol, cave)\n      startCol &lt;- startCol + 1\n    } else if (col == ncol(cave) - 1) { cave &lt;- cbind(cave, newCol) }\n    \n    if (row + 1 &gt; nrow(cave)) { \n      breakFlag &lt;- TRUE \n    } else {\n      if (cave[row + 1, col] == \" \") {\n        row &lt;- row + 1\n      } else if (col &gt;= 2 & cave[row + 1, col - 1] == \" \") {\n        row &lt;- row + 1; col &lt;- col - 1\n      } else if (col &lt; ncol(cave) & cave[row + 1, col + 1] == \" \") {\n        row &lt;- row + 1; col &lt;- col + 1\n      } else { breakFlag &lt;- TRUE }\n    }\n    if (breakFlag) {\n      cave[row, col] &lt;- \"o\"\n      break\n    }\n  }\n}\nwhich(cave == \"o\") |&gt;\n  length()\n\n[1] 26375\n\n\n\nmatrix_to_coords(cave) |&gt;\n  data.frame() |&gt;\n  filter(data != \" \") |&gt;\n  mutate(row = as.integer(row), col = as.integer(col)) |&gt;\n  filter(row &lt;= maxRow) |&gt;\n  ggplot() +\n  geom_tile(aes(x = col, y = -row, fill = data))"
  },
  {
    "objectID": "2024/14/2024-14.html",
    "href": "2024/14/2024-14.html",
    "title": "Restroom Redoubt",
    "section": "",
    "text": "library(mistlecode)\n\noptions(scipen = 999)\nmdt &lt;-\n  'input.txt' |&gt;\n  readLines() |&gt;\n  stringr::str_match_all('-?\\\\d+') |&gt;\n  purrr::map(\\(x) {\n    x &lt;- as.integer(x)\n    list(\n      'p' = c(x[1], x[2]) + 1, # row,col\n      'v' = c(x[3], x[4])\n    )\n  })"
  },
  {
    "objectID": "2024/14/2024-14.html#part-1",
    "href": "2024/14/2024-14.html#part-1",
    "title": "Restroom Redoubt",
    "section": "Part 1",
    "text": "Part 1\nWhen I was almost done I realized I could’ve just multiplied the vectors by 100 then not needed a loop. Oh well. Easy enough.\n\nm &lt;- matrix(list(), nrow = 103, ncol = 101)\ndt &lt;- mdt\nfor(i in 1:100) {\n  dt &lt;- purrr::map(dt, \\(x) {\n      p &lt;- x$p + x$v\n      p[1] &lt;- p[1] %% ncol(m); if (p[1] == 0) p[1] &lt;- ncol(m);\n      p[2] &lt;- p[2] %% nrow(m); if (p[2] == 0) p[2] &lt;- nrow(m);\n      list('p' = p, 'v' = x$v)\n    })\n}\n\np &lt;-\n  dt |&gt;\n  purrr::map(\\(x) x$p |&gt; matrix(ncol = 2) |&gt; as.data.frame()) |&gt;\n  purrr::list_rbind() |&gt;\n  setNames(c('col', 'row')) |&gt;\n  dplyr::select('row', 'col')\n\nmid_row &lt;- ceiling(nrow(m) / 2); mid_col &lt;- ceiling(ncol(m) / 2);\none &lt;- p[p$row &lt; mid_row & p$col &lt; mid_col,] |&gt; nrow()\ntwo &lt;- p[p$row &lt; mid_row & p$col &gt; mid_col,] |&gt; nrow()\nthree &lt;- p[p$row &gt; mid_row & p$col &lt; mid_col,] |&gt; nrow()\nfour &lt;- p[p$row &gt; mid_row & p$col &gt; mid_col,] |&gt; nrow()\nprod(one, two, three, four)\n\n[1] 228421332"
  },
  {
    "objectID": "2024/14/2024-14.html#part-2",
    "href": "2024/14/2024-14.html#part-2",
    "title": "Restroom Redoubt",
    "section": "Part 2",
    "text": "Part 2\nUgh. mistlecode::coords_to_matrix() isn’t working. I guess I’ll use {ggplot}. Figuring out how to identify the tree was annoying. I tried clicking through the first 500 iterations with {ggplot} but that wasn’t going anywhere. I took a bit but I figured that the tree would probably have either high or low density in terms of points vs white space. Took a gander and just ran a loop until the initial state was repeated then checked the max and min densities. Sure enough. Max density it was.\n\nm &lt;- matrix(list(), nrow = 103, ncol = 101)\nfilled &lt;- c(Inf, 0); which_filled &lt;- c(0, 0)\n\n\ndt1 &lt;- purrr::map(mdt, \\(x) {\n      p &lt;- x$p + x$v\n      p[1] &lt;- p[1] %% ncol(m); if (p[1] == 0) p[1] &lt;- ncol(m);\n      p[2] &lt;- p[2] %% nrow(m); if (p[2] == 0) p[2] &lt;- nrow(m);\n      list('p' = p, 'v' = x$v)\n    })\ni &lt;- 2\nrepeat {\n  dt &lt;- purrr::map(mdt, \\(x) {\n      p &lt;- x$p + (x$v * i)\n      p[1] &lt;- p[1] %% ncol(m); if (p[1] == 0) p[1] &lt;- ncol(m);\n      p[2] &lt;- p[2] %% nrow(m); if (p[2] == 0) p[2] &lt;- nrow(m);\n      list('p' = p, 'v' = x$v)\n    })\n  if (identical(dt, dt1)) break\n  dt &lt;-\n    dt |&gt;\n    purrr::map(\\(x) x$p |&gt; matrix(ncol = 2) |&gt; as.data.frame()) |&gt;\n    purrr::list_rbind() |&gt;\n    setNames(c('col', 'row'))\n  f &lt;- nrow(unique(dt)) / prod(dim(m))\n  if (f &lt; filled[1]) {\n    filled[1] &lt;- f \n    which_filled[1] &lt;- i\n  } else if (f &gt; filled[2]) {\n    filled[2] &lt;- f\n    which_filled[2] &lt;- i\n  }\n  i &lt;- i + 1\n}\n\n\npurrr::map(1:2, \\(i) {\n  dt &lt;- purrr::map(mdt, \\(x) {\n      p &lt;- x$p + (x$v * which_filled[i])\n      p[1] &lt;- p[1] %% ncol(m); if (p[1] == 0) p[1] &lt;- ncol(m);\n      p[2] &lt;- p[2] %% nrow(m); if (p[2] == 0) p[2] &lt;- nrow(m);\n      list('p' = p, 'v' = x$v)\n    })\n  dt |&gt;\n    purrr::map(\\(x) x$p |&gt; matrix(ncol = 2) |&gt; as.data.frame()) |&gt;\n    purrr::list_rbind() |&gt;\n    setNames(c('col', 'row')) |&gt;\n    ggplot2::ggplot() +\n    ggplot2::geom_point(ggplot2::aes(x = col, y = -row)) +\n    ggplot2::theme_void()\n})\n\n[[1]]\n\n\n\n\n\n\n\n\n\n[[2]]\n\n\n\n\n\n\n\n\n\nwhich_filled[2]\n\n[1] 7790"
  },
  {
    "objectID": "2022/06/2022-06.html",
    "href": "2022/06/2022-06.html",
    "title": "Tuning Trouble",
    "section": "",
    "text": "library(tidyverse)\nlibrary(data.table)\nlibrary(mistlecode)\ndt &lt;- \n  'input.txt' |&gt; \n  readLines() |&gt; \n  strsplit('') |&gt; \n  unlist()\nThis looks easy. Oh wait. I totally misread the problem…\ndo_part &lt;- function(part) {\n  part &lt;- part - 1\n  get_vec &lt;- function(vec, place) {\n    if (place == 0) { return(vec)}\n    c(vec[-1:(-place)], rep(NA, place))\n  }\n  \n  lapply(0:part, function(x) {\n    get_vec(dt, x)\n  }) |&gt;\n    data.frame() |&gt;\n    `colnames&lt;-`(paste0(\"X\", 1:part)) %&gt;%\n    apply(1, function(x) {\n      paste0(x, collapse = \"\")\n    }) |&gt;\n    sapply(function(x) {\n      max(table(strsplit(x, \"\")))\n    }) -&gt; tmp\n  (which(tmp == 1) + part)[1]\n}"
  },
  {
    "objectID": "2022/06/2022-06.html#part-1",
    "href": "2022/06/2022-06.html#part-1",
    "title": "Tuning Trouble",
    "section": "Part 1",
    "text": "Part 1\nHardcoding everything will bite me in the butt later probably. Ultimately not too bad in hindsight.\n\n\nNew\nOriginal\n\n\n\n\ndo_part(4)\n\nbdjq \n1578 \n\n\n\n\n\ndata.frame(\"w\" = dt,\n           \"x\" = c(dt[-1], NA),\n           \"y\" = c(dt[-1:-2], NA, NA),\n           \"z\" = c(dt[-1:-3], NA, NA, NA)) |&gt;\n  mutate(marker = paste0(w, x, y, z, sep = \"\")) |&gt;\n  apply(1, function(x) {\n    max(table(strsplit(x[\"marker\"], \"\")))\n  }) -&gt; tmp\n(which(tmp == 1) + 3)[1]\n\n[1] 1578"
  },
  {
    "objectID": "2022/06/2022-06.html#part-2",
    "href": "2022/06/2022-06.html#part-2",
    "title": "Tuning Trouble",
    "section": "Part 2",
    "text": "Part 2\nWell, well, well. Hardcoding is never a good move. Took a bit of time to get it figured out, but I got there in the end.\n\n\nNew\nOriginal\n\n\n\n\ndo_part(14)\n\nmdcbnwqgshpvfj \n          2178 \n\n\n\n\n\nget_vec &lt;- function(vec, place) {\n  if (place == 0) { return(vec) }\n  c(vec[-1:(-place)], rep(NA, place))\n}\n\nlapply(0:13, function(x) {\n  get_vec(dt, x)\n}) |&gt;\n  data.frame() |&gt;\n  `colnames&lt;-`(paste0(\"X\", 1:14)) %&gt;%\n  apply(1, function(x) {\n    paste0(x, collapse = \"\")\n  }) |&gt;\n  sapply(function(x) {\n    max(table(strsplit(x, \"\")))\n  }) -&gt; tmp\n(which(tmp == 1) + 13)[1]\n\nmdcbnwqgshpvfj \n          2178"
  },
  {
    "objectID": "2024/06/2024-06.html",
    "href": "2024/06/2024-06.html",
    "title": "Guard Gallivant",
    "section": "",
    "text": "library(mistlecode)\n\noptions(scipen = 999)\nmat &lt;- \n  'input.txt' |&gt;\n  mistlecode::read_matrix()"
  },
  {
    "objectID": "2024/06/2024-06.html#part-1",
    "href": "2024/06/2024-06.html#part-1",
    "title": "Guard Gallivant",
    "section": "Part 1",
    "text": "Part 1\nThis wasn’t too bad. I’d been working on the adjacency function earlier trying to figure out an A* method for older puzzles. Just had to trim some fat and it was good enough. For some reason I struggled with getting the break to happen. Initially I just relied on the mat[y,x] reference to fail and that’s how I submitted, but it’s not a good look so I fixed it.\n\nadjacent &lt;- function(point) {\n  y &lt;- point[1]; x &lt;- point[2];\n  list(\n    'up' = c(y-1,x),\n    'down' = c(y+1,x),\n    'left' = c(y,x-1),\n    'right' = c(y,x+1)\n  )\n}\n\n\nguy &lt;- which(mat == '^', arr.ind = TRUE)[1,] |&gt; unname()\nrotate &lt;- c('up' = 'right', 'right' = 'down', 'down' = 'left', 'left' = 'up')\n\ndir &lt;- 'up'\nstep &lt;- 0\nvisited &lt;- matrix(FALSE, nrow(mat), ncol(mat))\nrepeat {\n  visited[guy[1], guy[2]] &lt;- TRUE\n  n &lt;- adjacent(guy)[[dir]]\n  if (!dplyr::between(n[1], 1, nrow(mat)) | !dplyr::between(n[2], 1, ncol(mat))) break\n  if (mat[n[1], n[2]] != '#') guy &lt;- n else dir &lt;- rotate[dir]\n  step &lt;- step + 1\n}\nsum(visited)\n\n[1] 4696"
  },
  {
    "objectID": "2024/06/2024-06.html#part-2",
    "href": "2024/06/2024-06.html#part-2",
    "title": "Guard Gallivant",
    "section": "Part 2",
    "text": "Part 2\nIt’s never a good sign when you resort to future… But also, I figured a path can’t cross itself more than five times without being in a loop. Before figuring that out, my estimated run time on a single core was 6-8 hours.\nThe next day…I realized the magic number is four since that’s the number of unique directions you can approach a node from.\n\ntictoc::tic()\nstart &lt;- which(mat == '^', arr.ind = TRUE)[1,] |&gt; unname()\ncores &lt;- future::availableCores()\nfuture::plan(future::multisession, workers = cores)\nprogressr::with_progress({\n  df &lt;-\n    visited |&gt; \n    mistlecode::matrix_to_coords() |&gt; \n    dplyr::filter(.data$data) |&gt;\n    dplyr::select(-'data')\n  p &lt;- progressr::progressor(steps = nrow(df))\n  df |&gt;\n  furrr::future_pmap_lgl(\\(row, col) {\n    p()\n    cells &lt;- matrix(0, nrow(mat), ncol(mat))\n    dmat &lt;- mat; dmat[row,col] &lt;- '#';\n    guy &lt;- start; dir &lt;- 'up'; step &lt;- 0;\n    repeat {\n      n &lt;- adjacent(guy)[[dir]]\n      if (n[1] &lt; 1 || n[1] &gt; nrow(dmat) || n[2] &lt; 1 || n[2] &gt; ncol(dmat)) return(FALSE)\n      if (dmat[n[1], n[2]] != '#') {\n        cells[n[1], n[2]] &lt;- cells[n[1], n[2]] + 1\n        guy &lt;- n\n      } else dir &lt;- rotate[dir]\n      step &lt;- step + 1\n      if (any(cells &gt; 4)) return(TRUE)\n    }\n  }) |&gt;\n  sum()\n}, handlers = progressr::handler_cli())\n\n[1] 1443\n\nfuture::plan(future::sequential())\nglue::glue('Finished with {tictoc::toc()$callback_msg} using {cores} cores')\n\n165.983 sec elapsed\n\n\nFinished with 165.983 sec elapsed using 6 cores"
  },
  {
    "objectID": "2022/20/2022-20.html",
    "href": "2022/20/2022-20.html",
    "title": "Grove Positioning System",
    "section": "",
    "text": "This looks too good to be true!\nlibrary(mistlecode)\noptions(scipen = 999)\ndt &lt;- \n  readLines(\"input.txt\") |&gt;\n  as.numeric()"
  },
  {
    "objectID": "2022/20/2022-20.html#part-1",
    "href": "2022/20/2022-20.html#part-1",
    "title": "Grove Positioning System",
    "section": "Part 1",
    "text": "Part 1\nPretty straightforward, all things considered. Getting vectors to wrap is always a pain. I also missed the bit about the numbers being after zero, but a quick which took care of that.\n\npos &lt;- 1:length(dt)\n\nshift &lt;- function(pos, x, shift) {\n  if (x == 0) { return(pos) }\n  p &lt;- which(pos == x)\n  pos &lt;- pos[-p]\n  after &lt;- (p - 1 + shift) %% length(pos)\n  after &lt;- ifelse(after == 0, length(pos), after)\n  append(pos, x, after = after)\n}\n\nfor(i in 1:length(dt)) { pos &lt;- shift(pos, i, dt[i]) }\n\nget_sum &lt;- function(dt, pos) {\n  zero &lt;- which(dt[pos] == 0)\n  sapply(c(1e3, 2e3, 3e3), \\(x) {\n    x &lt;- (x + zero) %% length(pos)\n    x &lt;- ifelse(x == 0, length(pos), x)\n    dt[pos[x]]\n  }) |&gt;\n    sum()\n}\n\nget_sum(dt, pos)\n\n[1] 4151"
  },
  {
    "objectID": "2022/20/2022-20.html#part-2",
    "href": "2022/20/2022-20.html#part-2",
    "title": "Grove Positioning System",
    "section": "Part 2",
    "text": "Part 2\nBasically the same as Part 1. I was blessed with no integer overflows so that’s nice. Just multiply the vector by a constant, nest the for loop, then get the sum using the function from Part 1.\n\nkey &lt;- 811589153\ndt2 &lt;- dt * key\npos2 &lt;- 1:length(dt)\n\nfor(j in 1:10) {\n  for (i in 1:length(dt2)) { pos2 &lt;- shift(pos2, i, dt2[i]) }\n}\n\nget_sum(dt2, pos2)\n\n[1] 7848878698663"
  },
  {
    "objectID": "2022/10/2022-10.html",
    "href": "2022/10/2022-10.html",
    "title": "Cathode-Ray Tube",
    "section": "",
    "text": "library(mistlecode)\ndt &lt;-\n  readLines(\"input.txt\") |&gt;\n  str_split(\" \", simplify = TRUE) |&gt;\n  unlist(recursive = FALSE) |&gt;\n  data.frame() |&gt;\n  mutate(X2 = as.numeric(X2))\nOh. This looks a lot like last year’s day one."
  },
  {
    "objectID": "2022/10/2022-10.html#part-1",
    "href": "2022/10/2022-10.html#part-1",
    "title": "Cathode-Ray Tube",
    "section": "Part 1",
    "text": "Part 1\nPart 1 wasn’t too bad. I was a really big dummy and forgot to download the test input then was trying to check my real input as the test input which didn’t work. Other than that, I’m really happy I got to use mistlecode::expand_directions which I only wrote a few hours prior. I did have to make some live modifications, but nothing crazy. Once everything was mostly right, I had a problem where the first five signals were correct, but the last wasn’t. I eventually realized that I needed to lead the add values and that got everything sorted.\n\ndt &lt;-\n  dt |&gt;\n  mutate(\"mag\" = ifelse(X1 == \"noop\", 1, 2)) |&gt;\n  select(\"dir\" = \"X1\", \"mag\", \"X2\") |&gt;\n  mutate(ins = row_number()) |&gt;\n  expand_directions(preserve_data = TRUE) |&gt;\n  data.table()\n\ndt$dup = duplicated(dt$ins, fromLast = TRUE)\ndt$X2 = ifelse(dt$dup, NA, dt$X2)\n\ndt$X3 &lt;- lead(dt$X2, 1)\n\nsapply(c(20, 60, 100, 140, 180, 220), \\(x) {\n  sum(1, sum(dt[1:x, \"X3\"], na.rm = TRUE)) * x\n}) |&gt;\n  sum()\n\n[1] 14260"
  },
  {
    "objectID": "2022/10/2022-10.html#part-2",
    "href": "2022/10/2022-10.html#part-2",
    "title": "Cathode-Ray Tube",
    "section": "Part 2",
    "text": "Part 2\nThis was an absolute mess. I didn’t understand the question at all and still don’t really get it. The difference between what I had and what I thought I should have made the solution relatively clear, but only after struggling with it for hours. I do like ggplot-able solutions though. Those are always nice.\n\nm &lt;- matrix(\" \", 6, 40)\n\ndt$X2 &lt;- ifelse(is.na(dt$X2), 0, dt$X2)\ndt$cumsum &lt;- sapply(1:240, \\(x) { sum(1, sum(dt[1:x, \"X2\"], na.rm = TRUE)) })\n\nm &lt;-\n  sapply(1:240, \\(x) {\n    forty &lt;- (x %/% 40)\n    cumsum &lt;- c(dt$cumsum[x] - 1, dt$cumsum[x], dt$cumsum[x] + 1)\n    sprite_pos &lt;- cumsum[!is.na(cumsum)]\n    if (any((sprite_pos + (40 * forty)) == x)) {\n      sprite_pos &lt;- suppressWarnings(min(which(sprite_pos == x), na.rm = TRUE))\n      if (sprite_pos == 1) { sprite_pos &lt;- cumsum[1] }\n      else if (sprite_pos == 3) { sprite_pos &lt;- cumsum[3] }\n      else { sprite_pos &lt;- cumsum[2] }\n      return(sprite_pos + (40 * forty))\n    }\n    return(NA)\n  })\n\nm[240] &lt;- 0\n\nmatrix_to_coords(matrix(m, 6, 40, byrow = TRUE)) |&gt;\n  data.frame() |&gt;\n  filter(!is.na(data)) |&gt;\n  mutate(col = ifelse(col == 40, 0, col)) |&gt;\n  ggplot() +\n  geom_point(aes(x = col, y = -row), size = 5, shape = 15) +\n  coord_fixed()"
  },
  {
    "objectID": "2022/08/2022-08.html",
    "href": "2022/08/2022-08.html",
    "title": "Treetop Tree House",
    "section": "",
    "text": "library(mistlecode)\ndt &lt;- fread(\"input.txt\", header = FALSE)\nOh no. I always do hate grid based ones."
  },
  {
    "objectID": "2022/08/2022-08.html#part-1",
    "href": "2022/08/2022-08.html#part-1",
    "title": "Treetop Tree House",
    "section": "Part 1",
    "text": "Part 1\nThis was a weird one. I’m writing this the day after I wrote the code, and I have no clue what my thought process was. I did it reasonably quickly so I’m not too unhappy with it.\n\nmm &lt;- \n  dt |&gt;\n  as.matrix() |&gt;\n  as.character() |&gt;\n  str_split(\"\", simplify = TRUE) |&gt;\n  apply(c(1, 2), as.numeric)\n\ngrid &lt;- expand.grid(\"col\" = 1:ncol(mm), \"row\" = 1:nrow(mm))\n\nm &lt;-\n  mapply(\\(x, y) {\n    tree &lt;- mm[y, x]\n    \n    if (x == 1 | x == ncol(mm) | y == 1 | y == nrow(mm)) { return(c(x, y)) }\n    \n    if (all(mm[(y + 1):nrow(mm), x] &lt; tree, na.rm = TRUE) |\n        all(mm[1:(y - 1), x] &lt; tree, na.rm = TRUE) |\n        all(mm[y, 1:(x - 1)] &lt; tree, na.rm = TRUE) |\n        all(mm[y, (x + 1):ncol(mm)] &lt; tree, na.rm = TRUE)) {\n      return(c(x, y))\n    }\n  }, grid$col, grid$row)\n\nm[!sapply(m, is.null)] %&gt;%\n  do.call(rbind, .) |&gt;\n  data.frame() |&gt;\n  `colnames&lt;-`(c(\"col\", \"row\")) -&gt; mi\nnrow(mi)\n\n[1] 1717"
  },
  {
    "objectID": "2022/08/2022-08.html#part-2",
    "href": "2022/08/2022-08.html#part-2",
    "title": "Treetop Tree House",
    "section": "Part 2",
    "text": "Part 2\nThis was a mess. I kept trying to be smart about it and wasted so much time. I mostly had trouble working with patterns like [5050] where the first five can see both the zero and the second five, but not the second zero. This meant that x &lt; 5 ignored the five, and x &lt;= 5 would keep going and read over the remaining zero. Even though I ended up hard-coding everything, I’m rather pleased with how neat it is. I’m sure I could move more of it to functions, but it wouldn’t be too much prettier, if any.\n\nscenic &lt;- matrix(NA, nrow(mm), ncol(mm))\n\nchecker &lt;- function(vec, i, tree, dir) {\n  vec &lt;- detect_index(vec, \\(.x) { .x &gt;= tree }) \n  if (dir == -1) { vec &lt;- ifelse(vec == 0, i - 1, vec) }\n  else { vec &lt;- ifelse(vec == 0, ncol(mm) - i, vec) }\n  vec\n}\n\nmapply(\\(y, x) {\n  tree &lt;- mm[y, x]\n  up &lt;- NA; down &lt;- NA; left &lt;- NA; right &lt;- NA\n  if (y == 1) { up &lt;- 0 }; if (y == nrow(mm)) { down &lt;- 0 }\n  if (x == 1) { left &lt;- 0}; if (x == ncol(mm)) { right &lt;- 0 }\n  \n  rowMin &lt;- ifelse(y - 1 &lt; 1, 1, y - 1); rowMax &lt;- ifelse(y + 1 &gt; nrow(mm), nrow(mm), y + 1)\n  colMin &lt;- ifelse(x - 1 &lt; 1, 1, x - 1); colMax &lt;- ifelse(x + 1 &gt; ncol(mm), ncol(mm), x + 1)\n  \n  yMin &lt;- ifelse(y - 1 &lt; 1, 1, y - 1); yMax &lt;- ifelse(y + 1 &gt; nrow(mm), nrow(mm), y + 1)\n  xMin &lt;- ifelse(x - 1 &lt; 1, 1, x - 1); xMax &lt;- ifelse(x + 1 &gt; ncol(mm), ncol(mm), x + 1)\n  \n  if (is.na(up)) { up &lt;- checker(rev(mm[1:yMin, x]), y, tree, -1) }\n  if (is.na(left)) { left &lt;- checker(rev(mm[y, 1:xMin]), x, tree, -1) }\n  if (is.na(right)) { right &lt;- checker(mm[y, xMax:ncol(mm)], x, tree, 1) }\n  if (is.na(down)) { down &lt;- checker(mm[rowMax:nrow(mm), x], y, tree, 1) }\n  \n  scene &lt;- c(up, left, right, down)\n  scenic[y, x] &lt;&lt;- prod(scene[scene != 0])\n}, grid$row, grid$col) |&gt; invisible()\nmax(scenic)\n\n[1] 321975"
  },
  {
    "objectID": "2023/13/2023-13.html",
    "href": "2023/13/2023-13.html",
    "title": "Point of Incidence",
    "section": "",
    "text": "library(mistlecode)\n\noptions(scipen = 999)\ndt &lt;-\n  readLines(\"input.txt\") |&gt;\n  tibble::as_tibble() |&gt;\n  dplyr::mutate(group = cumsum(value == \"\")) |&gt;\n  dplyr::filter(value != \"\") |&gt;\n  dplyr::group_split(group) |&gt;\n  purrr::map(\\(x) {\n    x |&gt;\n      dplyr::pull(value) |&gt;\n      stringr::str_split(\"\", simplify = TRUE)\n  })"
  },
  {
    "objectID": "2023/13/2023-13.html#part-1",
    "href": "2023/13/2023-13.html#part-1",
    "title": "Point of Incidence",
    "section": "Part 1",
    "text": "Part 1\nOkay okay. Not too bad. Just need to make sure I get the line of reflection right.\n\nget_up_down &lt;- function(up, down) {\n  l &lt;- min(c(length(up), length(down)))\n  up &lt;- rev(rev(up)[seq_len(l)]); down &lt;- down[rev(seq_len(l))];\n  list('up' = up, 'down' = down)\n}\nget_seq &lt;- function(s) { s |&gt; seq_len() |&gt; head(-1) }\ncheck_row &lt;- function(x) {\n  x |&gt;\n    nrow() |&gt;\n    get_seq() |&gt;\n    purrr::map_int(\\(r) {\n      up &lt;- seq_len(r); down &lt;- min(c(r+1,nrow(x))):nrow(x)\n      updown &lt;- get_up_down(up, down)\n      up &lt;- x[updown$up,]; down &lt;- x[updown$down,];\n      if (all(up == down)) r * 100 else 0\n    })\n}\ncheck_col &lt;- function(x) {\n  x |&gt;\n    ncol() |&gt;\n    get_seq() |&gt;\n    purrr::map_int(\\(r) {\n      up &lt;- seq_len(r); down &lt;- min(c(r+1,ncol(x))):ncol(x)\n      updown &lt;- get_up_down(up, down)\n      up &lt;- x[,updown$up]; down &lt;- x[,updown$down];\n      if (all(up == down)) r else 0\n    })\n}\ndt |&gt;\n  purrr::map(\\(x) {\n    c(check_row(x), check_col(x))\n  }) |&gt;\n  unlist() |&gt;\n  sum()\n\n[1] 37718"
  },
  {
    "objectID": "2023/13/2023-13.html#part-2",
    "href": "2023/13/2023-13.html#part-2",
    "title": "Point of Incidence",
    "section": "Part 2",
    "text": "Part 2\nomg. This is gonna be easy. I just need to check if all but one are equal instead of all. I got this in well under two minutes!\n\ncheck_row &lt;- function(x) {\n  x |&gt;\n    nrow() |&gt;\n    get_seq() |&gt;\n    purrr::map_int(\\(r) {\n      up &lt;- seq_len(r); down &lt;- min(c(r+1,nrow(x))):nrow(x)\n      updown &lt;- get_up_down(up, down)\n      up &lt;- x[updown$up,]; down &lt;- x[updown$down,];\n      if (sum(up == down) == length(up) - 1) r * 100 else 0\n    })\n}\ncheck_col &lt;- function(x) {\n  x |&gt;\n    ncol() |&gt;\n    get_seq() |&gt;\n    purrr::map_int(\\(r) {\n      up &lt;- seq_len(r); down &lt;- min(c(r+1,ncol(x))):ncol(x)\n      updown &lt;- get_up_down(up, down)\n      up &lt;- x[,updown$up]; down &lt;- x[,updown$down];\n      if (sum(up == down) == length(up) - 1) r else 0\n    })\n}\ndt |&gt;\n  purrr::map(\\(x) {\n    c(check_row(x), check_col(x))\n  }) |&gt;\n  unlist() |&gt;\n  sum()\n\n[1] 40995"
  },
  {
    "objectID": "2023/07/2023-07.html",
    "href": "2023/07/2023-07.html",
    "title": "Camel Cards",
    "section": "",
    "text": "library(mistlecode)\n\noptions(scipen = 999)\ndt &lt;-\n  readLines('input.txt') |&gt;\n  stringr::str_split(' ') |&gt;\n  unlist() |&gt;\n  matrix(ncol = 2, byrow = TRUE) |&gt;\n  `colnames&lt;-`(c('cards', 'bet')) |&gt;\n  tibble::as_tibble()"
  },
  {
    "objectID": "2023/07/2023-07.html#part-1",
    "href": "2023/07/2023-07.html#part-1",
    "title": "Camel Cards",
    "section": "Part 1",
    "text": "Part 1\nThis wasn’t too bad, but I originally used a dplyr::case_when instead of my if...else chain and because dplyr::case_when is vectorized, that wouldn’t work. However, when I swapped to my if...else chain, I accidentally marked three of a kind as the same value as a full house. Quite annoying, but an easy fix.\n\nrank &lt;- c('A', 'K', 'Q', 'J', 'T', 9:2) |&gt; rev()\ndt |&gt;\n  dplyr::mutate(\n    '.nest' = purrr::map(.data$cards, \\(x) {\n      # x &lt;- 'QJJQ2'\n      h &lt;-\n        x |&gt;\n        stringr::str_split_1('') |&gt;\n        table() |&gt;\n        sort(decreasing = TRUE)\n      hand &lt;-\n        if (length(h) == 1 && all(h %in% 5)) 7\n        else if (length(h) == 2 && all(h %in% c(4, 1))) 6\n        else if (length(h) == 2 && all(h %in% c(3, 2))) 5\n        else if (length(h) == 3 && max(h) == 3) 4\n        else if (length(h[h == 2]) == 2 && max(h) == 2) 3\n        else if (length(h[h == 2]) == 1 && max(h) == 2) 2\n        else 1\n      high &lt;-\n        x |&gt; \n        stringr::str_split_1('') |&gt;\n        purrr::map_int(\\(y) which(rank == y)) |&gt;\n        stringr::str_pad(2, pad = '0') |&gt;\n        paste0(collapse = '') |&gt;\n        as.integer()\n      list('hand' = hand, 'high' = high)\n    })\n  ) |&gt;\n  tidyr::unnest_wider('.nest') |&gt;\n  dplyr::arrange(.data$hand, .data$high) |&gt;\n  dplyr::mutate('bid' = as.integer(.data$bet) * dplyr::row_number()) |&gt;\n  dplyr::pull(.data$bid) |&gt;\n  sum()\n\n[1] 250120186"
  },
  {
    "objectID": "2023/07/2023-07.html#part-2",
    "href": "2023/07/2023-07.html#part-2",
    "title": "Camel Cards",
    "section": "Part 2",
    "text": "Part 2\nThis took longer than it should’ve. I had the concept down quick, but was assigning the Joker to the highest available card rather than the card with the most occurrences. This is quickly apparent with the example KTJJT which with my original method would’ve become KTKKT, a full house, instead of KTTTT, four of a kind.\n\nrank &lt;- c('A', 'K', 'Q', 'T', 9:2, 'J') |&gt; rev()\ndt |&gt;\n  dplyr::mutate(\n    '.nest' = purrr::map(.data$cards, \\(x) {\n      # x &lt;- 'KTJJT'\n      x &lt;- stringr::str_split_1(x, '')\n      h &lt;-\n        x |&gt;\n        table() |&gt;\n        sort(decreasing = TRUE)\n      if (any(names(h) == 'J') & !all(names(h) == 'J')) {\n        r &lt;- which(rank == names(h[names(h) != 'J'])[1])\n        h[rank[r]] &lt;- h[rank[r]] + h['J']\n      } else if (length(h) == 1 & all(names(h) == 'J')) {\n        h &lt;- c('A' = 5)\n      }\n      h &lt;- h[names(h) != 'J']\n      hand &lt;- {\n        if (length(h) == 1 && all(h %in% 5)) 7\n        else if (length(h) == 2 && all(h %in% c(4, 1))) 6\n        else if (length(h) == 2 && all(h %in% c(3, 2))) 5\n        else if (length(h) == 3 && max(h) == 3) 4\n        else if (length(h[h == 2]) == 2 && max(h) == 2) 3\n        else if (length(h[h == 2]) == 1 && max(h) == 2) 2\n        else 1\n      }\n      high &lt;-\n        x |&gt; \n        purrr::map_int(\\(y) which(rank == y)) |&gt;\n        stringr::str_pad(2, pad = '0') |&gt;\n        paste0(collapse = '') |&gt;\n        as.integer()\n      list('hand' = hand, 'high' = high)\n    })\n  ) |&gt;\n  tidyr::unnest_wider('.nest') |&gt;\n  dplyr::arrange(.data$hand, .data$high) |&gt;\n  dplyr::mutate('bid' = as.integer(.data$bet) * dplyr::row_number()) |&gt;\n  dplyr::pull(.data$bid) |&gt;\n  sum()\n\n[1] 250665248"
  },
  {
    "objectID": "2023/04/2023-04.html",
    "href": "2023/04/2023-04.html",
    "title": "Scratchcards",
    "section": "",
    "text": "library(mistlecode)\n\noptions(scipen = 999)\ndt &lt;-\n  readLines(\"input.txt\") |&gt;\n  stringr::str_remove_all('Card +\\\\d+: ') |&gt;\n  stringr::str_split(\" \\\\| \")"
  },
  {
    "objectID": "2023/04/2023-04.html#part-1",
    "href": "2023/04/2023-04.html#part-1",
    "title": "Scratchcards",
    "section": "Part 1",
    "text": "Part 1\nThis took me longer than it should’ve, mostly because of the multiplication factor. I’m happy with my code, but disappointed in how long it took.\n\nbreak_line &lt;- function(x) {\n  x |&gt;\n    stringr::str_split(\" +\") |&gt; \n    unlist() |&gt; \n    as.numeric() |&gt; \n    purrr::discard(is.na)\n}\ndt |&gt;\n  purrr::map(\\(x) {\n    x1 &lt;- break_line(x[1]); x2 &lt;- break_line(x[2]);\n    x &lt;- sum(x1 %in% x2)\n    floor(2^(x-1))\n  }) |&gt;\n  unlist() |&gt;\n  sum()\n\n[1] 21105"
  },
  {
    "objectID": "2023/04/2023-04.html#part-2",
    "href": "2023/04/2023-04.html#part-2",
    "title": "Scratchcards",
    "section": "Part 2",
    "text": "Part 2\nPart 2 follows the same theme as part 1. I’m ultimately really pleased with my code, but it took way too long and in this case could be faster too. The almost recursion but not quite was quite confusing to figure out and I’m sure my code makes even less sense than the problem does.\n\ndt2 &lt;- list()\ndt |&gt;\n  purrr::iwalk(\\(x, idx) {\n    x1 &lt;- break_line(x[1]); x2 &lt;- break_line(x[2]);\n    i &lt;- if (length(dt2) == 0) 1 else (unname(table(unlist(dt2))[idx]) + 1)\n    i &lt;- if (is.na(i)) 1 else i\n    dt2[[idx]] &lt;&lt;- c(idx, rep((idx:(idx + sum(x1 %in% x2)))[-1], i))\n  })\ndt2 |&gt; \n  unlist() |&gt; \n  length()\n\n[1] 5329815"
  },
  {
    "objectID": "2023/02/2023-02.html",
    "href": "2023/02/2023-02.html",
    "title": "Cube Conundrum",
    "section": "",
    "text": "library(mistlecode)\n\noptions(scipen = 999)\ndt &lt;-\n  readLines(\"input.txt\") |&gt;\n  stringr::str_split(\": |; \") |&gt;\n  purrr::map(\\(x) {\n    x[-1] |&gt;\n      str_split(', ')\n  })"
  },
  {
    "objectID": "2023/02/2023-02.html#part-1",
    "href": "2023/02/2023-02.html#part-1",
    "title": "Cube Conundrum",
    "section": "Part 1",
    "text": "Part 1\nI’m pretty pleased overall. I got a bit hung up on the if statements because y was originally all the colors, not one color at a time so I had to add the second (actually third) map statement.\n\nred &lt;- 12; green &lt;- 13; blue &lt;- 14;\n\ndt |&gt;\n  purrr::map_lgl(\\(x) {\n    x &lt;-\n      x |&gt;\n      purrr::map(\\(x2) {\n        x2 |&gt;\n          stringr::str_split(\" \") |&gt;\n          purrr::map(\\(y) {\n            r &lt;- 1\n            if ((y[2] == 'red' & as.numeric(y[1]) &gt; red) |\n                (y[2] == 'green' & as.numeric(y[1]) &gt; green) |\n                (y[2] == 'blue' & as.numeric(y[1]) &gt; blue)) {\n              r &lt;- 0\n            }\n            return(r)\n          })\n    }) |&gt;\n      unlist()\n    all(x == 1)\n  }) |&gt;\n  which() |&gt;\n  sum()\n\n[1] 2006"
  },
  {
    "objectID": "2023/02/2023-02.html#part-2",
    "href": "2023/02/2023-02.html#part-2",
    "title": "Cube Conundrum",
    "section": "Part 2",
    "text": "Part 2\nPretty happy with this too. I got pretty stuck on X1 being character because I was casting later but that meant I was finding the max of a character not a numeric. Moved the cast and it works like a dream.\n\ndt |&gt;\n  purrr::map_int(\\(x) {\n    x |&gt;\n    purrr::map(\\(y) {\n      y |&gt;\n        stringr::str_split_fixed(\" \", 2) |&gt;\n        data.frame() |&gt;\n        dplyr::arrange(X2)\n    }) |&gt;\n      purrr::list_rbind() |&gt;\n      dplyr::summarise(count = max(as.numeric(X1)), .by = X2) |&gt;\n      dplyr::pull(count) |&gt;\n      as.numeric() |&gt;\n      prod()\n  }) |&gt;\n  sum()\n\n[1] 84911"
  },
  {
    "objectID": "2024/13/2024-13.html",
    "href": "2024/13/2024-13.html",
    "title": "Claw Contraption",
    "section": "",
    "text": "library(mistlecode)\n\noptions(scipen = 999)\nFiguring out how best to parse the input was annoying. I need to remember that tidyr::extract() exists.\n.get_buttons &lt;- function(x) {\n  x &lt;-\n    stringr::str_match(x$raw, '(\\\\d+), Y[+=](\\\\d+)')[,-1] |&gt;\n    mistlecode::cast_matrix(as.integer)\n  if (all(is.na(x[1,]))) x[-1,] else x\n}\ndt &lt;-\n  'input.txt' |&gt;\n  readLines() |&gt;\n  tibble::tibble() |&gt;\n  setNames('raw') |&gt;\n  dplyr::mutate(\n    'game' = cumsum(.data$raw == '')\n  ) |&gt;\n  tidyr::nest('data' = raw) |&gt;\n  dplyr::pull(.data$data) |&gt;\n  purrr::map(\\(x) {\n    x &lt;- .get_buttons(x)\n    list('a' = x[1,], 'b' = x[2,], 'p' = x[3,])\n  })"
  },
  {
    "objectID": "2024/13/2024-13.html#part-1",
    "href": "2024/13/2024-13.html#part-1",
    "title": "Claw Contraption",
    "section": "Part 1",
    "text": "Part 1\nI got to do math!!! I’m so proud of myself for this one. Like genuinely actually for realizing I could just math it out. And my solution is so fast too! I probably could’ve done the linear programming, but just solving seemed easier?\n\\[\\begin{gather*}\nix_a + jx_b = X, iy_a + jy_b = Y\\\\\nix_a = X - jx_b, iy_a = Y - jy_b\\\\\ni = \\frac{X - jx_b}{x_a}, i = \\frac{Y - jy_b}{y_a}\\\\\n\\frac{X - jx_b}{x_a} = \\frac{Y - jy_b}{y_a}\\\\\nX - jx_b =\\frac{x_aY - jx_ay_b}{y_a}\\\\\ny_aX - jx_by_a = x_aY - jx_ay_b\\\\\n-jx_by_a + jx_ay_b = x_aY - y_aX\\\\\nj * (-x_by_a + x_ay_b) = x_aY - y_aX\\\\\nj = \\frac{x_aY - y_aX}{x_ay_b - x_by_a}\n\\end{gather*}\\]\n\ndt |&gt;\n  purrr::map(\\(x) {\n    j &lt;-\n      ((x$a[1] * x$p[2]) - (x$a[2] * x$p[1])) / \n      ((x$a[1] * x$b[2]) - (x$b[1] * x$a[2]))\n    i &lt;- (x$p[1] - (j * x$b[1])) / x$a[1]\n    x &lt;- c(i * 3, j * 1)\n    if (all(as.integer(x) == x)) sum(x)\n  }) |&gt;\n  purrr::discard(is.null) |&gt;\n  unlist() |&gt; \n  sum()\n\n[1] 33921"
  },
  {
    "objectID": "2024/13/2024-13.html#part-2",
    "href": "2024/13/2024-13.html#part-2",
    "title": "Claw Contraption",
    "section": "Part 2",
    "text": "Part 2\nThis was supremely unsatisfying. I kept multiplying by 10000000000000 instead of adding then for whatever reason if I leave my if statement as an all(x) kinda deal, it doesn’t work right. I spent way too long on random bit64 stuff and trying to solve to get rid of the 10000000000000.\n\ndt |&gt;\n  purrr::map(\\(x) {\n    x$p &lt;- x$p + 10000000000000\n    j &lt;-\n      ((x$a[1] * x$p[2]) - (x$a[2] * x$p[1])) / \n      ((x$a[1] * x$b[2]) - (x$b[1] * x$a[2]))\n    if (j &lt; 0 || j %% 1 != 0) return(NULL)\n    i &lt;- (x$p[1] - (j * x$b[1])) / x$a[1]\n    if (i &lt; 0 || i %% 1 != 0) return(NULL)\n    x &lt;- c(i * 3, j * 1)\n    sum(x)\n  }) |&gt;\n  purrr::discard(is.null) |&gt;\n  unlist() |&gt; \n  sum()\n\n[1] 82261957837868"
  },
  {
    "objectID": "2024/05/2024-05.html",
    "href": "2024/05/2024-05.html",
    "title": "Print Queue",
    "section": "",
    "text": "Lots of minor hiccups leading to a major fizzle. Overall I want to see how everyone else’s solutions look, but I think mine is rather elegant, even if a bit slow.\nlibrary(mistlecode)\n\noptions(scipen = 999)\ninput &lt;- 'input.txt'\nskip &lt;- which(readLines(input) == '')\n\ndt1 &lt;- \n  input |&gt;\n  readr::read_delim('|', col_names = FALSE, n_max = skip - 1, show_col_types = FALSE) |&gt;\n  dplyr::filter(!is.na(.data$X2))\n\nRegistered S3 methods overwritten by 'bit64':\n  method               from  \n  as.double.integer64  cheapr\n  as.integer.integer64 cheapr\n\ndt2 &lt;-\n  input |&gt;\n  readLines()\ndt2 &lt;-\n  dt2[(skip+1):length(dt2)] |&gt;\n  strsplit(',') |&gt;\n  purrr::map(as.integer)"
  },
  {
    "objectID": "2024/05/2024-05.html#part-1",
    "href": "2024/05/2024-05.html#part-1",
    "title": "Print Queue",
    "section": "Part 1",
    "text": "Part 1\nThis was really frustrating. I was struggling and eventually found I had lines with even numbers of items. I couldn’t figure out what the heck was up with that and how to get a middle item from an even length set and then eventually realized my input ingestion was messing everything up. Once I switched from read.delim() to readLines(), I was able to clear everything right up.\n\nmiddle_page &lt;-\n  dt2 |&gt;\n  purrr::map_int(\\(x) {\n    if (length(x) %% 2 == 0) print(x)\n    is_valid &lt;-\n      x |&gt;\n      seq_along() |&gt;\n      purrr::map_lgl(\\(i) {\n        if (i == length(x)) return(TRUE)\n        left &lt;- x[i]; right &lt;- x[(i+1):length(x)];\n        check_right &lt;- dt1$X2[dt1$X1 == left]\n        all(right %in% check_right)\n      }) |&gt;\n      all()\n    if (is_valid) x[ceiling(length(x) / 2)] else 0\n  })\nsum(middle_page)\n\n[1] 7307"
  },
  {
    "objectID": "2024/05/2024-05.html#part-2",
    "href": "2024/05/2024-05.html#part-2",
    "title": "Print Queue",
    "section": "Part 2",
    "text": "Part 2\nThis was just a matter of getting the logic straight in my head then putting it on sreen and getting over silly mistakes like filtering for things that passed the test in part 1 instead of things that failed. Except. I’ve always struggled with recursion but I’m getting better at it and I’m getting better at it and I’m getting better at it and eventually I might be able to solve that stupid bag problem from 2020.\n\nswap &lt;- function(x, i = 1) {\n  left &lt;- x[i]; right &lt;- x[i+1];\n  check_right &lt;- dt1$X2[dt1$X1 == left]\n  if (is.na(right)) return(x)\n  if (!(right %in% check_right)) {\n    x[i+1] &lt;- left; x[i] &lt;- right;\n    swap(x, 1)\n  } else { swap(x, i + 1) }\n}\n\ndt2[middle_page == 0] |&gt;\n  purrr::map_int(\\(x) {\n    x &lt;- swap(x)\n    x[ceiling(length(x) / 2)]\n  }) |&gt;\n  sum()\n\n[1] 4713"
  },
  {
    "objectID": "2024/03/2024-03.html",
    "href": "2024/03/2024-03.html",
    "title": "Mull It Over",
    "section": "",
    "text": "library(mistlecode)\n\noptions(scipen = 999)\ndt &lt;- readLines(\"input.txt\")"
  },
  {
    "objectID": "2024/03/2024-03.html#part-1",
    "href": "2024/03/2024-03.html#part-1",
    "title": "Mull It Over",
    "section": "Part 1",
    "text": "Part 1\nI’m really pleased with this. Doing the parse() |&gt; eval() is super super dangerous and should never be done, but it works so I’m happy. I got 343 on the leaderboard which is my best ever.\n\nmul &lt;- function(x, y) x * y\ndt |&gt;\n  stringr::str_extract_all('mul\\\\(\\\\d+,\\\\d+\\\\)') |&gt;\n  unlist() |&gt;\n  purrr::map_int(\\(x) {\n    x |&gt;\n      parse(text = _) |&gt;\n      eval()\n  }) |&gt;\n  sum()\n\n[1] 170068701"
  },
  {
    "objectID": "2024/03/2024-03.html#part-2",
    "href": "2024/03/2024-03.html#part-2",
    "title": "Mull It Over",
    "section": "Part 2",
    "text": "Part 2\nI didn’t realize the example input changed which messed me up a bit. Then I just had to get my regex right and I was good to go. I’m also pleased with my little if...else if chain. I got an error when x was a mul() call, but then realized that I didn’t have to explicitly check because I was already checking for do() and don't() and if it’s not either of those, then it must be a mul(). Oh, and 502 on the leaderboard for part 2 would’ve been a best ever if not for part 1!\n\ndo &lt;- TRUE\ndt |&gt;\n  stringr::str_extract_all(\"mul\\\\(\\\\d+,\\\\d+\\\\)|do\\\\(\\\\)|don't\\\\(\\\\)\") |&gt;\n  unlist() |&gt;\n  purrr::map_int(\\(x) {\n    if (x == \"don't()\") do &lt;&lt;- FALSE \n    else if (x == \"do()\") do &lt;&lt;- TRUE \n    else if (do) {\n      x &lt;-\n        x |&gt;\n        parse(text = _) |&gt;\n        eval()\n      return(x)\n    }\n    return(0)\n  }) |&gt;\n  sum()\n\n[1] 78683433"
  },
  {
    "objectID": "2024/01/2024-01.html",
    "href": "2024/01/2024-01.html",
    "title": "Historian Hysteria",
    "section": "",
    "text": "library(mistlecode)\n\noptions(scipen = 999)\ndt &lt;- \n  'input.txt' |&gt;\n  readr::read_delim(delim = '   ', col_names = FALSE, show_col_types = FALSE)\n\nRegistered S3 methods overwritten by 'bit64':\n  method               from  \n  as.double.integer64  cheapr\n  as.integer.integer64 cheapr"
  },
  {
    "objectID": "2024/01/2024-01.html#part-1",
    "href": "2024/01/2024-01.html#part-1",
    "title": "Historian Hysteria",
    "section": "Part 1",
    "text": "Part 1\nThis was nice and quick. I’m pretty happy with my global rank 518.\n\ndt1 &lt;- dt$X1 |&gt; sort()\ndt2 &lt;- dt$X2 |&gt; sort()\n\nabs(dt1 - dt2) |&gt; sum()\n\n[1] 1151792"
  },
  {
    "objectID": "2024/01/2024-01.html#part-2",
    "href": "2024/01/2024-01.html#part-2",
    "title": "Historian Hysteria",
    "section": "Part 2",
    "text": "Part 2\nThis took way too long for me. I was really struggling with the counting portion for some reason and it took a long time for me to internalize that x %in% y and which don’t actually count things. Might need to add that to mistlecode…\n\ndt |&gt;\n  dplyr::mutate('count' = purrr::map_int(.data$X1, \\(x) {\n    which(.data$X2 == x) |&gt; length()\n  })) |&gt;\n  dplyr::mutate('count' = .data$X1 * .data$count) |&gt;\n  dplyr::pull(.data$count) |&gt;\n  sum()\n\n[1] 21790168"
  },
  {
    "objectID": "2022/05/2022-05.html",
    "href": "2022/05/2022-05.html",
    "title": "Supply Stacks",
    "section": "",
    "text": "library(tidyverse)\nlibrary(data.table)\nThis was a big mess. It took me forever to read in the input and I eventually stumbled upon reaf_fwf because I couldn’t remember what a fixed-width file was. I kept looking for delimited readers and tried all sorts of crazy things.\nfile_name &lt;- \"input.txt\"\nmove &lt;- function(piles, i, ins, part) {\n  moveN &lt;- ins$X2[i]\n  fromN &lt;- ins$X3[i]\n  toN &lt;- ins$X4[i]\n  \n  from &lt;- piles[[fromN]]\n  to &lt;- piles[[toN]]\n  \n  if (part == 1) { to &lt;- c(rev(from[1:moveN]), to) }\n  else if (part == 2) { to &lt;- c(from[1:moveN], to) }\n  from &lt;- tail(from, -moveN)\n  \n  piles[[fromN]] &lt;- from[!is.na(from)]\n  piles[[toN]] &lt;- to[!is.na(to)]\n  \n  return(piles)\n}\n\ndo_part &lt;- function(part) {\n  dt &lt;- readLines(file_name)\n  piles &lt;- read_fwf(file = file_name, na = \"  \", n_max = which(dt == \"\") - 2)\n  \n  piles &lt;- piles |&gt; as.matrix()\n  piles &lt;-\n    piles |&gt;\n    ncol() |&gt;\n    seq_len()\n    lapply(\\(i) piles[, i]) |&gt;\n    lapply(\\(x) str_extract(x[x != \"\"], \"\\\\w\"))\n  \n  ins &lt;-\n    readLines(file_name) |&gt;\n    tail(-(which(dt == \"\") - 1)) |&gt;\n    str_match_all(\"move (\\\\d*) from (\\\\d*) to (\\\\d*)\") |&gt;\n    do.call(rbind, args = _) |&gt;\n    data.frame() |&gt;\n    lapply(as.numeric) |&gt;\n    data.frame()\n  \n  for (i in 1:nrow(ins)) {\n    piles &lt;- move(piles, i, ins, part = part)\n  }\n  piles |&gt;\n    lapply(\\(x) head(x, 1)) |&gt;\n    unlist() |&gt;\n    paste(collapse = \"\")\n}"
  },
  {
    "objectID": "2022/05/2022-05.html#part-1",
    "href": "2022/05/2022-05.html#part-1",
    "title": "Supply Stacks",
    "section": "Part 1",
    "text": "Part 1\nOnce I had the input in, it was relatively smooth sailing. I missed the part in part 1 where the boxes move one by one (oh part 2, how I wish I knew you then…) but once I had that fixed, I was looking pretty good. I got the test input working but then the real input wasn’t working. I eventually realized that my regex \\\\d was missing any numbers greater than 9 once that was fixed, everything else was pretty easy.\n\ndo_part(1)\n\nRows: 8 Columns: 9\n── Column specification ────────────────────────────────────────────────────────\n\nchr (9): X1, X2, X3, X4, X5, X6, X7, X8, X9\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nWarning in lapply(data.frame(str_match_all(tail(readLines(file_name),\n-(which(dt == : NAs introduced by coercion\n\n\n[1] \"ZBDRNPMVH\""
  },
  {
    "objectID": "2022/05/2022-05.html#part-2",
    "href": "2022/05/2022-05.html#part-2",
    "title": "Supply Stacks",
    "section": "Part 2",
    "text": "Part 2\nAfter firing off a celebratory text message, I read part 2, deleted my rev and was done in 52 seconds!\n\ndo_part(2)\n\nRows: 8 Columns: 9\n── Column specification ────────────────────────────────────────────────────────\n\nchr (9): X1, X2, X3, X4, X5, X6, X7, X8, X9\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nWarning in lapply(data.frame(str_match_all(tail(readLines(file_name),\n-(which(dt == : NAs introduced by coercion\n\n\n[1] \"WDLPFNNNB\""
  },
  {
    "objectID": "2022/03/2022-03.html",
    "href": "2022/03/2022-03.html",
    "title": "Rucksack Reorganization",
    "section": "",
    "text": "library(tidyverse)\nlibrary(data.table)\n# dt &lt;- fread(\"input.txt\", header = FALSE)\ndt &lt;- readLines(\"input.txt\")\nThis already looks rough. readLines because it’s strings."
  },
  {
    "objectID": "2022/03/2022-03.html#part-1",
    "href": "2022/03/2022-03.html#part-1",
    "title": "Rucksack Reorganization",
    "section": "Part 1",
    "text": "Part 1\nUltimately not too bad. I got to make use of \\(x) for an anonymous function. I messed up the second half of the string and had it started at the end of the first half. I got docked a minute for the bad answer but then was able to fix it in time for resubmission.\n\ndata.frame(\"input\" = dt) %&gt;%\n  mutate(V1 = substr(input, 1, nchar(input) / 2),\n         V2 = substr(input, nchar(input) / 2 + 1, nchar(input))) %&gt;%\n  apply(1, \\(x) {\n    v1 &lt;- unlist(strsplit(x[\"V1\"], \"\"))\n    v2 &lt;- unlist(strsplit(x[\"V2\"], \"\"))\n    \n    return(v1[v1 %in% v2])\n  }) %&gt;%\n  sapply(\\(x) {\n    x &lt;- unique(x)\n    sum(which(letters == x), (which(LETTERS == x) + 26), na.rm = TRUE)\n  }) %&gt;%\n  sum()\n\n[1] 7811"
  },
  {
    "objectID": "2022/03/2022-03.html#part-2",
    "href": "2022/03/2022-03.html#part-2",
    "title": "Rucksack Reorganization",
    "section": "Part 2",
    "text": "Part 2\nI struggled with creating the groups for some reason. Once I had that going, the rest was pretty easy.\n\ndata.frame(\"input\" = dt) %&gt;%\n  mutate(\"group\" = rep(1:(nrow(.) / 3), each = 3)) -&gt; dt2\n\nd2 &lt;- c()\nfor(g in unique(dt2$group)) {\n  d &lt;- dt2$input[dt2$group == g]\n  \n  v1 &lt;- unlist(strsplit(d[1], \"\"))\n  v2 &lt;- unlist(strsplit(d[2], \"\"))\n  v3 &lt;- unlist(strsplit(d[3], \"\"))\n    \n  d2 &lt;&lt;- c(d2, unique(v3[v3 %in% v1[v1 %in% v2]]))\n}\n\nsapply(d2, \\(x) {\n    x &lt;- unique(x)\n    sum(which(letters == x), (which(LETTERS == x) + 26), na.rm = TRUE)\n  }) %&gt;%\n  sum()\n\n[1] 2639"
  },
  {
    "objectID": "2022/01/2022-01.html",
    "href": "2022/01/2022-01.html",
    "title": "Calorie Counting",
    "section": "",
    "text": "library(tidyverse)\nlibrary(data.table)\nMy initial thought was to use data.table::fread but that skipped the spaces in the input by default. readLines keeps the spaces so I switched to that right away.\ndt &lt;- readLines(\"input.txt\")"
  },
  {
    "objectID": "2022/01/2022-01.html#part-1",
    "href": "2022/01/2022-01.html#part-1",
    "title": "Calorie Counting",
    "section": "Part 1",
    "text": "Part 1\nThis was just a matter of getting a loop with a maximum value counter going. I knew from the get-go that I would need to use the global assignment operator inside the loop. For reasons I thought that naming my variable sum would work but got an error since that’s a reserved word in R (duh!). Find+replace helped get that sorted but my inner loop logic was still wrong. I realized that I was missing an else case to catch any time the maximum hadn’t changed, but the sum needed to be reset.\n\nsm &lt;- 0\nmaxsm &lt;- 0\nfor (x in dt) {\n  x &lt;- as.numeric(x)\n  if (!is.na(x)) {\n    sm &lt;&lt;- sm + x\n  } else if (sm &gt; maxsm) {\n    maxsm &lt;&lt;- sm\n    sm &lt;&lt;- 0\n  } else {\n    sm &lt;&lt;- 0\n  }\n}\nmaxsm\n\n[1] 68923"
  },
  {
    "objectID": "2022/01/2022-01.html#part-2",
    "href": "2022/01/2022-01.html#part-2",
    "title": "Calorie Counting",
    "section": "Part 2",
    "text": "Part 2\nComing out of Part 1 was really strong, especially on Day 1. Instead of saving just the max sum, I made it a vector to record all sums. Then I just need to sort it, get the top three values, and sum those.\n\nsm &lt;- 0\nmaxsm &lt;- c()\nfor (x in dt) {\n  x &lt;- as.numeric(x)\n  if (!is.na(x)) {\n    sm &lt;&lt;- sm + x\n  } else  {\n    maxsm &lt;&lt;- c(maxsm, sm)\n    sm &lt;&lt;- 0\n  }\n}\nsum(sort(maxsm, decreasing = TRUE)[1:3])\n\n[1] 200044"
  },
  {
    "objectID": "2025/06/2025-06.html",
    "href": "2025/06/2025-06.html",
    "title": "Trash Compactor",
    "section": "",
    "text": "library(mistlecode)\n\noptions(scipen = 999)"
  },
  {
    "objectID": "2025/06/2025-06.html#part-1",
    "href": "2025/06/2025-06.html#part-1",
    "title": "Trash Compactor",
    "section": "Part 1",
    "text": "Part 1\nUsed apply because it’s much better at this sort of thing than purrr::pmap().\n\n'input.txt' |&gt;\n  readLines() |&gt;\n  stringr::str_split('\\\\s+') |&gt;\n  purrr::map(\\(x) x[x != '']) |&gt;\n  do.call(rbind, args = _) |&gt;\n  apply(\\(x) {\n    x[-length(x)] |&gt;\n      paste0(collapse = x[length(x)]) |&gt;\n      parse(text = _) |&gt;\n      eval()\n  }, MARGIN = 2) |&gt;\n  sum()\n\n[1] 4405895212738"
  },
  {
    "objectID": "2025/06/2025-06.html#part-2",
    "href": "2025/06/2025-06.html#part-2",
    "title": "Trash Compactor",
    "section": "Part 2",
    "text": "Part 2\nTook me way too long to realize my problems where because numbers could be left or right padded and then I had to figure out how to deal with it.\n\nwhich_op &lt;-\n  'input.txt' |&gt; \n  readLines() |&gt;\n  utils::tail(1) |&gt;\n  stringr::str_split_1('') |&gt;\n  (\\(x) which(x != ' '))()\n\n'input.txt' |&gt;\n  readLines() |&gt;\n  # utils::head(-1) |&gt;\n  purrr::map(\\(x) {\n    x |&gt;\n      stringr::str_sub_all(start = which_op, end = c(which_op[-1] -1, nchar(x))) |&gt;\n      unlist()\n  }) |&gt;\n  do.call(rbind, args = _) |&gt;\n  apply(\\(x) {\n    x[-length(x)] |&gt;\n      stringr::str_split('') |&gt;\n      do.call(rbind, args = _) |&gt;\n      apply(paste0, MARGIN = 2, collapse = '') |&gt;\n      stringr::str_trim() |&gt;\n      (\\(x) x[x != ''])() |&gt;\n      paste0(collapse = x[length(x)]) |&gt;\n      parse(text = _) |&gt;\n      eval()\n  }, MARGIN = 2) |&gt;\n  sum()\n\n[1] 7450962489289"
  },
  {
    "objectID": "2025/04/2025-04.html",
    "href": "2025/04/2025-04.html",
    "title": "Printing Department",
    "section": "",
    "text": "library(mistlecode)\n\noptions(scipen = 999)"
  },
  {
    "objectID": "2025/04/2025-04.html#part-1",
    "href": "2025/04/2025-04.html#part-1",
    "title": "Printing Department",
    "section": "Part 1",
    "text": "Part 1\nThis is one of those ones where you do great on the test input and miss something on the real one and can’t figure it out. I was returning too early in a few edge cases. Literal edge cases. Where the toilet paper was on the edge of the grid.\n\nmat &lt;- mistlecode::read_matrix('input.txt')\nexpand.grid(\n  'y' = mat |&gt; nrow() |&gt; seq_len(),\n  'x' = mat |&gt; ncol() |&gt; seq_len()\n) |&gt;\n  purrr::pmap(\\(y, x) {\n    if (mat[y, x] == '.') return(c('.' = 4))\n    mistlecode::get_adjacent_values(y, x, mat) |&gt;\n      as.vector() |&gt;\n      table()\n  }) |&gt;\n  unlist() |&gt;\n  (\\(x) x[names(x) == '@'])() |&gt;\n  (\\(x) x[x &lt;= 4])() |&gt;\n  length()\n\n[1] 1516"
  },
  {
    "objectID": "2025/04/2025-04.html#part-2",
    "href": "2025/04/2025-04.html#part-2",
    "title": "Printing Department",
    "section": "Part 2",
    "text": "Part 2\nA little bit more of me being not so bright on the execution and some waiting and there’s a solution.\n\nmat &lt;- mistlecode::read_matrix('input.txt')\nwiped &lt;- 0\ncoords &lt;-\n  expand.grid(\n    'y' = mat |&gt; nrow() |&gt; seq_len(),\n    'x' = mat |&gt; ncol() |&gt; seq_len()\n  )\ndo_wipe &lt;- function(mat) {\n  current &lt;- wiped\n  mat_copy &lt;- mat\n  coords |&gt;\n    purrr::pwalk(\\(y, x) {\n      if (mat[y, x] == '@') {\n        vals &lt;- \n          mistlecode::get_adjacent_values(y, x, mat) |&gt;\n          as.vector() |&gt;\n          table()\n        if (vals['@'] &lt;= 4) {\n          mat_copy[y, x] &lt;&lt;- '.'\n          wiped &lt;&lt;- wiped + 1\n        }\n      }\n    })\n  if (current != wiped) do_wipe(mat_copy) else wiped\n}\ndo_wipe(mat)\n\n[1] 9122"
  },
  {
    "objectID": "2025/02/2025-02.html",
    "href": "2025/02/2025-02.html",
    "title": "Gift Shop",
    "section": "",
    "text": "library(mistlecode)\n\noptions(scipen = 999)"
  },
  {
    "objectID": "2025/02/2025-02.html#part-1",
    "href": "2025/02/2025-02.html#part-1",
    "title": "Gift Shop",
    "section": "Part 1",
    "text": "Part 1\nFun litle bit of regex. I’m pleased it was that easy.\n\n'input.txt' |&gt;\n  readLines() |&gt;\n  stringr::str_split_1(',') |&gt;\n  stringr::str_split('-') |&gt;\n  purrr::map(\\(x) {\n    sq &lt;- x[1]:x[2]\n    sq[\n      sq |&gt;\n        as.character() |&gt;\n        stringr::str_detect('^(\\\\d+)(\\\\1)$')\n    ]\n  }) |&gt;\n  unlist() |&gt;\n  sum()\n\n[1] 12850231731"
  },
  {
    "objectID": "2025/02/2025-02.html#part-2",
    "href": "2025/02/2025-02.html#part-2",
    "title": "Gift Shop",
    "section": "Part 2",
    "text": "Part 2\nJust a little regex modification. Nice and simple.\n\n'input.txt' |&gt;\n  readLines() |&gt;\n  stringr::str_split_1(',') |&gt;\n  stringr::str_split('-') |&gt;\n  purrr::map(\\(x) {\n    sq &lt;- x[1]:x[2]\n    sq[\n      sq |&gt;\n        as.character() |&gt;\n        stringr::str_detect('^(\\\\d+)(\\\\1){1,}$')\n    ]\n  }) |&gt;\n  unlist() |&gt;\n  sum()\n\n[1] 24774350322"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome!",
    "section": "",
    "text": "Welcome to my Advent of Code blog book! All of my solutions are in R with varying degrees of complexity and documentation."
  },
  {
    "objectID": "index.html#click-here-for-my-solutions",
    "href": "index.html#click-here-for-my-solutions",
    "title": "Welcome!",
    "section": "CLICK HERE FOR MY SOLUTIONS",
    "text": "CLICK HERE FOR MY SOLUTIONS"
  },
  {
    "objectID": "index.html#star-chart",
    "href": "index.html#star-chart",
    "title": "Welcome!",
    "section": "Star Chart",
    "text": "Star Chart"
  },
  {
    "objectID": "index.html#my-favorite-solutions",
    "href": "index.html#my-favorite-solutions",
    "title": "Welcome!",
    "section": "My Favorite Solutions",
    "text": "My Favorite Solutions\n\n\n2016-12 and 2017-08: I created a small assembly style computer that solves the problems for me given a set of registers and instructions.\n\n2021-09: I used the dbscan clustering method to solve a path finding issue.\n\n2022-04: While not my fastest part 1, part 2 took me just 38 seconds!\n\n2022-11: I used S3 Classes and function factories for the first time, and got just a little bit better at recursion."
  },
  {
    "objectID": "solutions.html",
    "href": "solutions.html",
    "title": "Solutions",
    "section": "",
    "text": "Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Title\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\nDate\n\n\nTitle\n\n\n\n\n\n\n2025-09\n\n\nMovie Theater\n\n\n\n\n2025-06\n\n\nTrash Compactor\n\n\n\n\n2025-05\n\n\nCafeteria\n\n\n\n\n2025-04\n\n\nPrinting Department\n\n\n\n\n2025-03\n\n\nLobby\n\n\n\n\n2025-02\n\n\nGift Shop\n\n\n\n\n2025-01\n\n\nSecret Entrance\n\n\n\n\n2024-14\n\n\nRestroom Redoubt\n\n\n\n\n2024-13\n\n\nClaw Contraption\n\n\n\n\n2024-07\n\n\nBridge Repair\n\n\n\n\n2024-06\n\n\nGuard Gallivant\n\n\n\n\n2024-05\n\n\nPrint Queue\n\n\n\n\n2024-04\n\n\nCeres Search\n\n\n\n\n2024-03\n\n\nMull It Over\n\n\n\n\n2024-02\n\n\nRed-Nosed Reports\n\n\n\n\n2024-01\n\n\nHistorian Hysteria\n\n\n\n\n2023-13\n\n\nPoint of Incidence\n\n\n\n\n2023-08\n\n\nHaunted Wasteland\n\n\n\n\n2023-07\n\n\nCamel Cards\n\n\n\n\n2023-04\n\n\nScratchcards\n\n\n\n\n2023-03\n\n\nGear Ratios\n\n\n\n\n2023-02\n\n\nCube Conundrum\n\n\n\n\n2023-01\n\n\nTrebuchet?!\n\n\n\n\n2022-21\n\n\nMonkey Math\n\n\n\n\n2022-20\n\n\nGrove Positioning System\n\n\n\n\n2022-14\n\n\nRegolith Reservoir\n\n\n\n\n2022-11\n\n\nMonkey in the Middle\n\n\n\n\n2022-10\n\n\nCathode-Ray Tube\n\n\n\n\n2022-08\n\n\nTreetop Tree House\n\n\n\n\n2022-07\n\n\nNo Space Left On Device\n\n\n\n\n2022-06\n\n\nTuning Trouble\n\n\n\n\n2022-05\n\n\nSupply Stacks\n\n\n\n\n2022-04\n\n\nCamp Cleanup\n\n\n\n\n2022-03\n\n\nRucksack Reorganization\n\n\n\n\n2022-02\n\n\nRock Paper Scissors\n\n\n\n\n2022-01\n\n\nCalorie Counting\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "2025/01/2025-01.html",
    "href": "2025/01/2025-01.html",
    "title": "Secret Entrance",
    "section": "",
    "text": "library(mistlecode)\n\noptions(scipen = 999)"
  },
  {
    "objectID": "2025/01/2025-01.html#part-1",
    "href": "2025/01/2025-01.html#part-1",
    "title": "Secret Entrance",
    "section": "Part 1",
    "text": "Part 1\nI’m very proud of this one. I did it the fancy math way instead of trying to simulate an actual dial.\n\n'input.txt' |&gt;\n  readLines() |&gt;\n  stringr::str_replace_all('L', '-') |&gt;\n  stringr::str_replace_all('R', '') |&gt;\n  as.numeric() |&gt;\n  append(50, after = 0) |&gt;\n  cumsum() |&gt;\n  (\\(x) x %% 100)() |&gt;\n  table() |&gt;\n  _[['0']]\n\n[1] 1084"
  },
  {
    "objectID": "2025/01/2025-01.html#part-2",
    "href": "2025/01/2025-01.html#part-2",
    "title": "Secret Entrance",
    "section": "Part 2",
    "text": "Part 2\nDisappointed in myself on this one. I tried a bunch of fancy stuff including simulating the dial by move, but the real easy solution was just to move the dial step by step and then apply the solution from above.\n\n'input.txt' |&gt;\n  readLines() |&gt;\n  stringr::str_replace_all('L', '-') |&gt;\n  stringr::str_replace_all('R', '') |&gt;\n  as.numeric() |&gt;\n  # append(50, after = 0) |&gt;\n  purrr::map(\\(x) {\n    x |&gt;\n      sign() |&gt;\n      rep(abs(x))\n  }) |&gt;\n  unlist() |&gt;\n  append(50, after = 0) |&gt;\n  cumsum() |&gt;\n  (\\(x) x %% 100)() |&gt;\n  table() |&gt;\n  _[['0']]\n\n[1] 6475"
  },
  {
    "objectID": "2025/03/2025-03.html",
    "href": "2025/03/2025-03.html",
    "title": "Lobby",
    "section": "",
    "text": "library(mistlecode)\n\noptions(scipen = 999)"
  },
  {
    "objectID": "2025/03/2025-03.html#part-1",
    "href": "2025/03/2025-03.html#part-1",
    "title": "Lobby",
    "section": "Part 1",
    "text": "Part 1\nProud of this one. Just find the biggest number that isn’t the last number, then find the biggest number after the biggest number.\n\n'input.txt' |&gt;\n  readLines() |&gt;\n  stringr::str_split('') |&gt;\n  purrr::map_int(\\(x) {\n    x &lt;- as.integer(x)\n    biggest &lt;- which.max(head(x, -1))\n    second_biggest &lt;- which.max(x[(biggest+1):length(x)]) + biggest\n    glue::glue('{x[biggest]}{x[second_biggest]}') |&gt;\n      as.integer()\n  }) |&gt;\n  sum()\n\n[1] 16812"
  },
  {
    "objectID": "2025/03/2025-03.html#part-2",
    "href": "2025/03/2025-03.html#part-2",
    "title": "Lobby",
    "section": "Part 2",
    "text": "Part 2\nGetting the recursion right was a bit annoying. I had an off-by-one error in my which.max(). I do like these kinds of puzzles where the second part is doing the first part a more general way.\n\nfind_biggest &lt;- function(x, value = integer(), pos = 0) {\n  remaining &lt;- 12 - length(value)\n  if (remaining == 0) return(value)\n  biggest &lt;- which.max(x[(pos+1):(length(x)-remaining+1)]) + pos\n  value &lt;- c(value, x[biggest])\n  pos &lt;- biggest\n  find_biggest(x, value, pos)\n}\n\n'input.txt' |&gt;\n  readLines() |&gt;\n  stringr::str_split('') |&gt;\n  purrr::map_dbl(\\(x) {\n    x |&gt;\n      as.integer() |&gt;\n      find_biggest() |&gt;\n      paste0(collapse = '') |&gt;\n      as.numeric()\n  }) |&gt;\n  sum()\n\n[1] 166345822896410"
  },
  {
    "objectID": "2025/05/2025-05.html",
    "href": "2025/05/2025-05.html",
    "title": "Cafeteria",
    "section": "",
    "text": "library(mistlecode)\n\noptions(scipen = 999)"
  },
  {
    "objectID": "2025/05/2025-05.html#part-1",
    "href": "2025/05/2025-05.html#part-1",
    "title": "Cafeteria",
    "section": "Part 1",
    "text": "Part 1\nError: cannot allocate vector of size 3238080.8 Gb yeah okay. Just doing %in% would’ve been too easy. But my actual solution isn’t that much more complicated either. I’m not sure I’ve ever actually used dplyr::join_by() before.\n\ninput &lt;- readLines('input.txt')\n\nranges &lt;-\n  input[1:(which(input == '')-1)] |&gt;\n  purrr::map(\\(x) {\n    x |&gt;\n      stringr::str_split_1('-') |&gt;\n      as.numeric()\n  }) |&gt;\n  do.call(rbind, args = _) |&gt;\n  as.data.frame()\n\ninput[(which(input == '')+1):length(input)] |&gt;\n  as.numeric() |&gt;\n  tibble::tibble() |&gt;\n  setNames('values') |&gt;\n  dplyr::inner_join(\n    y = ranges,\n    by = dplyr::join_by(dplyr::between(x$values, y$V1, y$V2))\n  ) |&gt;\n  dplyr::pull(.data$values) |&gt;\n  unique() |&gt;\n  length()\n\n[1] 607"
  },
  {
    "objectID": "2025/05/2025-05.html#part-2",
    "href": "2025/05/2025-05.html#part-2",
    "title": "Cafeteria",
    "section": "Part 2",
    "text": "Part 2\nI’m sure there’s a more efficient way. That said, initially I was starting back at row one every time a new range was found and that was taking forever. I realized I can just subtract one from my current index to account for the row I lost and there will always be something new until there isn’t.\n\ndownsize &lt;- function(ranges, i = 1) {\n  # browser()\n  if (i &gt; nrow(ranges)) return(ranges)\n  r &lt;- ranges[i,]\n  \n  new_ranges &lt;-\n    ranges[-i,] |&gt;\n    dplyr::filter(\n      (r$V1 &gt;= .data$V1 & r$V1 &lt;= .data$V2) | (r$V2 &gt;= .data$V1 & r$V1 &lt;= .data$V2)\n    ) |&gt;\n    purrr::pmap(\\(V1, V2) {\n      tibble::tibble(\n        'V1' = min(r$V1, V1),\n        'V2' = max(r$V2, V2)\n      )\n    }) |&gt;\n    purrr::list_rbind()\n  \n  if (nrow(new_ranges) == 0) {\n    downsize(ranges, i + 1) \n  } else {\n    ranges &lt;- ranges[-i,]\n    ranges |&gt;\n      dplyr::bind_rows(new_ranges) |&gt;\n      unique() |&gt;\n      downsize(i - 1)\n  }\n}\n\nranges |&gt;\n  downsize() |&gt;\n  dplyr::mutate(\n    'size' = .data$V2 - .data$V1 + 1\n  ) |&gt;\n  dplyr::pull(.data$size) |&gt;\n  sum()\n\n[1] 342433357244012"
  },
  {
    "objectID": "2025/09/2025-09.html",
    "href": "2025/09/2025-09.html",
    "title": "Movie Theater",
    "section": "",
    "text": "library(mistlecode)\n\noptions(scipen = 999)"
  },
  {
    "objectID": "2025/09/2025-09.html#part-1",
    "href": "2025/09/2025-09.html#part-1",
    "title": "Movie Theater",
    "section": "Part 1",
    "text": "Part 1\nOff by one errors and pesky zeroes.\n\npoints &lt;-\n  'input.txt' |&gt;\n  readLines() |&gt;\n  stringr::str_split(',') |&gt;\n  purrr::map(as.numeric)\n\npoints |&gt;\n  seq_along() |&gt;\n  utils::head(-1) |&gt;\n  purrr::map(\\(i) {\n    i:length(points) |&gt;\n      purrr::map_dbl(\\(j) {\n        if (i == j) return(0L)\n        width &lt;- abs(points[[i]][1] - points[[j]][1]) + 1\n        height &lt;- abs(points[[i]][2] - points[[j]][2]) + 1\n        if (width == 0) width &lt;- 1\n        if (height == 0) height &lt;- 1\n        (width * height)\n      })\n  }) |&gt;\n  unlist() |&gt;\n  max()\n\n[1] 4739623064"
  },
  {
    "objectID": "2025/09/2025-09.html#part-2",
    "href": "2025/09/2025-09.html#part-2",
    "title": "Movie Theater",
    "section": "Part 2",
    "text": "Part 2\nVery pleased with this one. I had this whole convoluted solution actually plotting out the green tiles but then was like “how do I check if something is in a polygon?” and realized I do know how to do that. geos is great for stuff like this. It’s super fast and easy to work with unlike sf. Unfortunately geos::geos_area() didn’t work because these are points on a grid and not a lat/long. There’s probably a CRS I could’ve used but I didn’t.\n\npoints &lt;-\n  'input.txt' |&gt;\n  readLines() |&gt;\n  stringr::str_split(',') |&gt;\n  purrr::map(as.numeric)\n\npolygon_points &lt;-\n  points |&gt;\n  append(points[1]) |&gt;\n  do.call(rbind, args = _)\n\npolygon &lt;- \n  geos::geos_make_polygon(x = polygon_points[,1], y = polygon_points[,2])\n\nchosen_one &lt;-\n  expand.grid(\n    'i' = seq_along(points),\n    'j' = seq_along(points)\n  ) |&gt;\n  dplyr::filter(.data$j &gt; .data$i) |&gt;\n  dplyr::mutate(\n    'rectangle' = purrr::map2_vec(.data$i, .data$j, \\(i, j) {\n      geos::geos_create_rectangle(\n        points[[i]][1], points[[i]][2], \n        points[[j]][1], points[[j]][2]\n      )\n    }),\n    'covers' = geos::geos_contains(.env$polygon, .data$rectangle)\n  ) |&gt;\n  dplyr::filter(.data$covers) |&gt;\n  dplyr::mutate(\n    'area' = purrr::map2_dbl(.data$i, .data$j, \\(i, j) {\n      width &lt;- abs(points[[i]][1] - points[[j]][1]) + 1\n      height &lt;- abs(points[[i]][2] - points[[j]][2]) + 1\n      if (width == 0) width &lt;- 1\n      if (height == 0) height &lt;- 1\n      (width * height)\n    })\n  ) |&gt;\n  dplyr::filter(.data$area == max(.data$area))\nplot(c(polygon, chosen_one$rectangle))\n\n\n\n\n\n\nchosen_one$area\n\n[1] 1654141440"
  },
  {
    "objectID": "2022/02/2022-02.html",
    "href": "2022/02/2022-02.html",
    "title": "Rock Paper Scissors",
    "section": "",
    "text": "library(tidyverse)\nlibrary(data.table)\ndt &lt;- fread(\"input.txt\", header = FALSE)\n# dt &lt;- readLines(\"input.txt\")\nThis isn’t so bad, just rock, paper, scissors."
  },
  {
    "objectID": "2022/02/2022-02.html#part-1",
    "href": "2022/02/2022-02.html#part-1",
    "title": "Rock Paper Scissors",
    "section": "Part 1",
    "text": "Part 1\nI initially did V1 == V2 but that doesn’t work with ABC and XYZ, but a quick fix put me at 549 on the leaderboard so I’m really pleased.\n\ndt %&gt;%\n  mutate(\"my_score\" = case_when(\n    V2 == \"X\" ~ 1,\n    V2 == \"Y\" ~ 2,\n    V2 == \"Z\" ~ 3\n  )) %&gt;%\n  mutate(\"win_score\" = case_when(\n    (V1 == \"A\" & V2 == \"X\") | (V1 == \"B\" & V2 == \"Y\") | (V1 == \"C\" & V2 == \"Z\") ~ 3,\n    V1 == \"A\" & V2 == \"Y\" ~ 6,\n    V1 == \"A\" & V2 == \"Z\" ~ 0,\n    V1 == \"B\" & V2 == \"X\" ~ 0,\n    V1 == \"B\" & V2 == \"Z\" ~ 6,\n    V1 == \"C\" & V2 == \"X\" ~ 6,\n    V1 == \"C\" & V2 == \"Y\" ~ 0\n  )) %&gt;%\n  mutate(\"score\" = my_score + win_score) %&gt;%\n  pull(\"score\") %&gt;%\n  sum()\n\n[1] 14163"
  },
  {
    "objectID": "2022/02/2022-02.html#part-2",
    "href": "2022/02/2022-02.html#part-2",
    "title": "Rock Paper Scissors",
    "section": "Part 2",
    "text": "Part 2\nI had this one pretty quick, just a bit of logic to get the play column right. Of course, I then had to remember to change all the right V2 references which took me a minute to figure out when I missed the second mutate.\n\ndt %&gt;%\n  mutate(\"play\" = case_when(\n    V2 == \"X\" & V1 == \"A\" ~ \"Z\",\n    V2 == \"X\" & V1 == \"B\" ~ \"X\",\n    V2 == \"X\" & V1 == \"C\" ~ \"Y\",\n    V2 == \"Y\" & V1 == \"A\" ~ \"X\",\n    V2 == \"Y\" & V1 == \"B\" ~ \"Y\",\n    V2 == \"Y\" & V1 == \"C\" ~ \"Z\",\n    V2 == \"Z\" & V1 == \"A\" ~ \"Y\",\n    V2 == \"Z\" & V1 == \"B\" ~ \"Z\",\n    V2 == \"Z\" & V1 == \"C\" ~ \"X\",\n  )) %&gt;%\n  mutate(\"my_score\" = case_when(\n    play == \"X\" ~ 1,\n    play == \"Y\" ~ 2,\n    play == \"Z\" ~ 3\n  )) %&gt;%\n  mutate(\"win_score\" = case_when(\n    (V1 == \"A\" & play == \"X\") | (V1 == \"B\" & play == \"Y\") | (V1 == \"C\" & play == \"Z\") ~ 3,\n    V1 == \"A\" & play == \"Y\" ~ 6,\n    V1 == \"A\" & play == \"Z\" ~ 0,\n    V1 == \"B\" & play == \"X\" ~ 0,\n    V1 == \"B\" & play == \"Z\" ~ 6,\n    V1 == \"C\" & play == \"X\" ~ 6,\n    V1 == \"C\" & play == \"Y\" ~ 0\n  )) %&gt;%\n  mutate(\"score\" = my_score + win_score) %&gt;%\n  pull(\"score\") %&gt;%\n  sum()\n\n[1] 12091"
  },
  {
    "objectID": "2022/04/2022-04.html",
    "href": "2022/04/2022-04.html",
    "title": "Camp Cleanup",
    "section": "",
    "text": "library(tidyverse)\nlibrary(data.table)\ndt &lt;- fread(\"input.txt\", header = FALSE)\nThis looks bad at first, but it’s not."
  },
  {
    "objectID": "2022/04/2022-04.html#part-1",
    "href": "2022/04/2022-04.html#part-1",
    "title": "Camp Cleanup",
    "section": "Part 1",
    "text": "Part 1\nIt took me a minute to figure out how I wanted to work with the data ranges. I started with mutate then lapply then quickly switched to mapply. From there it wrote itself. I then second-guessed my answer and divided by two because I thought I was double reporting the ranges. I cost myself a minute :(\n\nmapply(\\(x, y) {\n  x &lt;- as.numeric(unlist(strsplit(x, \"-\")))\n  y &lt;- as.numeric(unlist(strsplit(y, \"-\")))\n  \n  all(x[1]:x[2] %in% y[1]:y[2]) | all(y[1]:y[2] %in% x[1]:x[2])\n}, dt$V1, dt$V2) |&gt;\n  unlist() |&gt;\n  table() %&gt;%\n  .[\"TRUE\"]\n\nTRUE \n 532"
  },
  {
    "objectID": "2022/04/2022-04.html#part-2",
    "href": "2022/04/2022-04.html#part-2",
    "title": "Camp Cleanup",
    "section": "Part 2",
    "text": "Part 2\n38 seconds for part 2! I just had to change all to any.\n\nmapply(\\(x, y) {\n  x &lt;- as.numeric(unlist(strsplit(x, \"-\")))\n  y &lt;- as.numeric(unlist(strsplit(y, \"-\")))\n  \n  any(x[1]:x[2] %in% y[1]:y[2]) | any(y[1]:y[2] %in% x[1]:x[2])\n}, dt$V1, dt$V2) |&gt;\n  unlist() |&gt;\n  table() %&gt;%\n  .[\"TRUE\"]\n\nTRUE \n 854"
  },
  {
    "objectID": "2024/02/2024-02.html",
    "href": "2024/02/2024-02.html",
    "title": "Red-Nosed Reports",
    "section": "",
    "text": "library(mistlecode)\n\noptions(scipen = 999)\ndt &lt;-\n  'input.txt' |&gt;\n  readLines() |&gt;\n  strsplit(' ') |&gt;\n  purrr::map(as.integer)"
  },
  {
    "objectID": "2024/02/2024-02.html#part-1",
    "href": "2024/02/2024-02.html#part-1",
    "title": "Red-Nosed Reports",
    "section": "Part 1",
    "text": "Part 1\nI missed the second condition for a pass at first. Mildly annoying, but not too bad globally.\n\ndt |&gt;\n  purrr::map_lgl(\\(x) {\n    x &lt;- x - lag(x)\n    x &lt;- x[!is.na(x)]\n    all(abs(x) %in% 1:3) & (all(x &lt; 0) | all(x &gt; 0))\n  }) |&gt; \n  sum()\n\n[1] 686"
  },
  {
    "objectID": "2024/02/2024-02.html#part-2",
    "href": "2024/02/2024-02.html#part-2",
    "title": "Red-Nosed Reports",
    "section": "Part 2",
    "text": "Part 2\nI’m really pleased with this. I was trying something more functional, then realized a simple for loop was the way to go and that resulted in a 495 on the leaderboard. It’s also a good example for whatever it’s called that I did with my returns not just being if statements the whole way down.\n\ntest &lt;- function(x) {\n  x &lt;- x - lag(x)\n  x &lt;- x[!is.na(x)]\n  all(abs(x) %in% 1:3) & (all(x &lt; 0) | all(x &gt; 0))\n}\n\ndt |&gt;\n  purrr::map_lgl(\\(x) {\n    if (test(x)) return(TRUE)\n    for(i in seq_along(x)) {\n      if (test(x[-i])) return(TRUE)\n    }\n    return(FALSE)\n  }) |&gt; \n  sum()\n\n[1] 717"
  },
  {
    "objectID": "2024/04/2024-04.html",
    "href": "2024/04/2024-04.html",
    "title": "Ceres Search",
    "section": "",
    "text": "library(mistlecode)\n\noptions(scipen = 999)\ndt &lt;-\n  readLines(\"input.txt\") |&gt; \n  strsplit('')\n\ndt &lt;-\n  dt |&gt;\n  unlist() |&gt;\n  matrix(ncol = length(dt[[1]]), byrow = TRUE)"
  },
  {
    "objectID": "2024/04/2024-04.html#part-1",
    "href": "2024/04/2024-04.html#part-1",
    "title": "Ceres Search",
    "section": "Part 1",
    "text": "Part 1\nI’m disappointed in myself. I really should have a function to parse input like this by now, but again I sat on my butt and didn’t make one then struggled for it. I also got super duper stuck when my mistlecode::get_diagonal() wasn’t able to pick up diagonals that start in the lower right corner. It’s something I’ll have to go fix. I’ll probably re-do the whole thing to just say ‘top-left’ or ‘bottom-right’ or something to actually say what corner it’s coming off of rather than trying to say how it’s divided. Anyways, I knew I had overlapping diagonals and needed to drop them, but I was dropping them inside count_diag() which wasn’t doing anything except dropping a letter off the diagonals. Once I moved that outside, I was able to recognize my missing corner.\n\ncount &lt;- function(x) {\n  x |&gt;\n    paste0(collapse = '') |&gt;\n    mistlecode::strg_extract_all('XMAS|SAMX') |&gt;\n    unlist() |&gt;\n    length()\n}\n\ncount_diag &lt;- function(x, dim, dir) {\n  x |&gt;\n    purrr::map_int(\\(x) {\n      mistlecode::get_diagonal(dt, x, dim, dir) |&gt;\n        count()\n    }) |&gt;\n    sum()\n}\n\nrows &lt;- dt |&gt; apply(1, count) |&gt; sum()\ncols &lt;- dt |&gt; apply(2, count) |&gt; sum()\n\ndrow &lt;- dt |&gt; nrow() |&gt; seq_len() |&gt; count_diag('row', 'down')\ndcol &lt;- dt |&gt; ncol() |&gt; seq_len() |&gt; tail(-1) |&gt; count_diag('col', 'down')\n\nurow &lt;-\n  dt |&gt; rev() |&gt; `dim&lt;-`(rev(dim(dt))) |&gt;\n  nrow() |&gt; seq_len() |&gt; count_diag('row', 'up')\nucol &lt;-\n  dt |&gt;  rev() |&gt; `dim&lt;-`(rev(dim(dt))) |&gt;\n  ncol() |&gt; seq_len() |&gt; tail(-1) |&gt; count_diag('col', 'up')\n\nrows + cols + drow + dcol + urow + ucol\n\n[1] 2524"
  },
  {
    "objectID": "2024/04/2024-04.html#part-2",
    "href": "2024/04/2024-04.html#part-2",
    "title": "Ceres Search",
    "section": "Part 2",
    "text": "Part 2\nThankfully this was much easier. It was a small struggle adapting my count() which I really didn’t need to do if I hadn’t been so eager to paste0() in my for loop. But if it works, it works, and it was much much faster than part 1.\n\ndt[dt == 'X'] &lt;- ''\n\ncount &lt;- function(x) {\n  x |&gt;\n    stringr::str_count('MAS|SAM') |&gt;\n    sum()\n}\n\ntally &lt;- logical()\nfor (r in seq_len(nrow(dt) - 2)) {\n  for (c in seq_len(ncol(dt) - 2)) {\n    x &lt;- dt[r:(r+2), c:(c+2)]\n    if (x[2, 2] != 'A') next\n    left_right &lt;- paste0(c(x[1,1], x[2,2], x[3,3]), collapse = '')\n    right_left &lt;- paste0(c(x[1,3], x[2,2], x[3,1]), collapse = '')\n    valid &lt;- count(c(left_right, right_left)) == 2\n    if (valid) tally &lt;- c(tally, valid)\n  }\n}\ntally |&gt;\n  sum()\n\n[1] 1873"
  },
  {
    "objectID": "2024/07/2024-07.html",
    "href": "2024/07/2024-07.html",
    "title": "Bridge Repair",
    "section": "",
    "text": "library(mistlecode)\n\noptions(scipen = 999)\nmat &lt;-\n  'input.txt' |&gt;\n  readLines() |&gt;\n  stringr::str_split(':| ', simplify = TRUE) |&gt;\n  mistlecode::cast_matrix(as.numeric)\nmat &lt;- mat[,-2]"
  },
  {
    "objectID": "2024/07/2024-07.html#part-1",
    "href": "2024/07/2024-07.html#part-1",
    "title": "Bridge Repair",
    "section": "Part 1",
    "text": "Part 1\nOkay. At first glance this is some fancy math one that I don’t know enough math to do correctly. After fiddling around a bit and getting it working on the test input, it was time to move to the real one. For ages I kept getting the same wrong output. I thought that maybe it’s because I needed bit64 for 64 bit integers and spent way too long screwing around with that then eventually realized that not only was my input not being read properly (that seems to be a theme this year…), but that the numbers can be double and that solves all my problems. They’re still whole numbers, just not integers. After realizing that, it was a lot of head scratching until I realized that my if statement with return(total) was inside my second for loop when it should be after it. Fixing that led to a victory.\n\ntotals &lt;-\n  mat |&gt;\n  apply(1, \\(r) {\n    target &lt;- r[1]; r &lt;- r[-1]; r &lt;- r[!is.na(r)];\n    grid &lt;- expand.grid(rlang::inject(rep(list(c('*', '+')), length(r) - 1)))\n    for (g in seq_len(nrow(grid))) {\n      ops &lt;- grid[g,] |&gt; unlist() |&gt; unname(); total &lt;- 0;\n      for (i in seq_along(r)[-1]) {\n        if (i == 2) {\n          total &lt;- if (ops[i-1] == '+') r[i-1] + r[i] else r[i-1] * r[i]\n        } else {\n          total &lt;- if (ops[i-1] == '+') total + r[i] else total * r[i]\n        }\n      }\n      if (target == total) return(total)\n    }\n    return(0)\n  }) \npart1 &lt;-\n  totals |&gt; \n  sum() |&gt;\n  print()\n\n[1] 945512582195"
  },
  {
    "objectID": "2024/07/2024-07.html#part-2",
    "href": "2024/07/2024-07.html#part-2",
    "title": "Bridge Repair",
    "section": "Part 2",
    "text": "Part 2\nI spent a while on part 2 as well, but had more of a plan than part 1. I initially had a cool little recursion method that used the same expand.grid and collapsed the string in on itself. It ultimately didn’t end up working and I’m not really sure why. Moving the operations into a function helped make things more readable and then it was just a matter of collapsing the string the right way every time and waiting a while for everything to run. After getting my answer I realized I could reduce grid even further by filtering for rows that contain a concatenate operation since the new numbers must have one.\n\ntictoc::tic()\nfuture::plan(future::multisession, workers = future::availableCores())\nprogressr::with_progress({\n  do_op &lt;- function(x, y, op) {\n    x &lt;- \n      if (op == '*') x * y else if (op == '+') x + y else paste0(x, y, collapse = '')\n    as.numeric(x)\n  }\n  \n  mat2 &lt;- mat[totals == 0,] \n  p &lt;- progressr::progressor(steps = nrow(mat2))\n  mat2 |&gt;\n    nrow() |&gt;\n    seq_len() |&gt;\n    furrr::future_map_dbl(\\(rr) {\n      p()\n      rr &lt;- mat2[rr,]\n      target &lt;- rr[1]; rr &lt;- rr[-1]; rr &lt;- rr[!is.na(rr)];\n      grid &lt;- \n        expand.grid(rlang::inject(rep(list(c('*', '+', '|')), length(rr) - 1))) |&gt;\n        dplyr::filter(dplyr::if_any(tidyselect::everything(), \\(x) x == '|'))\n      for (g in seq_len(nrow(grid))) {\n        ops &lt;- grid[g,] |&gt; unlist() |&gt; as.character()\n        r &lt;- rr; i &lt;- 1;\n        repeat {\n          if (r[1] &gt; target || i &gt; length(ops)) break\n          x &lt;- do_op(r[1], r[2], ops[i])\n          r &lt;- c(x, utils::tail(r, -2))\n          i &lt;- i + 1\n        }\n        if (isTRUE(r == target)) return(r)\n      }\n      return(0)\n    }) |&gt;\n    sum(part1)\n}, handlers = progressr::handler_cli())\n\n[1] 2.716911e+14\n\nfuture::plan(future::sequential())\ntictoc::toc()\n\n408.647 sec elapsed"
  },
  {
    "objectID": "2023/01/2023-01.html",
    "href": "2023/01/2023-01.html",
    "title": "Trebuchet?!",
    "section": "",
    "text": "library(mistlecode)\n\noptions(scipen = 999)\ndt &lt;- readLines(\"input.txt\")"
  },
  {
    "objectID": "2023/01/2023-01.html#part-1",
    "href": "2023/01/2023-01.html#part-1",
    "title": "Trebuchet?!",
    "section": "Part 1",
    "text": "Part 1\nThis wasn’t too bad. Just forgot to unlist initially.\n\ndt |&gt;\n   sapply(\\(x) {\n     x |&gt;\n      str_extract_all('[0-9]') |&gt;\n      unlist() -&gt; y\n    glue::glue('{head(y, 1)}{tail(y, 1)}')\n  }) |&gt;\n  as.numeric() |&gt;\n  sum()\n\n[1] 56397"
  },
  {
    "objectID": "2023/01/2023-01.html#part-2",
    "href": "2023/01/2023-01.html#part-2",
    "title": "Trebuchet?!",
    "section": "Part 2",
    "text": "Part 2\nThis took way too long and I hate incomplete examples. Absolutely no indication that oneight flips for both 1 and 8.\n\nnumbers &lt;-\n  c(\n    'one' = 1,\n    'two' = 2,\n    'three' = 3,\n    'four' = 4,\n    'five' = 5,\n    'six' = 6,\n    'seven' = 7,\n    'eight' = 8,\n    'nine' = 9\n  )\ndt |&gt;\n  sapply(\\(x) {\n    n &lt;- c(names(numbers), '[1-9]')\n    i &lt;-\n      x |&gt;\n      stringi::stri_locate_all_regex(n, omit_no_match = TRUE) |&gt;\n      lapply(data.frame) |&gt;\n      purrr::list_rbind() |&gt;\n      dplyr::pull(start) |&gt;\n      order()\n    x &lt;-\n      stringi::stri_match_all_regex(x, n) |&gt;\n      unlist() |&gt;\n      purrr::discard(is.na)\n    y &lt;- ifelse(x %in% names(numbers), numbers[x], x)[i]\n    glue::glue('{head(y, 1)}{tail(y, 1)}')\n  }) |&gt;\n  as.numeric() |&gt;\n  sum()\n\n[1] 55701"
  },
  {
    "objectID": "2023/03/2023-03.html",
    "href": "2023/03/2023-03.html",
    "title": "Gear Ratios",
    "section": "",
    "text": "library(mistlecode)\n\noptions(scipen = 999)\ndt &lt;- \n  readLines(\"input.txt\") |&gt;\n  stringr::str_split(\"\")\n\nm &lt;- matrix(unlist(dt), nrow = length(dt), byrow = TRUE)"
  },
  {
    "objectID": "2023/03/2023-03.html#part-1",
    "href": "2023/03/2023-03.html#part-1",
    "title": "Gear Ratios",
    "section": "Part 1",
    "text": "Part 1\nThis was so much fun! I love dbscan with all my heart. I also did something really stupid and submitted the test input then had to wait the longest minute of my life to submit the real answer.\n\ndt &lt;- mistlecode::matrix_to_coords(m)\nclust &lt;-\n  dt |&gt;\n  dplyr::filter(data != \".\") |&gt;\n  dplyr::select(-data) |&gt;\n  dbscan::dbscan(sqrt(2), minPts = 2)\ndt &lt;- \n  dt |&gt;\n  dplyr::filter(data != \".\") |&gt;\n  dplyr::mutate(clust = clust$cluster) |&gt;\n  dplyr::filter(any(!grepl('[0-9]', data)), .by = 'clust')\nnumbers &lt;-\n  mistlecode::coords_to_matrix(dt$data, dt$row, dt$col) |&gt;\n  t() |&gt;\n  as.vector() |&gt;\n  paste0(collapse = \"\") |&gt;\n  stringr::str_replace_all('[^0-9]', ' ') |&gt;\n  stringr::str_split(' ') |&gt;\n  unlist() |&gt;\n  as.numeric() |&gt;\n  purrr::discard(is.na)\nsum(numbers, na.rm = TRUE)\n\n[1] 520019"
  },
  {
    "objectID": "2023/03/2023-03.html#part-2",
    "href": "2023/03/2023-03.html#part-2",
    "title": "Gear Ratios",
    "section": "Part 2",
    "text": "Part 2\nThis is really long-winded. I’m sure it could be better functionalized. The hard part wasn’t as much figuring out what goes in a group as much as figuring out what goes in which group.\n\ndt &lt;- mistlecode::matrix_to_coords(m)\nnumber_clust &lt;-\n  dt |&gt;\n  dplyr::filter(grepl('[0-9]', data)) |&gt;\n  dplyr::select(-data) |&gt;\n  dbscan::dbscan(1, minPts = 1)\nnumber_dt &lt;-\n  dt |&gt;\n  dplyr::filter(grepl('[0-9]', data)) |&gt;\n  dplyr::mutate(number_clust = number_clust$cluster)\nclust_dt &lt;- \n  dt |&gt;\n  dplyr::filter(data != \".\") |&gt;\n  dplyr::mutate(clust = clust$cluster) |&gt;\n  dplyr::left_join(number_dt, by = dplyr::join_by(data, row, col)) |&gt;\n  dplyr::filter(any(!grepl('[0-9]', data)), .by = 'clust') |&gt;\n  dplyr::mutate(\n    has_prod = any(data == '*') & length(unique(number_clust[!is.na(number_clust)])) == 2,\n    prod_group = dplyr::cur_group_id(),\n    .by = 'clust'\n  ) |&gt;\n  dplyr::filter(grepl('[0-9]', data))\nhas_prod &lt;-\n  mistlecode::coords_to_matrix(clust_dt$prod_group, clust_dt$row, clust_dt$col) |&gt;\n  t() |&gt;\n  as.vector() |&gt;\n  data.frame() |&gt;\n  `colnames&lt;-`('has_prod') |&gt;\n  dplyr::mutate(t = cumsum(is.na(has_prod))) |&gt;\n  dplyr::filter(dplyr::row_number() == dplyr::n() & !is.na(has_prod), .by = 't') |&gt;\n  dplyr::pull(has_prod)\n\ndata.frame(\n  has_prod,\n  numbers\n) |&gt;\n  dplyr::filter(dplyr::n() &gt;= 2, .by = has_prod) |&gt;\n  dplyr::summarise(val = prod(numbers), .by = has_prod) |&gt;\n  dplyr::pull(val) |&gt;\n  sum()\n\n[1] 75519888"
  },
  {
    "objectID": "2023/08/2023-08.html",
    "href": "2023/08/2023-08.html",
    "title": "Haunted Wasteland",
    "section": "",
    "text": "library(mistlecode)\n\noptions(scipen = 999)\nfile &lt;- 'input.txt'\n\ndir &lt;- \n  file |&gt;\n  readLines(n = 1) |&gt;\n  stringr::str_split_1('')\n  \ndt &lt;-\n  file |&gt;\n  readr::read_csv(skip = 2, trim_ws = TRUE, col_names = FALSE) |&gt;\n  tidyr::separate(X1, into = c('start', 'L'), sep = ' = \\\\(') |&gt;\n  dplyr::mutate('R' = stringr::str_remove_all(.data$X2, '\\\\)')) |&gt;\n  dplyr::select(-'X2')\n\nRegistered S3 methods overwritten by 'bit64':\n  method               from  \n  as.double.integer64  cheapr\n  as.integer.integer64 cheapr\n\n\nRows: 718 Columns: 2\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (2): X1, X2\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message."
  },
  {
    "objectID": "2023/08/2023-08.html#part-1",
    "href": "2023/08/2023-08.html#part-1",
    "title": "Haunted Wasteland",
    "section": "Part 1",
    "text": "Part 1\nI have evidence that I struggled some other time, but I have no recollection. This was pretty easy, just had an off-by-one to deal with to get around the modulo of length sometimes being zero.\n\nstart &lt;- function(end, dir) {\n  dt[[dir]][dt$start == end]\n}\n\ncount &lt;- 0\nend &lt;- 'AAA'\nrepeat {\n  end &lt;- start(end, dir[(count %% length(dir)) + 1])\n  if (end == 'ZZZ') break else count &lt;- count + 1\n}\ncount + 1\n\n[1] 17141"
  },
  {
    "objectID": "2023/08/2023-08.html#part-2",
    "href": "2023/08/2023-08.html#part-2",
    "title": "Haunted Wasteland",
    "section": "Part 2",
    "text": "Part 2\nI hate when there’s a fancy math way. It’s just least common multiples this time and I’m super dumb for not thinking of this sooner. I did have to be careful with match instead of %in% because that would return the indices in the incorrect order and cause everything to fail.\n\nstart &lt;- function(end, dir) {\n  dt[[dir]][match(end, dt$start)]\n}\n\ncount &lt;- 0\nend &lt;-\n  dt |&gt;\n    dplyr::filter(grepl('A$', .data$start)) |&gt;\n    dplyr::pull(.data$start)\ntargets &lt;-\n  dt |&gt;\n    dplyr::filter(grepl('Z$', .data$start)) |&gt;\n    dplyr::pull(.data$start)\ntarget_pos &lt;- integer(length(end))\nrepeat {\n  end &lt;- start(end, dir[(count %% length(dir)) + 1])\n  if (any(end %in% targets)) {\n    target_pos[end %in% targets] &lt;- count\n    if (!any(target_pos == 0)) break\n  }\n  count &lt;- count + 1\n}\ncheapr::scm(target_pos + 1)\n\n[1] 10818234074807"
  },
  {
    "objectID": "2022/21/2022-21.html",
    "href": "2022/21/2022-21.html",
    "title": "Monkey Math",
    "section": "",
    "text": "This…doesn’t actually look too bad. Part 2 will probably be a nightmare.\nlibrary(mistlecode)\n#remotes::install_github(\"rconsortium/OOP-WG\")\nlibrary(S7)\noptions(scipen = 999)\ndt &lt;- \n  readLines(\"input.txt\") |&gt;\n  str_split(\": \")"
  },
  {
    "objectID": "2022/21/2022-21.html#part-1",
    "href": "2022/21/2022-21.html#part-1",
    "title": "Monkey Math",
    "section": "Part 1",
    "text": "Part 1\nLet’s take a chance to use S7 for the first time! I can build on the bits I learned with S3 in 2022-11. The idea to use a vector of monkey names (index) made it really easy to make sure I was pulling info from the right monkeys, rather than needing to iterate over the entire list. There’s probably a better approach overall with a more recursive solution, but this seems to work fine for Part 1, although I’m worried about Part 2.\nNote (2023-04-23): I just updated to R 4.3 and the latest version of R7 which is now S7 and I was unable to run the previous version which used recursion due to a C-stack error. I swapped over to a while loop based version and that seems to be working fine.\n\nmonkey &lt;- new_class(\n  name = \"monkey\",\n  properties = list(\n    name = class_character,\n    val = class_any,\n    op = class_character\n  )\n)\n\nnew_monkey &lt;- function(x) {\n  if (!is.na(suppressWarnings(as.numeric(x[2])))) {\n    val &lt;- as.numeric(x[2])\n    op &lt;- NA_character_\n  } else {\n    val &lt;- NA\n    op &lt;- x[2]\n  }\n  monkey(\n    name = x[1],\n    val = val,\n    op = op\n  )\n}\n\nmonkeys &lt;- lapply(dt, new_monkey)\nmasterMonkeys &lt;- monkeys\nindex &lt;- sapply(monkeys, \\(x) x@name)\n\nmonkey_math &lt;- function(monkeys, op) {\n  m1 &lt;- monkeys[[which(index == op[1])]]@val\n  m2 &lt;- monkeys[[which(index == op[3])]]@val\n  \n  if (!is.na(m1) & !is.na(m2)) {\n    if (op[2] == \"+\") { m1 + m2 }\n    else if (op[2] == \"-\") { m1 - m2 }\n    else if (op[2] == \"*\") { m1 * m2 }\n    else if (op[2] == \"/\") { m1 / m2 }\n  } else { return(NA_integer_) }\n}\n\nm &lt;- monkeys\nbreakFlag &lt;- FALSE\nwhile(!breakFlag) {\n  n &lt;- 1\n  while (n &lt;= length(monkeys)) {\n    if (is.na(monkeys[[n]]@val)) {\n      val &lt;- str_split_1(monkeys[[n]]@op, \" \")\n      monkeys[[n]]@val &lt;- monkey_math(monkeys, val)\n    }\n    if (monkeys[[n]]@name == \"root\" & !is.na(monkeys[[n]]@val)) {\n      breakFlag &lt;- TRUE\n      break\n    }\n    n &lt;- n + 1\n  }\n}\nmonkeys[[n]]@val\n\n[1] 93813115694560"
  },
  {
    "objectID": "2022/21/2022-21.html#part-2",
    "href": "2022/21/2022-21.html#part-2",
    "title": "Monkey Math",
    "section": "Part 2",
    "text": "Part 2\nI tried brute-forcing it… It took a while to fully figure out what I wanted to do, but the idea behind just making a giant equation then solving for humn was there early on. I started by expanding the input by replacing monkeys with their value if they had one or operation if they didn’t. I then replaced all the monkeys with their values, just like in Part 1. This left me with a giant expression where the only variable was humn. I just wasn’t sure how to actually solve equations in R so I kept trying to brute-force it, which kept on not working. I eventually found the Ryacas package which made quick work of everything.\n\nmonkeys &lt;- lapply(dt, new_monkey)\n\nroot_op &lt;- \n  str_extract(monkeys[[which(index == \"root\")]]@op, \"(\\\\+|\\\\-|\\\\*|\\\\/)\")\nmonkeys[[which(index == \"root\")]]@op &lt;- \n  gsub(paste0(\"\\\\\", root_op), \"=\", monkeys[[which(index == \"root\")]]@op)\n\nm1 &lt;- str_split_1(monkeys[[which(index == \"root\")]]@op, \" = \")\nm2 &lt;- m1[2]\nm1 &lt;- m1[1]\n\nreplace_monkey &lt;- function(m) {\n  w &lt;- which(index == m)\n  if (length(w) == 0) { return(m) }\n  v &lt;- monkeys[[w]]@val\n  if (is.na(v)) { return(paste0(\"( \", monkeys[[which(index == m)]]@op, \" )\")) }\n  return(paste0(\"( \", v, \" )\"))\n}\n\n# https://stackoverflow.com/a/14838753\nquotemeta &lt;- function(string) { str_replace_all(string, \"(\\\\W)\", \"\\\\\\\\\\\\1\") }\n\nreduce_string &lt;- function(mm, pattern) {\n  r &lt;-\n    str_extract_all(mm, pattern) |&gt;\n    unlist() |&gt;\n    sapply(\\(r) {\n      if (grepl(\"h\", r)) { return(r) }\n      else { eval(parse(text = r)) }\n    })\n  \n  for (i in 1:length(r)) {\n    mm &lt;- str_replace_all(mm, quotemeta(names(r)[i]), as.character(r[i]))\n  }\n  return(mm)\n}\n\nprocess_string &lt;- function(m) {\n  while (any(grepl(\"([^(h)][a-z])\", m))) {\n    m &lt;- \n      sapply(m, \\(mm) { replace_monkey(mm) }) |&gt;\n      paste0(collapse = \" \") |&gt;\n      str_split_1(\" \")\n  }\n  m &lt;- paste0(m, collapse = \"\")\n  oldM &lt;- 0\n  while (length(m) == 1 && oldM != m) {\n    oldM &lt;- m\n    m &lt;- reduce_string(m, \"\\\\((\\\\d+|h)\\\\)[\\\\+|\\\\-|\\\\*|\\\\/]\\\\((\\\\d+|h)\\\\)\")\n  }\n  return(oldM)\n}\n\nmonkeys[[which(index == \"humn\")]]@val &lt;- \"h\"\nmm1 &lt;- process_string(m1)\nmm2 &lt;- process_string(m2)\n\npaste(\n    reduce_string(mm1, \"\\\\((\\\\d+|h)\\\\)\"), \n    \"==\", \n    reduce_string(mm2, \"\\\\((\\\\d+|h)\\\\)\")\n  ) %&gt;%\n  Ryacas::y_fn(\"Solve\", \"h\") |&gt;\n  Ryacas::yac_str() |&gt;\n  str_extract(\"\\\\d+\") |&gt;\n  as.numeric()\n\n[1] 3910938071092"
  },
  {
    "objectID": "2022/11/2022-11.html",
    "href": "2022/11/2022-11.html",
    "title": "Monkey in the Middle",
    "section": "",
    "text": "library(mistlecode)\ndt &lt;- readLines(\"input.txt\")\n\ndt &lt;- \n  data.frame(dt) |&gt;\n  mutate(monkey = cumsum(grepl(\"Monkey \\\\d+:\", dt)) - 1) |&gt;\n  filter(dt != \"\")\nOh no. I’m going to bed."
  },
  {
    "objectID": "2022/11/2022-11.html#part-1",
    "href": "2022/11/2022-11.html#part-1",
    "title": "Monkey in the Middle",
    "section": "Part 1",
    "text": "Part 1\nThis was so much fun! I dipped my toes into S3 classes, made a useful function factory, and did some recursion. I had a bit of trouble making sure my list of monkeys was getting passed around properly and returned because loops can’t change objects in the global environment. That said, I have a bad feeling about part 2.\n\noperation &lt;- function(op, val) {\n  function(old) {\n    if (val == \"old\") { val &lt;- as.integer(old) } \n    else { val &lt;- as.integer(val) }\n    \n    if (op == \"*\") { val &lt;- old * val }\n    else if (op == \"+\") { val &lt;- old + val }\n    \n    return(val)\n  }\n}\n\nnew_monkey &lt;- function(dt, x) {\n  name &lt;- str_extract(dt[1,\"dt\"], \"\\\\d+\")\n  items &lt;- \n    str_split(dt[2,\"dt\"], \":|,\", simplify = TRUE)[1,-1] |&gt; as.numeric()\n  opp &lt;- \n    str_split(dt[3, \"dt\"], \"=\", simplify = TRUE)[1,2] |&gt;\n    str_match(\" (new|old) (\\\\+|\\\\-|\\\\*|\\\\/) (old|\\\\d+)\")\n  op_op &lt;- opp[1,3]\n  op_num &lt;- ifelse(opp[1,4])\n  op &lt;- operation(op = opp[1,3], val = opp[1,4])\n  test &lt;- str_extract(dt[4,\"dt\"], \"\\\\d+\") |&gt; as.integer()\n  case_true &lt;- str_extract(dt[5,\"dt\"], \"\\\\d+\")\n  case_false &lt;- str_extract(dt[6,\"dt\"], \"\\\\d+\")\n  x &lt;- list(\n    \"name\" = name,\n    \"items\" = items,\n    \"operation\" = op,\n    \"test\" = test,\n    \"case_true\" = case_true,\n    \"case_false\" = case_false,\n    \"inspections\" = 0\n  )\n  structure(x, class = \"monkey\")\n}\n\nmonkeys &lt;- \n  lapply(unique(dt$monkey), \\(m) { \n    new_monkey(dt[dt$monkey == m,], m) \n  })\nnames(monkeys) &lt;- sapply(monkeys, \\(m) m$name)\n\nprocess_items &lt;- function(item, monkey, these_monkeys) {\n  if (is.na(monkey$items[item]) | \n      item &gt; length(monkey$items)) { return(these_monkeys) }\n  worry_level &lt;- monkey$operation(monkey$items[item])\n  worry_level &lt;- floor(worry_level / 3)\n  if (worry_level %% monkey$test == 0) {\n    case_true &lt;- \n      c(these_monkeys[[monkey$case_true]]$items, worry_level)\n    these_monkeys[[monkey$case_true]]$items &lt;- \n      case_true[!is.na(case_true)]\n  } else {\n    case_false &lt;- \n      c(these_monkeys[[monkey$case_false]]$items, worry_level)\n    these_monkeys[[monkey$case_false]]$items &lt;- \n      case_false[!is.na(case_false)]\n  }\n  process_items(item + 1, monkey, these_monkeys)\n}\n\nprocess_monkey &lt;- function(i, these_monkeys) {\n  if (i == length(monkeys) + 1) { return(these_monkeys) }\n  monkey &lt;- these_monkeys[[i]]\n  these_monkeys &lt;- process_items(1, monkey, these_monkeys)\n  monkey$inspections &lt;- \n    sum(monkey$inspections, length(monkey$items), na.rm = TRUE)\n  monkey$items &lt;- as.numeric(NA)\n  these_monkeys[[i]] &lt;- monkey\n  process_monkey(i + 1, these_monkeys)\n}\n\nround &lt;- function(these_monkeys, round) {\n  if (round == round_max + 1) { return(these_monkeys) }\n  these_monkeys &lt;- process_monkey(1, these_monkeys)\n  round(these_monkeys, round + 1)\n}\n\n\nround_max &lt;- 20\nm &lt;- round(monkeys, 1)\nsapply(m, \\(m) m$inspections) |&gt;\n  sort(decreasing = TRUE) |&gt;\n  head(2) |&gt;\n  prod()\n\n[1] 316888"
  },
  {
    "objectID": "2022/11/2022-11.html#part-2",
    "href": "2022/11/2022-11.html#part-2",
    "title": "Monkey in the Middle",
    "section": "Part 2",
    "text": "Part 2\nI want to scream. I submitted my answer just to see and it’s right, even though the test input was wrong. I could’ve submitted yesterday 😭 So many hours devoted to these monkeys for nothing…\nI figured out the worry_level %% prod(tests) thing pretty quick after part 1, but it took a full day because the test input never lined up, even if I got super close. I still want to figure out why that is, but for now I’m just happy to have the star.\n\nprocess_items &lt;- function(item, monkey, these_monkeys) {\n  if (is.na(monkey$items[item]) | \n      item &gt; length(monkey$items)) { return(these_monkeys) }\n  worry_level &lt;- monkey$operation(monkey$items[item])\n  case &lt;- (worry_level %% monkey$test) == 0\n  worry_level &lt;- worry_level %% prod(tests)\n  if (case) {\n    case_true &lt;- \n      c(these_monkeys[[monkey$case_true]]$items, worry_level)\n    these_monkeys[[monkey$case_true]]$items &lt;- \n      case_true[!is.na(case_true)]\n  } else {\n    case_false &lt;- \n      c(these_monkeys[[monkey$case_false]]$items, worry_level)\n    these_monkeys[[monkey$case_false]]$items &lt;- \n      case_false[!is.na(case_false)]\n  }\n  process_items(item + 1, monkey, these_monkeys)\n}\n\nm &lt;- monkeys\ntests &lt;- sapply(m, \\(m) m$test)\n\nround_max &lt;- 1\ni &lt;- 1\nwhile (i &lt;= 10000) {\n  m &lt;- process_monkey(1, m)\n  i &lt;- i + 1\n}\n\nsapply(m, \\(m) m$inspections) |&gt;\n  sort(decreasing = TRUE) |&gt;\n  head(2) |&gt;\n  prod()\n\n[1] 35270398814"
  },
  {
    "objectID": "2022/07/2022-07.html",
    "href": "2022/07/2022-07.html",
    "title": "No Space Left On Device",
    "section": "",
    "text": "library(mistlecode)\ndt &lt;- readLines(\"input.txt\")\nwd &lt;- getwd()\nOh no. This will probably use recursion."
  },
  {
    "objectID": "2022/07/2022-07.html#part-1",
    "href": "2022/07/2022-07.html#part-1",
    "title": "No Space Left On Device",
    "section": "Part 1",
    "text": "Part 1\nMy first attempt I just kinda hoped I wouldn’t need recursion. It was silly, but a guy can dream. My next idea was to just create the file system and so that’s what I did. Rather than making the files the size it says, I just filled them with one line holding the size so that I could read it in later. Getting the instructions fleshed out wasn’t too bad. It reminds me a lot of my Cat Simulator 2019 project from Intro to UNIX.\n\ndir.create(\"here_we_go\")\n\nWarning in dir.create(\"here_we_go\"): 'here_we_go' already exists\n\nsetwd(paste0(wd, \"/here_we_go\"))\n\ninvisible(sapply(dt, \\(x) {\n  if(grepl(\"dir \", x)) {\n    d &lt;- str_remove(x, \"dir \")\n    if (!dir.exists(d)) { dir.create(d) }\n  } else if (grepl(\"[0-9]+\", x)) {\n    f &lt;- paste0(str_remove_all(x, \"[0-9 \\\\.]\"), \".txt\")\n    if (!file.exists(f)) {\n      f &lt;- file(f)\n      content &lt;-\n        paste0(as.numeric(paste0(\n          str_extract_all(x, \"\\\\d\", simplify = TRUE), collapse = \"\"\n        )), \"\\n\")\n      cat(content, file = f)\n      close(f)\n    }\n  } else if (grepl(\"\\\\$ cd \\\\.\\\\.\", x)) {\n    setwd(\"../\")\n  } else if (grepl(\"\\\\$ cd \\\\w\", x)) {\n    d &lt;- str_remove(x, \"\\\\$ cd \")\n    if (!dir.exists(d)) { dir.create(d) }\n    setwd(d)\n  } else if (grepl(\"\\\\$ cd /\", x)) {\n    setwd(paste0(wd, \"/here_we_go\")) \n  } else if (!grepl(\"\\\\$ ls|\\\\$ cd /\", x)) { print(x) }\n}))\nsetwd(wd)\n\nGetting this bit working was a pain, but I’m really pleased with it. I had it working on the test input for a while before the real input which was excruciating, but I eventually tracked the problem down to my regex where I remove any file paths. In my earlier step where I repeated file paths then unlisted, any duplicates are assigned a trailing number. In the test input, this number was never more than one digit. In my regex, I was only looking for one digit and so any paths with no digits or more than one digit were missed. With that out of the way, it still doesn’t work. Eventually I realized I was collapsing my paths backwards so all my folder sizes were reversed. Fixing that eventually got me where I needed to be.\n\nv &lt;- \npaste0(\"here_we_go/\", list.files(\"here_we_go\", recursive = TRUE)) |&gt;\n  sapply(\\(x) {\n    count &lt;- str_count(x, \"/\") - 1\n    count &lt;- ifelse(count == 0, 1, count)\n    rep(x, count)\n  }) \npaths &lt;-\n  v |&gt;\n  lapply(\\(x) {\n    xx &lt;- str_remove(x, \"here_we_go/\")\n    sapply(0:(length(x) - 1), \\(x) {\n      if (x == 0) { return(xx) }\n      m &lt;- str_split(xx, \"/\")[[1]]\n      m &lt;- m[-(length(m) - (1:x))]\n      m &lt;- paste0(m, collapse = \"/\")\n      return(m)\n    }) |&gt;\n      unlist() |&gt;\n      unique()\n  }) |&gt;\n  unlist() |&gt;\n  unname()\n\nfiles &lt;- \n  v |&gt;\n  unlist() |&gt;\n  sapply(\\(x) {\n    x &lt;- as.numeric(readLines(x))\n  }) |&gt;\n  data.frame() |&gt;\n  rownames_to_column(var = \"path\") |&gt;\n  `colnames&lt;-`(c(\"full_path\", \"size\")) |&gt;\n  cbind(paths) |&gt;\n  mutate(path = str_remove(paths, \"/\\\\w*\\\\.txt\\\\d*\"))\n  # filter(grepl(\"\\\\.txt\", path)) |&gt;\n  # mutate(path = str_remove(path, \"/\\\\w*\\\\.txt[0-9]?\"))\nfiles |&gt;\n  group_by(path) |&gt;\n    summarise(size = sum(size)) |&gt;\n    arrange(path, .by_group = TRUE) |&gt;\n  ungroup() |&gt;\n  filter(size &lt;= 100000) |&gt;\n  pull(size) |&gt;\n  sum()\n\n[1] 1297683"
  },
  {
    "objectID": "2022/07/2022-07.html#part-2",
    "href": "2022/07/2022-07.html#part-2",
    "title": "No Space Left On Device",
    "section": "Part 2",
    "text": "Part 2\nThis wasn’t too bad. Just took a bit to make the changes needed from part 1. I was briefly stuck when just grouping by path in the second pipeline, but adding the level grouping took care of it and I was good to go!\n\nf &lt;- \n  files |&gt;\n  select(paths, size) |&gt;\n  mutate(path = str_remove(paths, \"/\\\\w*\\\\.txt\\\\d*\")) |&gt;\n  select(-paths) |&gt;\n  unique() |&gt;\n  group_by(path) |&gt;\n    summarise(size = sum(size)) |&gt;\n    ungroup() |&gt;\n  mutate(level = str_count(path, \"/\"))\nhome &lt;- sum(f$size[f$level == 0])\n\nf |&gt;\n  group_by(path, level) |&gt;\n    summarise(size = sum(size), .groups = \"keep\") |&gt;\n    arrange(path, .by_group = TRUE) |&gt;\n    ungroup() |&gt;\n  mutate(free = 70000000 - home,\n         sort = size + free) |&gt;\n  arrange(desc(sort), size) |&gt;\n  filter(sort &gt; 30000000) |&gt;\n  tail(1) |&gt;\n  pull(size)\n\n[1] 5756764"
  }
]