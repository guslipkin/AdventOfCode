{
  "hash": "a122ca776a211cdd3fab71fe2e04e275",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"06: Guard Gallivant\"\nformat: html\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(mistlecode)\n\noptions(scipen = 999)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmat <- \n  'input.txt' |>\n  mistlecode::read_matrix()\n```\n:::\n\n\n\n\n\n## Part 1\n\nThis wasn't too bad. I'd been working on the adjacency function earlier trying to figure out an A* method for older puzzles. Just had to trim some fat and it was good enough. For some reason I struggled with getting the `break` to happen. Initially I just relied on the `mat[y,x]` reference to fail and that's how I submitted, but it's not a good look so I fixed it.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadjacent <- function(point) {\n  y <- point[1]; x <- point[2];\n  list(\n    'up' = c(y-1,x),\n    'down' = c(y+1,x),\n    'left' = c(y,x-1),\n    'right' = c(y,x+1)\n  )\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nguy <- which(mat == '^', arr.ind = TRUE)[1,] |> unname()\nrotate <- c('up' = 'right', 'right' = 'down', 'down' = 'left', 'left' = 'up')\n\ndir <- 'up'\nstep <- 0\nvisited <- matrix(FALSE, nrow(mat), ncol(mat))\nrepeat {\n  visited[guy[1], guy[2]] <- TRUE\n  n <- adjacent(guy)[[dir]]\n  if (!dplyr::between(n[1], 1, nrow(mat)) | !dplyr::between(n[2], 1, ncol(mat))) break\n  if (mat[n[1], n[2]] != '#') guy <- n else dir <- rotate[dir]\n  step <- step + 1\n}\nsum(visited)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4696\n```\n\n\n:::\n:::\n\n\n\n\n\n## Part 2\n\nIt's never a good sign when you resort to `{future}`... But also, I figured a path can't cross itself more than five times without being in a loop. Before figuring that out, my estimated run time on a single core was 6-8 hours.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntictoc::tic()\nstart <- which(mat == '^', arr.ind = TRUE)[1,] |> unname()\nfuture::plan(future::multisession, workers = future::availableCores())\nprogressr::with_progress({\n  df <-\n    visited |> \n    mistlecode::matrix_to_coords() |> \n    dplyr::filter(.data$data) |>\n    dplyr::select(-'data')\n  p <- progressr::progressor(steps = nrow(df))\n  df |>\n  furrr::future_pmap_lgl(\\(row, col) {\n    p()\n    cells <- matrix(0, nrow(mat), ncol(mat))\n    dmat <- mat; dmat[row,col] <- '#';\n    guy <- start; dir <- 'up'; step <- 0;\n    repeat {\n      n <- adjacent(guy)[[dir]]\n      if (n[1] < 1 || n[1] > nrow(dmat) || n[2] < 1 || n[2] > ncol(dmat)) return(FALSE)\n      if (dmat[n[1], n[2]] != '#') {\n        cells[n[1], n[2]] <- cells[n[1], n[2]] + 1\n        guy <- n\n      } else dir <- rotate[dir]\n      step <- step + 1\n      if (any(cells > 5)) return(TRUE)\n    }\n  }) |>\n  sum()\n}, handlers = progressr::handler_cli())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1443\n```\n\n\n:::\n\n```{.r .cell-code}\nfuture::plan(future::sequential())\ntictoc::toc()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n159.856 sec elapsed\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}