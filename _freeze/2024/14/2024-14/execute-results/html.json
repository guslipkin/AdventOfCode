{
  "hash": "204d0a6a4c61203ef2d4f8c73a28bb15",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"14: Restroom Redoubt\"\nformat: html\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(mistlecode)\n\noptions(scipen = 999)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmdt <-\n  'input.txt' |>\n  readLines() |>\n  stringr::str_match_all('-?\\\\d+') |>\n  purrr::map(\\(x) {\n    x <- as.integer(x)\n    list(\n      'p' = c(x[1], x[2]) + 1, # row,col\n      'v' = c(x[3], x[4])\n    )\n  })\n```\n:::\n\n\n\n\n\n## Part 1\n\nWhen I was almost done I realized I could've just multiplied the vectors by 100 then not needed a loop. Oh well. Easy enough.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- matrix(list(), nrow = 103, ncol = 101)\ndt <- mdt\nfor(i in 1:100) {\n  dt <- purrr::map(dt, \\(x) {\n      p <- x$p + x$v\n      p[1] <- p[1] %% ncol(m); if (p[1] == 0) p[1] <- ncol(m);\n      p[2] <- p[2] %% nrow(m); if (p[2] == 0) p[2] <- nrow(m);\n      list('p' = p, 'v' = x$v)\n    })\n}\n\np <-\n  dt |>\n  purrr::map(\\(x) x$p |> matrix(ncol = 2) |> as.data.frame()) |>\n  purrr::list_rbind() |>\n  setNames(c('col', 'row')) |>\n  dplyr::select('row', 'col')\n\nmid_row <- ceiling(nrow(m) / 2); mid_col <- ceiling(ncol(m) / 2);\none <- p[p$row < mid_row & p$col < mid_col,] |> nrow()\ntwo <- p[p$row < mid_row & p$col > mid_col,] |> nrow()\nthree <- p[p$row > mid_row & p$col < mid_col,] |> nrow()\nfour <- p[p$row > mid_row & p$col > mid_col,] |> nrow()\nprod(one, two, three, four)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 228421332\n```\n\n\n:::\n:::\n\n\n\n\n\n## Part 2\n\nUgh. `mistlecode::coords_to_matrix()` isn't working. I guess I'll use `{ggplot}`. Figuring out how to identify the tree was annoying. I tried clicking through the first 500 iterations with `{ggplot}` but that wasn't going anywhere. I took a bit but I figured that the tree would probably have either high or low density in terms of points vs white space. Took a gander and just ran a loop until the initial state was repeated then checked the max and min densities. Sure enough. Max density it was.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- matrix(list(), nrow = 103, ncol = 101)\nfilled <- c(Inf, 0); which_filled <- c(0, 0)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndt1 <- purrr::map(mdt, \\(x) {\n      p <- x$p + x$v\n      p[1] <- p[1] %% ncol(m); if (p[1] == 0) p[1] <- ncol(m);\n      p[2] <- p[2] %% nrow(m); if (p[2] == 0) p[2] <- nrow(m);\n      list('p' = p, 'v' = x$v)\n    })\ni <- 2\nrepeat {\n  dt <- purrr::map(mdt, \\(x) {\n      p <- x$p + (x$v * i)\n      p[1] <- p[1] %% ncol(m); if (p[1] == 0) p[1] <- ncol(m);\n      p[2] <- p[2] %% nrow(m); if (p[2] == 0) p[2] <- nrow(m);\n      list('p' = p, 'v' = x$v)\n    })\n  if (identical(dt, dt1)) break\n  dt <-\n    dt |>\n    purrr::map(\\(x) x$p |> matrix(ncol = 2) |> as.data.frame()) |>\n    purrr::list_rbind() |>\n    setNames(c('col', 'row'))\n  f <- nrow(unique(dt)) / prod(dim(m))\n  if (f < filled[1]) {\n    filled[1] <- f \n    which_filled[1] <- i\n  } else if (f > filled[2]) {\n    filled[2] <- f\n    which_filled[2] <- i\n  }\n  i <- i + 1\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::map(1:2, \\(i) {\n  dt <- purrr::map(mdt, \\(x) {\n      p <- x$p + (x$v * which_filled[i])\n      p[1] <- p[1] %% ncol(m); if (p[1] == 0) p[1] <- ncol(m);\n      p[2] <- p[2] %% nrow(m); if (p[2] == 0) p[2] <- nrow(m);\n      list('p' = p, 'v' = x$v)\n    })\n  dt |>\n    purrr::map(\\(x) x$p |> matrix(ncol = 2) |> as.data.frame()) |>\n    purrr::list_rbind() |>\n    setNames(c('col', 'row')) |>\n    ggplot2::ggplot() +\n    ggplot2::geom_point(ggplot2::aes(x = col, y = -row)) +\n    ggplot2::theme_void()\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](2024-14_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n[[2]]\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](2024-14_files/figure-html/unnamed-chunk-6-2.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwhich_filled[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7790\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}