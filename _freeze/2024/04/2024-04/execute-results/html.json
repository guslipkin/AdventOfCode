{
  "hash": "cbb913592c17c31ef82bbd7cf5fd5ac6",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"04: Ceres Search\"\nformat: html\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(mistlecode)\n\noptions(scipen = 999)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndt <-\n  readLines(\"input.txt\") |>\n  strsplit('')\n\ndt <-\n  dt |>\n  unlist() |>\n  matrix(ncol = length(dt[[1]]), byrow = TRUE)\n```\n:::\n\n\n\n\n\n## Part 1\n\nI'm disappointed in myself. I really should have a function to parse input like this by now, but again I sat on my butt and didn't make one then struggled for it. I also got super duper stuck when my `mistlecode::get_diagonal()` wasn't able to pick up diagonals that start in the lower right corner. It's something I'll have to go fix. I'll probably re-do the whole thing to just say 'top-left' or 'bottom-right' or something to actually say what corner it's coming off of rather than trying to say how it's divided. Anyways, I knew I had overlapping diagonals and needed to drop them, but I was dropping them inside `count_diag()` which wasn't doing anything except dropping a letter off the diagonals. Once I moved that outside, I was able to recognize my missing corner.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount <- function(x) {\n  x |>\n    paste0(collapse = '') |>\n    strg_extract_all('XMAS|SAMX') |>\n    unlist() |>\n    length()\n}\n\ncount_diag <- function(x, dim, dir) {\n  x |>\n    purrr::map_int(\\(x) {\n      mistlecode::get_diagonal(dt, x, dim, dir) |>\n        count()\n    }) |>\n    sum()\n}\n\nrows <- dt |> apply(1, count) |> sum()\ncols <- dt |> apply(2, count) |> sum()\n\ndrow <- dt |> nrow() |> seq_len() |> count_diag('row', 'down')\ndcol <- dt |> ncol() |> seq_len() |> tail(-1) |> count_diag('col', 'down')\n\nurow <-\n  dt |> rev() |> `dim<-`(rev(dim(dt))) |>\n  nrow() |> seq_len() |> count_diag('row', 'up')\nucol <-\n  dt |>  rev() |> `dim<-`(rev(dim(dt))) |>\n  ncol() |> seq_len() |> tail(-1) |> count_diag('col', 'up')\n\nrows + cols + drow + dcol + urow + ucol\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2524\n```\n\n\n:::\n:::\n\n\n\n\n\n## Part 2\n\nThankfully this was much easier. It was a small struggle adapting my `count()` which I really didn't need to do if I hadn't been so eager to `paste0()` in my `for` loop. But if it works, it works, and it was much much faster than part 1.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt[dt == 'X'] <- ''\n\ncount <- function(x) {\n  x |>\n    stringr::str_count('MAS|SAM') |>\n    sum()\n}\n\ntally <- logical()\nfor (r in seq_len(nrow(dt) - 2)) {\n  for (c in seq_len(ncol(dt) - 2)) {\n    x <- dt[r:(r+2), c:(c+2)]\n    if (x[2, 2] != 'A') next\n    left_right <- paste0(c(x[1,1], x[2,2], x[3,3]), collapse = '')\n    right_left <- paste0(c(x[1,3], x[2,2], x[3,1]), collapse = '')\n    valid <- count(c(left_right, right_left)) == 2\n    if (valid) tally <- c(tally, valid)\n  }\n}\ntally |>\n  sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1873\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}