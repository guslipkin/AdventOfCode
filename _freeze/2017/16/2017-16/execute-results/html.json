{
  "hash": "5e82391e389d8a144de6cb62afe93b27",
  "result": {
    "markdown": "---\ntitle: \"16: Permutation Promenade\"\n---\n\n::: {.cell hash='2017-16_cache/html/unnamed-chunk-1_008351f8bc5a33ed91688fa16449190c'}\n\n```{.r .cell-code}\nlibrary(mistlecode)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTo install `mistlecode` yourself, run `devtools::install_github('guslipkin/mistlecode')`.\n\n Also loading:  cipheR data.table dplyr purrr slider stringr tidyverse glue rlang R6\n```\n:::\n\n```{.r .cell-code}\nx <-\n  readLines(\"input.txt\") |>\n  str_split_1(\",\") |>\n  add_processor()\n```\n:::\n\n\n## Part 1\n\nI hate zero indexed stuff... But it's fun to keep using `create_assembly`\n\n\n::: {.cell hash='2017-16_cache/html/unnamed-chunk-2_43c3ea1861f32793a5c77fe8b90e799d'}\n\n```{.r .cell-code}\nregisters <-\n  1:16 |>\n  as.list() |>\n  `names<-`(letters[1:16])\n\nfunctions <- list(\n  \"proc\" = \\(x, y) {\n    y <- stringr::str_split_fixed(x, \"/\", 2)\n    yy <- stringr::str_split_fixed(y[,1], \"\", 2)\n    x <- c(yy, y[,-1])\n    \n    x[1] <- case_match(\n      x[1],\n      \"s\" ~ \"spin\",\n      \"x\" ~ \"exchange\",\n      \"p\" ~ \"partner\"\n    )\n    self[[x[1]]](x[2], x[3])\n    \n    private$.inc()\n  },\n  \"spin\" = \\(x, y) {\n    x <- as.integer(x)\n    for (r in letters[1:16]) {\n      self[[r]] <- (self[[r]] + as.integer(x)) %% length(registers)\n      if (self[[r]] == 0) self[[r]] <- length(registers)\n    }\n  },\n  \"exchange\" = \\(x, y) {\n    x <- as.integer(x) + 1\n    y <- as.integer(y) + 1\n    pos <- sapply(letters[1:16], \\(r) self[[r]])\n    x <- names(which(pos == x))\n    y <- names(which(pos == y))\n    self$partner(x, y)\n  },\n  \"partner\" = \\(x, y) {\n    tmp <- self[[y]]\n    self[[y]] <- self[[x]]\n    self[[x]] <- tmp\n  }\n)\n\na <- create_assembly(registers, functions)$run(x)\nas.list(a)[letters[1:16]] |>\n  unlist() |>\n  sort() |>\n  names() |>\n  paste0(collapse = \"\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"ceijbfoamgkdnlph\"\n```\n:::\n:::\n\n\n## Part 2\n\nIt's going to loop at some point and I need to track that. Ugh. Just track the new ones until it repeats, then modulo. Slow, but it works.\n\n\n::: {.cell hash='2017-16_cache/html/unnamed-chunk-3_c98041db2ab97e2d9784ef045e24afd1'}\n\n```{.r .cell-code}\nseen <- c()\n\ni <- 0\nrepeat {\n  a <- create_assembly(registers, functions)$run(x)\n  registers <- as.list(a)[letters[1:16]]\n  new_a <-\n    registers |>\n    unlist() |>\n    sort() |>\n    names() |>\n    paste0(collapse = \"\")\n  if (new_a %in% seen) break else seen <- c(seen, new_a)\n  i <- i + 1\n}\n\nseen[1e9 %% i]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"pnhajoekigcbflmd\"\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}