{
  "hash": "ca70146edfc73778584f220c5822b8df",
  "result": {
    "markdown": "---\ntitle: \"2022-11: Monkey in the Middle\"\nformat: html\n---\n\n::: {.cell hash='2022-11_cache/html/unnamed-chunk-1_843487bebce8a189d2ed974579e5131d'}\n\n```{.r .cell-code}\nlibrary(mistlecode)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTo install `mistlecode` yourself, run `devtools::install_github('guslipkin/mistlecode')`.\n\n Also loading:  cipheR data.table dplyr purrr slider stringr tidyverse\n```\n:::\n:::\n\n::: {.cell hash='2022-11_cache/html/unnamed-chunk-2_566e5b9dfc2e35e378dbff985214c12a'}\n\n```{.r .cell-code}\ndt <- readLines(\"input.txt\")\n\ndt <- \n  data.frame(dt) |>\n  mutate(monkey = cumsum(grepl(\"Monkey \\\\d+:\", dt)) - 1) |>\n  filter(dt != \"\")\n```\n:::\n\n\nOh no. I'm going to bed.\n\n## Part 1\n\nThis was so much fun! I dipped my toes into S3 classes, made a useful function\nfactory, and did some recursion. I had a bit of trouble making sure my list of\nmonkeys was getting passed around properly and returned because loops can't\nchange objects in the global environment. That said, I have a bad feeling about\npart 2.\n\n\n::: {.cell hash='2022-11_cache/html/unnamed-chunk-3_b12fc5c2a9fdb97797683ae612261526'}\n\n```{.r .cell-code}\noperation <- function(op, val) {\n  function(old) {\n    if (val == \"old\") { val <- as.integer(old) } \n    else { val <- as.integer(val) }\n    \n    if (op == \"*\") { val <- old * val }\n    else if (op == \"+\") { val <- old + val }\n    \n    return(val)\n  }\n}\n\nnew_monkey <- function(dt, x) {\n  name <- str_extract(dt[1,\"dt\"], \"\\\\d+\")\n  items <- \n    str_split(dt[2,\"dt\"], \":|,\", simplify = TRUE)[1,-1] |> as.numeric()\n  opp <- \n    str_split(dt[3, \"dt\"], \"=\", simplify = TRUE)[1,2] |>\n    str_match(\" (new|old) (\\\\+|\\\\-|\\\\*|\\\\/) (old|\\\\d+)\")\n  op_op <- opp[1,3]\n  op_num <- ifelse(opp[1,4])\n  op <- operation(op = opp[1,3], val = opp[1,4])\n  test <- str_extract(dt[4,\"dt\"], \"\\\\d+\") |> as.integer()\n  case_true <- str_extract(dt[5,\"dt\"], \"\\\\d+\")\n  case_false <- str_extract(dt[6,\"dt\"], \"\\\\d+\")\n  x <- list(\n    \"name\" = name,\n    \"items\" = items,\n    \"operation\" = op,\n    \"test\" = test,\n    \"case_true\" = case_true,\n    \"case_false\" = case_false,\n    \"inspections\" = 0\n  )\n  structure(x, class = \"monkey\")\n}\n\nmonkeys <- \n  lapply(unique(dt$monkey), \\(m) { \n    new_monkey(dt[dt$monkey == m,], m) \n  })\nnames(monkeys) <- sapply(monkeys, \\(m) m$name)\n\nprocess_items <- function(item, monkey, these_monkeys) {\n  if (is.na(monkey$items[item]) | \n      item > length(monkey$items)) { return(these_monkeys) }\n  worry_level <- monkey$operation(monkey$items[item])\n  worry_level <- floor(worry_level / 3)\n  if (worry_level %% monkey$test == 0) {\n    case_true <- \n      c(these_monkeys[[monkey$case_true]]$items, worry_level)\n    these_monkeys[[monkey$case_true]]$items <- \n      case_true[!is.na(case_true)]\n  } else {\n    case_false <- \n      c(these_monkeys[[monkey$case_false]]$items, worry_level)\n    these_monkeys[[monkey$case_false]]$items <- \n      case_false[!is.na(case_false)]\n  }\n  process_items(item + 1, monkey, these_monkeys)\n}\n\nprocess_monkey <- function(i, these_monkeys) {\n  if (i == length(monkeys) + 1) { return(these_monkeys) }\n  monkey <- these_monkeys[[i]]\n  these_monkeys <- process_items(1, monkey, these_monkeys)\n  monkey$inspections <- \n    sum(monkey$inspections, length(monkey$items), na.rm = TRUE)\n  monkey$items <- as.numeric(NA)\n  these_monkeys[[i]] <- monkey\n  process_monkey(i + 1, these_monkeys)\n}\n\nround <- function(these_monkeys, round) {\n  if (round == round_max + 1) { return(these_monkeys) }\n  these_monkeys <- process_monkey(1, these_monkeys)\n  round(these_monkeys, round + 1)\n}\n```\n:::\n\n::: {.cell hash='2022-11_cache/html/unnamed-chunk-4_97109b8e4e95a2832a684b26c4fbb611'}\n\n```{.r .cell-code}\nround_max <- 20\nm <- round(monkeys, 1)\nsapply(m, \\(m) m$inspections) |>\n  sort(decreasing = TRUE) |>\n  head(2) |>\n  prod()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 316888\n```\n:::\n:::\n\n\n## Part 2\n\nI want to scream. I submitted my answer just to see and it's right, even though\nthe test input was wrong. I could've submitted yesterday ðŸ˜­ So many hours\ndevoted to these monkeys for nothing...\n\nI figured out the `worry_level %% prod(tests)` thing pretty quick after part 1,\nbut it took a full day because the test input never lined up, even if I got\nsuper close. I still want to figure out why that is, but for now I'm just happy\nto have the star.\n\n\n::: {.cell hash='2022-11_cache/html/unnamed-chunk-5_a68c9328f6659460447da05185904e12'}\n\n```{.r .cell-code}\nprocess_items <- function(item, monkey, these_monkeys) {\n  if (is.na(monkey$items[item]) | \n      item > length(monkey$items)) { return(these_monkeys) }\n  worry_level <- monkey$operation(monkey$items[item])\n  case <- (worry_level %% monkey$test) == 0\n  worry_level <- worry_level %% prod(tests)\n  if (case) {\n    case_true <- \n      c(these_monkeys[[monkey$case_true]]$items, worry_level)\n    these_monkeys[[monkey$case_true]]$items <- \n      case_true[!is.na(case_true)]\n  } else {\n    case_false <- \n      c(these_monkeys[[monkey$case_false]]$items, worry_level)\n    these_monkeys[[monkey$case_false]]$items <- \n      case_false[!is.na(case_false)]\n  }\n  process_items(item + 1, monkey, these_monkeys)\n}\n\nm <- monkeys\ntests <- sapply(m, \\(m) m$test)\n\nround_max <- 1\ni <- 1\nwhile (i <= 10000) {\n  m <- process_monkey(1, m)\n  i <- i + 1\n}\n\nsapply(m, \\(m) m$inspections) |>\n  sort(decreasing = TRUE) |>\n  head(2) |>\n  prod()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 35270398814\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}