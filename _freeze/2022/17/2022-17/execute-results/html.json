{
  "hash": "f17483a7df1cb8b9394a72cc0fbc35d3",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Pyroclastic Flow\"\nformat: html\ndate: \"2022-12-17\"\ndraft: true\neval: false\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(mistlecode)\n\noptions(scipen = 999)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndt <- \n  readLines(\"input.txt\") |>\n  str_split(\"\") |>\n  unlist()\n\nrocks <-\n  list(\n    matrix(\"@\", 1, 4),\n    matrix(c(\" \", \"@\", \" \", \"@\", \"@\", \"@\", \" \", \"@\", \" \"), 3, 3),\n    matrix(c(\" \", \" \", \"@\", \" \", \" \", \"@\", \"@\", \"@\", \"@\"), 3, 3),\n    matrix(\"@\", 4, 1),\n    matrix(\"@\", 2, 2)\n  )\nrock_seq <- rep(1:5, length(dt) / 5)\n\nrock_seq <- rep_len(rock_seq, 10000)\n# dt <- rep_len(dt, 2022)\n```\n:::\n\n\n\n\n## Part 1\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncave <- matrix(\" \", 3, 7)\n\ncave_to_matrix <- function(cave) {\n  cave |>\n    matrix_to_coords() |>\n    dplyr::filter(.data$data == '@') |>\n    dplyr::select(-'data') |>\n    as.matrix()\n}\n\nadd_row <- function(cave, rock) {\n  rbind(\n    cbind(\n      matrix(\" \", nrow(rock), 2), \n      rock, \n      matrix(\" \", nrow(rock), 5 - ncol(rock))),\n    cave)\n}\n\ncan_fall <- function(cave) {\n  coords <- cave_to_matrix(cave)\n  if (any(coords[,\"row\"] == nrow(cave))) { return(FALSE) }\n  apply(coords, 1, \\(x) {\n    (cave[x[\"row\"] + 1, x[\"col\"]] %in% c(\"@\", \" \"))\n  }) |>\n    all()\n}\n\nmove_rock <- function(cave, dir) {\n  x <- cave_to_matrix(cave)\n\n  for (j in 1:nrow(x)) { cave[x[j, \"row\"], x[j, \"col\"]] <- \" \" }\n  \n  if (dir == \"d\") {\n    x[, \"row\"] <- x[, \"row\"] + 1\n  } else if (dir == \"<\" &\n             !any(x[, \"col\"] - 1 < 1) &&\n             !any(sapply(1:nrow(x), \\(i) {\n               cave[x[i, \"row\"], x[i, \"col\"] - 1]\n             }) == \"█\")) {\n    x[, \"col\"] <- x[, \"col\"] - 1\n  } else if (dir == \">\" &\n             !any(x[, \"col\"] + 1 > 7) &&\n             !any(sapply(1:nrow(x), \\(i) {\n               cave[x[i, \"row\"], x[i, \"col\"] + 1]\n             }) == \"█\")) {\n    x[, \"col\"] <- x[, \"col\"] + 1\n  }\n  \n  for (j in 1:nrow(x)) { cave[x[j,\"row\"], x[j,\"col\"]] <- \"@\" }\n  \n  return(cave)\n}\n\ntrim_row <- function(cave) {\n  minRow <-\n    apply(cave, 2, \\(x) { which(x != \" \") }) |>\n    unlist() |>\n    min()\n  \n  cave[(minRow-3):nrow(cave), 1:7]\n}\n\ndirCount <- 1\nrowCounter <- 0\nfor (i in seq_along(rock_seq)) {\n  rock <- rocks[[rock_seq[i]]]\n  \n  cave <- add_row(cave, rock)\n  \n  cave <- move_rock(cave, dt[dirCount])\n  dirCount <- dirCount + 1\n\n  while(can_fall(cave)) {\n    dirCount <- dirCount %% length(dt)\n    dirCount <- ifelse(dirCount == 0, length(dt), dirCount)\n    cave <- move_rock(cave, \"d\")\n    cave <- move_rock(cave, dt[dirCount])\n    dirCount <- dirCount + 1\n  }\n  \n  cave <- trim_row(cave)\n  x <- cave_to_matrix(cave)\n  \n  for (j in 1:nrow(x)) { cave[x[j, \"row\"], x[j, \"col\"]] <- \"█\" }\n}\nnrow(cave) - 3\n```\n:::\n\n\n\n\n## Part 2\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# rock_seq <- rep_along(rep(dt, 5), 1:5)\n\ncave <- matrix(\" \", 3, 7)\n\ndirCount <- 1\nrowCounter <- 0\nfor (i in seq_along(rock_seq)) {\n  rock <- rocks[[rock_seq[i]]]\n  \n  cave <- add_row(cave, rock)\n  \n  cave <- move_rock(cave, dt[dirCount])\n  dirCount <- dirCount + 1\n\n  while(can_fall(cave)) {\n    dirCount <- dirCount %% length(dt)\n    dirCount <- ifelse(dirCount == 0, length(dt), dirCount)\n    cave <- move_rock(cave, \"d\")\n    cave <- move_rock(cave, dt[dirCount])\n    dirCount <- dirCount + 1\n    cave\n  }\n  \n  cave <- trim_row(cave)\n  x <-\n    matrix_to_coords(cave) %>%\n    .[.[, \"data\"] == \"@\", c(\"row\", \"col\")]\n  x <- \n    matrix(as.numeric(x), nrow(x)) |>\n    `colnames<-`(c(\"row\", \"col\"))\n  \n  for (j in 1:nrow(x)) { cave[x[j, \"row\"], x[j, \"col\"]] <- \"█\" }\n  \n  dropRows <- \n    apply(cave, 1, \\(x) { all(x == \"█\") }) |>\n    which()\n  if (length(dropRows) > 0) { dropRows <- min(dropRows) - 1 }\n  if (length(dropRows) == 1 && dropRows != Inf) {\n    rowCounter <- rowCounter + (nrow(cave) - dropRows)\n    cave <- cave[1:dropRows,]\n  }\n}\nnrow(cave) + rowCounter - 3\n\napply(cave, 1, \\(x) { all(x == \"█\") }) |>\n    which() -> x\n\nx - lag(x)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncave2 <- cave[4:nrow(cave),]\nsapply(1:nrow(cave2), \\(x) {\n  if (nrow(cave2) %% x != 0) { return(FALSE) }\n  all(cave2[x,] == \"█\")\n}) |>\n  unlist() |>\n  which()\n\napply(cave2, 1, \\(x) { all(x == \"█\") }) |>\n  any()\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}