{
  "hash": "b7968459a47eb0ceed3f6bf2f96fa152",
  "result": {
    "markdown": "---\ntitle: \"2022-21: Monkey Math\"\nformat: html\n---\n\n\nThis...doesn't actually look too bad. Part 2 will probably be a nightmare.\n\n\n::: {.cell hash='2022-21_cache/html/unnamed-chunk-1_49452f8ec7be60a6a1debda912ab8452'}\n\n```{.r .cell-code}\nlibrary(mistlecode)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTo install `mistlecode` yourself, run `devtools::install_github('guslipkin/mistlecode')`.\n\n Also loading:  cipheR data.table dplyr purrr slider stringr tidyverse\n```\n:::\n\n```{.r .cell-code}\n#remotes::install_github(\"rconsortium/OOP-WG\")\nlibrary(R7)\noptions(scipen = 999)\n```\n:::\n\n::: {.cell hash='2022-21_cache/html/unnamed-chunk-2_82859133bf65d03a64764f4093a12c4c'}\n\n```{.r .cell-code}\ndt <- \n  readLines(\"input.txt\") |>\n  str_split(\": \")\n```\n:::\n\n\n## Part 1\n\nLet's take a chance to use [R7](https://rconsortium.github.io/OOP-WG/) for the\nfirst time! I can build on the bits I learned with S3 in\n[2022-11](/2022/11/2022-11.html). The idea to use a vector of monkey names\n(`index`) made it really easy to make sure I was pulling info from the right\nmonkeys, rather than needing to iterate over the entire list. There's probably a\nbetter approach overall with a more recursive solution, but this seems to work\nfine for Part 1, although I'm worried about Part 2.\n\n\n::: {.cell hash='2022-21_cache/html/unnamed-chunk-3_0a82bbeb16fb6c60a3678b30f69c5fa1'}\n\n```{.r .cell-code}\nmonkey <- new_class(\n  name = \"monkey\",\n  properties = list(\n    name = class_character,\n    val = class_any,\n    op = class_character\n  )\n)\n\nnew_monkey <- function(x) {\n  if (!is.na(suppressWarnings(as.numeric(x[2])))) {\n    val <- as.numeric(x[2])\n    op <- NA_character_\n  } else {\n    val <- NA\n    op <- x[2]\n  }\n  monkey(\n    name = x[1],\n    val = val,\n    op = op\n  )\n}\n\nmonkeys <- lapply(dt, new_monkey)\nmasterMonkeys <- monkeys\nindex <- sapply(monkeys, \\(x) x@name)\n\nmonkey_math <- function(monkeys, op) {\n  m1 <- monkeys[[which(index == op[1])]]@val\n  m2 <- monkeys[[which(index == op[3])]]@val\n  \n  if (!is.na(m1) & !is.na(m2)) {\n    if (op[2] == \"+\") { m1 + m2 }\n    else if (op[2] == \"-\") { m1 - m2 }\n    else if (op[2] == \"*\") { m1 * m2 }\n    else if (op[2] == \"/\") { m1 / m2 }\n  } else { return(NA_integer_) }\n}\n\nprocess_monkeys <- function(monkeys, n = 1) {\n  if (n > length(monkeys)) { return(monkeys) }\n  if (is.na(monkeys[[n]]@val)) {\n    val <- str_split_1(monkeys[[n]]@op, \" \")\n    monkeys[[n]]@val <- monkey_math(monkeys, val)\n  }\n  if (monkeys[[n]]@name == \"root\" & !is.na(monkeys[[n]]@val)) { \n    return(monkeys[[n]]@val) \n  }\n  process_monkeys(monkeys, n + 1)\n}\n\nm <- monkeys\nwhile(is.list(m)) { m <- process_monkeys(m) }\nm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 93813115694560\n```\n:::\n:::\n\n\n## Part 2\n\nI tried brute-forcing it... It took a while to fully figure out what I wanted to\ndo, but the idea behind just making a giant equation then solving for `humn` was\nthere early on. I started by expanding the input by replacing monkeys with their\nvalue if they had one or operation if they didn't. I then replaced all the\nmonkeys with their values, just like in Part 1. This left me with a giant\nexpression where the only variable was `humn`. I just wasn't sure how to\nactually solve equations in R so I kept trying to brute-force it, which kept on\nnot working. I eventually found the `Ryacas` package which made quick work of\neverything.\n\n\n::: {.cell hash='2022-21_cache/html/unnamed-chunk-4_0058b452026165589acb84319b7b4a14'}\n\n```{.r .cell-code}\nmonkeys <- lapply(dt, new_monkey)\n\nroot_op <- \n  str_extract(monkeys[[which(index == \"root\")]]@op, \"(\\\\+|\\\\-|\\\\*|\\\\/)\")\nmonkeys[[which(index == \"root\")]]@op <- \n  gsub(paste0(\"\\\\\", root_op), \"=\", monkeys[[which(index == \"root\")]]@op)\n\nm1 <- str_split_1(monkeys[[which(index == \"root\")]]@op, \" = \")\nm2 <- m1[2]\nm1 <- m1[1]\n\nreplace_monkey <- function(m) {\n  w <- which(index == m)\n  if (length(w) == 0) { return(m) }\n  v <- monkeys[[w]]@val\n  if (is.na(v)) { return(paste0(\"( \", monkeys[[which(index == m)]]@op, \" )\")) }\n  return(paste0(\"( \", v, \" )\"))\n}\n\n# https://stackoverflow.com/a/14838753\nquotemeta <- function(string) { str_replace_all(string, \"(\\\\W)\", \"\\\\\\\\\\\\1\") }\n\nprocess_string <- function(m) {\n  while (any(grepl(\"([^(h)][a-z])\", m))) {\n    m <- \n      sapply(m, \\(mm) { replace_monkey(mm) }) |>\n      paste0(collapse = \" \") |>\n      str_split_1(\" \")\n  }\n  m <- paste0(m, collapse = \"\")\n  oldM <- 0\n  while (length(m) == 1 && oldM != m) {\n    oldM <- m\n    r <-\n      m |>\n      str_extract_all(\"\\\\((\\\\d+|h)\\\\)[\\\\+|\\\\-|\\\\*|\\\\/]\\\\((\\\\d+|h)\\\\)\") |>\n      unlist() |>\n      sapply(\\(r) {\n        if (grepl(\"h\", r)) { return(r) }\n        else { eval(parse(text = r)) }\n      })\n    \n    for (i in 1:length(r)) {\n      m <-\n        str_replace_all(m, quotemeta(names(r)[i]), as.character(r[i]))\n    }\n  }\n  return(oldM)\n}\n\nmonkeys[[which(index == \"humn\")]]@val <- \"h\"\nmm1 <- process_string(m1)\nmm2 <- process_string(m2)\n\nreduce_string <- function(mm) {\n  r <-\n    str_extract_all(mm, \"\\\\((\\\\d+|h)\\\\)\") |>\n    unlist() |>\n    sapply(\\(r) {\n      if (grepl(\"h\", r)) { return(r) }\n      else { eval(parse(text = r)) }\n    })\n  \n  for (i in 1:length(r)) {\n    mm <- str_replace_all(mm, quotemeta(names(r)[i]), as.character(r[i]))\n  }\n  return(mm)\n}\n\npaste(reduce_string(mm1), \"==\", reduce_string(mm2)) %>%\n  Ryacas::y_fn(\"Solve\", \"h\") |>\n  Ryacas::yac_str() |>\n  str_extract(\"\\\\d+\") |>\n  as.numeric()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3910938071092\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}