{
  "hash": "132a492f073747eb74ecc1efa8971e4e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Grove Positioning System\"\nformat: html\ndate: \"2022-12-20\"\n---\n\n\n\n\nThis looks too good to be true!\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(mistlecode)\noptions(scipen = 999)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndt <- \n  readLines(\"input.txt\") |>\n  as.numeric()\n```\n:::\n\n\n\n\n## Part 1\n\nPretty straightforward, all things considered. Getting vectors to wrap is always\na pain. I also missed the bit about the numbers being after zero, but a quick\n`which` took care of that.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npos <- 1:length(dt)\n\nshift <- function(pos, x, shift) {\n  if (x == 0) { return(pos) }\n  p <- which(pos == x)\n  pos <- pos[-p]\n  after <- (p - 1 + shift) %% length(pos)\n  after <- ifelse(after == 0, length(pos), after)\n  append(pos, x, after = after)\n}\n\nfor(i in 1:length(dt)) { pos <- shift(pos, i, dt[i]) }\n\nget_sum <- function(dt, pos) {\n  zero <- which(dt[pos] == 0)\n  sapply(c(1e3, 2e3, 3e3), \\(x) {\n    x <- (x + zero) %% length(pos)\n    x <- ifelse(x == 0, length(pos), x)\n    dt[pos[x]]\n  }) |>\n    sum()\n}\n\nget_sum(dt, pos)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4151\n```\n\n\n:::\n:::\n\n\n\n\n## Part 2\n\nBasically the same as Part 1. I was blessed with no integer overflows so that's\nnice. Just multiply the vector by a constant, nest the for loop, then get the\nsum using the function from Part 1.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkey <- 811589153\ndt2 <- dt * key\npos2 <- 1:length(dt)\n\nfor(j in 1:10) {\n  for (i in 1:length(dt2)) { pos2 <- shift(pos2, i, dt2[i]) }\n}\n\nget_sum(dt2, pos2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7848878698663\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}