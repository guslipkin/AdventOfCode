{
  "hash": "d544bc361366ef19b4e1fc8d25e4b4ed",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"2022-08: Treetop Tree House\"\nformat: html\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(mistlecode)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndt <- fread(\"input.txt\", header = FALSE)\n```\n:::\n\n\n\n\nOh no. I always do hate grid based ones.\n\n## Part 1\n\nThis was a weird one. I'm writing this the day after I wrote the code, and I have no clue what my thought process was. I did it reasonably quickly so I'm not too unhappy with it.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmm <- \n  dt |>\n  as.matrix() |>\n  as.character() |>\n  str_split(\"\", simplify = TRUE) |>\n  apply(c(1, 2), as.numeric)\n\ngrid <- expand.grid(\"col\" = 1:ncol(mm), \"row\" = 1:nrow(mm))\n\nm <-\n  mapply(\\(x, y) {\n    tree <- mm[y, x]\n    \n    if (x == 1 | x == ncol(mm) | y == 1 | y == nrow(mm)) { return(c(x, y)) }\n    \n    if (all(mm[(y + 1):nrow(mm), x] < tree, na.rm = TRUE) |\n        all(mm[1:(y - 1), x] < tree, na.rm = TRUE) |\n        all(mm[y, 1:(x - 1)] < tree, na.rm = TRUE) |\n        all(mm[y, (x + 1):ncol(mm)] < tree, na.rm = TRUE)) {\n      return(c(x, y))\n    }\n  }, grid$col, grid$row)\n\nm[!sapply(m, is.null)] %>%\n  do.call(rbind, .) |>\n  data.frame() |>\n  `colnames<-`(c(\"col\", \"row\")) -> mi\nnrow(mi)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1717\n```\n\n\n:::\n:::\n\n\n\n\n## Part 2\n\nThis was a mess. I kept trying to be smart about it and wasted so much time. I mostly had trouble working with patterns like `[5050]` where the first five can see both the zero and the second five, but not the second zero. This meant that `x < 5` ignored the five, and `x <= 5` would keep going and read over the remaining zero. Even though I ended up hard-coding everything, I'm rather pleased with how neat it is. I'm sure I could move more of it to functions, but it wouldn't be too much prettier, if any.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscenic <- matrix(NA, nrow(mm), ncol(mm))\n\nchecker <- function(vec, i, tree, dir) {\n  vec <- detect_index(vec, \\(.x) { .x >= tree }) \n  if (dir == -1) { vec <- ifelse(vec == 0, i - 1, vec) }\n  else { vec <- ifelse(vec == 0, ncol(mm) - i, vec) }\n  vec\n}\n\nmapply(\\(y, x) {\n  tree <- mm[y, x]\n  up <- NA; down <- NA; left <- NA; right <- NA\n  if (y == 1) { up <- 0 }; if (y == nrow(mm)) { down <- 0 }\n  if (x == 1) { left <- 0}; if (x == ncol(mm)) { right <- 0 }\n  \n  rowMin <- ifelse(y - 1 < 1, 1, y - 1); rowMax <- ifelse(y + 1 > nrow(mm), nrow(mm), y + 1)\n  colMin <- ifelse(x - 1 < 1, 1, x - 1); colMax <- ifelse(x + 1 > ncol(mm), ncol(mm), x + 1)\n  \n  yMin <- ifelse(y - 1 < 1, 1, y - 1); yMax <- ifelse(y + 1 > nrow(mm), nrow(mm), y + 1)\n  xMin <- ifelse(x - 1 < 1, 1, x - 1); xMax <- ifelse(x + 1 > ncol(mm), ncol(mm), x + 1)\n  \n  if (is.na(up)) { up <- checker(rev(mm[1:yMin, x]), y, tree, -1) }\n  if (is.na(left)) { left <- checker(rev(mm[y, 1:xMin]), x, tree, -1) }\n  if (is.na(right)) { right <- checker(mm[y, xMax:ncol(mm)], x, tree, 1) }\n  if (is.na(down)) { down <- checker(mm[rowMax:nrow(mm), x], y, tree, 1) }\n  \n  scene <- c(up, left, right, down)\n  scenic[y, x] <<- prod(scene[scene != 0])\n}, grid$row, grid$col) |> invisible()\nmax(scenic)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 321975\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}