{
  "hash": "53cd56bd71a5b3d778a64408426af29f",
  "result": {
    "markdown": "---\ntitle: \"2022-03: Rucksack Reorganization\"\nformat: html\n---\n\n::: {.cell hash='2022-03_cache/html/unnamed-chunk-1_017e4a317dc04bfa62d483bfe5ca747e'}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.4.0      ✔ purrr   0.3.5 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.2.1      ✔ stringr 1.4.1 \n✔ readr   2.1.3      ✔ forcats 0.5.2 \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n```\n:::\n\n```{.r .cell-code}\nlibrary(data.table)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'data.table'\n\nThe following objects are masked from 'package:dplyr':\n\n    between, first, last\n\nThe following object is masked from 'package:purrr':\n\n    transpose\n```\n:::\n:::\n\n::: {.cell hash='2022-03_cache/html/unnamed-chunk-2_6db713709de1d02021b4c6a18c5dc456'}\n\n```{.r .cell-code}\n# dt <- fread(\"input.txt\", header = FALSE)\ndt <- readLines(\"input.txt\")\n```\n:::\n\n\nThis already looks rough. `readLines` because it's strings.\n\n## Part 1\n\nUltimately not too bad. I got to make use of `\\(x)` for an anonymous function. I messed up the second half of the string and had it started at the end of the first half. I got docked a minute for the bad answer but then was able to fix it in time for resubmission.\n\n\n::: {.cell hash='2022-03_cache/html/unnamed-chunk-3_f8dddc0a83429b569a0a68dca549f558'}\n\n```{.r .cell-code}\ndata.frame(\"input\" = dt) %>%\n  mutate(V1 = substr(input, 1, nchar(input) / 2),\n         V2 = substr(input, nchar(input) / 2 + 1, nchar(input))) %>%\n  apply(1, \\(x) {\n    v1 <- unlist(strsplit(x[\"V1\"], \"\"))\n    v2 <- unlist(strsplit(x[\"V2\"], \"\"))\n    \n    return(v1[v1 %in% v2])\n  }) %>%\n  sapply(\\(x) {\n    x <- unique(x)\n    sum(which(letters == x), (which(LETTERS == x) + 26), na.rm = TRUE)\n  }) %>%\n  sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7811\n```\n:::\n:::\n\n\n## Part 2\n\nI struggled with creating the groups for some reason. Once I had that going, the rest was pretty easy.\n\n\n::: {.cell hash='2022-03_cache/html/unnamed-chunk-4_fa9f71192f2a9472a0ed8e1650c1abcc'}\n\n```{.r .cell-code}\ndata.frame(\"input\" = dt) %>%\n  mutate(\"group\" = rep(1:(nrow(.) / 3), each = 3)) -> dt2\n\nd2 <- c()\nfor(g in unique(dt2$group)) {\n  d <- dt2$input[dt2$group == g]\n  \n  v1 <- unlist(strsplit(d[1], \"\"))\n  v2 <- unlist(strsplit(d[2], \"\"))\n  v3 <- unlist(strsplit(d[3], \"\"))\n    \n  d2 <<- c(d2, unique(v3[v3 %in% v1[v1 %in% v2]]))\n}\n\nsapply(d2, \\(x) {\n    x <- unique(x)\n    sum(which(letters == x), (which(LETTERS == x) + 26), na.rm = TRUE)\n  }) %>%\n  sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2639\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}