{
  "hash": "6b2fa7d1d7dfed3ea125d7721837d064",
  "result": {
    "markdown": "---\ntitle: \"2022-14: Regolith Reservoir\"\nformat: html\n---\n\n\nThis doesn't actually look too terrible.\n\n\n::: {.cell hash='2022-14_cache/html/unnamed-chunk-1_29f8799e5831f9c5b3fde509c6b6123f'}\n\n```{.r .cell-code}\nlibrary(mistlecode)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTo install `mistlecode` yourself, run `devtools::install_github('guslipkin/mistlecode')`.\n\n Also loading:  cipheR data.table dplyr purrr slider stringr tidyverse\n```\n:::\n:::\n\n::: {.cell hash='2022-14_cache/html/unnamed-chunk-2_08bc621d11bfae707a8542489cf3e9af'}\n\n```{.r .cell-code}\ndt <- \n  readLines(\"input.txt\") |>\n  str_split(\" -> \")\n```\n:::\n\n\nThis was a standalone in Part 1, but I moved it to a function for Part 2.\n\n\n::: {.cell hash='2022-14_cache/html/unnamed-chunk-3_f5e4b51c37402e07ba9e613a2a62eebe'}\n\n```{.r .cell-code}\ncreateCave <- function(maxRow, maxCol) {\n  cave <- matrix(\" \", maxRow, maxCol)\n  \n  for (j in dt) {\n    for (i in 2:length(j)) {\n      x <-\n        str_split(j[i - 1], \",\", simplify = TRUE)[1, ] |>\n        as.numeric()\n      y <-\n        str_split(j[i], \",\", simplify = TRUE)[1, ] |>\n        as.numeric()\n      \n      cave[x[2]:y[2], x[1]:y[1]] <- \"â–ˆ\"\n    }\n  }\n  return(cave)\n}\n```\n:::\n\n\n## Part 1\n\nFirst step is always making the matrix way bigger than it needs to be and\nfilling it. Because everything's a straight line, I can just match the current\npair to the next pair and draw a line, essentially. Super easy with matrices. I\nwant to check the bottom row for sand and if there isn't sand, drop a new one\nfrom `(1,500)` (hooray for R being y,x and non-zero indexed!). Instead of\niterating through the whole drop, I can just get the index of the last row in\ncolumn 500 where there isn't anything. This saves some computation. If I'm at\nthe bottom, write a piece of sand. From there it's just iterating over\neverything just like the instructions say. Lastly, get the amount of sand in the\ncave then subtract one to account for the last piece of sand that trips the\nloop.\n\n\n::: {.cell hash='2022-14_cache/html/unnamed-chunk-4_4bd2838a9c776ee6f6979480c46b62ef'}\n\n```{.r .cell-code}\nmaxCol <-\n  dt |>\n  str_extract_all(\"[0-9]{1,3},\") |>\n  suppressWarnings() |>\n  unlist() |>\n  str_remove_all(\",\") |>\n  as.numeric() |>\n  max()\ncave <- createCave(maxCol, maxCol)\nwhile(!any(cave[nrow(cave),] == \"o\")) {\n  col <- 500\n  row <- which(cave[,col] != \" \")[1] - 1\n  breakFlag <- FALSE\n  repeat {\n    if (row + 1 > nrow(cave)) { breakFlag <- TRUE }\n    else {\n      if (cave[row + 1, col] == \" \") {\n        row <- row + 1\n      } else if (col >= 2 & cave[row + 1, col - 1] == \" \") {\n        row <- row + 1; col <- col - 1\n      } else if (col < ncol(cave) & cave[row + 1, col + 1] == \" \") {\n        row <- row + 1; col <- col + 1\n      } else { breakFlag <- TRUE }\n    }\n    if (breakFlag) {\n      cave[row, col] <- \"o\"\n      break\n    }\n  }\n}\nwhich(cave == \"o\") |>\n  length() |>\n  sum(-1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 961\n```\n:::\n:::\n\n\n## Part 2\n\nOkay. I need to get the highest row, I can't just make a massive matrix. Then\nadd another row on top of where everything was drawn that will capture the top\nof the pyramid. Also, make a new column placeholder that can be added if I need\nto expand to the left or right. Because of that, I also need to track where\ncolumn 500 is. If I'm going to have a column collision, I need to expand in that\ndirection. Then, it's business as usual, but now I'm checking to see if that\noriginal start point is full, no matter where it is. Lastly, don't subtract one\nbecause the top grain does count now.\n\n\n::: {.cell hash='2022-14_cache/html/unnamed-chunk-5_52cf87da024a6b6b7856363039ac3427'}\n\n```{.r .cell-code}\nmaxRow <-\n  dt |>\n  str_extract_all(\",[0-9]{1,3}\") |>\n  suppressWarnings() |>\n  unlist() |>\n  str_remove_all(\",\") |>\n  as.numeric() |>\n  max()\ncave <- createCave(maxRow + 1, maxCol)\ncave <- rbind(matrix(\" \", 1, ncol(cave)), cave)\nnewCol <- matrix(\" \", nrow(cave), 1)\nstartCol <- 500\nwhile (cave[1,startCol] != \"o\") {\n  col <- startCol\n  row <- which(cave[,col] != \" \")[1] - 1\n  breakFlag <- FALSE\n  repeat {\n    if (col == 2) { \n      cave <- cbind(newCol, cave)\n      startCol <- startCol + 1\n    } else if (col == ncol(cave) - 1) { cave <- cbind(cave, newCol) }\n    \n    if (row + 1 > nrow(cave)) { \n      breakFlag <- TRUE \n    } else {\n      if (cave[row + 1, col] == \" \") {\n        row <- row + 1\n      } else if (col >= 2 & cave[row + 1, col - 1] == \" \") {\n        row <- row + 1; col <- col - 1\n      } else if (col < ncol(cave) & cave[row + 1, col + 1] == \" \") {\n        row <- row + 1; col <- col + 1\n      } else { breakFlag <- TRUE }\n    }\n    if (breakFlag) {\n      cave[row, col] <- \"o\"\n      break\n    }\n  }\n}\nwhich(cave == \"o\") |>\n  length()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 26375\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}