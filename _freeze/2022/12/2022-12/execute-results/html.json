{
  "hash": "0c36359f0b6c2ee329fdd8b98a4a3fc1",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Hill Climbing Algorithm\"\nformat: html\ndraft: true\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(mistlecode)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmat <- \n  readLines(\"input2.txt\") |>\n  stringr::str_split(\"\", simplify = TRUE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nadjacent <- function(point, mat) {\n  y <- point[1]; x <- point[2];\n  tibble::tibble(\n    'y' = c(y-1, y+1, y,   y),\n    'x' = c(x,   x,   x-1, x+1)\n  ) |>\n    dplyr::filter(\n      dplyr::between(.data$y, 1, nrow(mat)),\n      dplyr::between(.data$x, 1, ncol(mat))\n    ) |>\n    purrr::pmap(\\(y, x) {\n      c(y, x)\n    })\n}\n\nhash <- function(x) paste0(x, collapse = ' ')\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfind_path <- function(mat, current, end, neighbors = adjacent, cost = function(x, y) dist(rbind(x, y), method = 'manhattan')[1]) {\n\n  open_list <- collections::priority_queue()$clear()$push(current, 0)\n  g_score <- matrix(Inf, nrow = nrow(mat), ncol = ncol(mat))\n  f_score <- matrix(Inf, nrow = nrow(mat), ncol = ncol(mat))\n  g_score[current[1], current[2]] <- 0\n  f_score[current[1], current[2]] <- dist(rbind(current, end), method = 'manhattan')[1]\n\n  came_from <- list()\n\n  while (open_list$size() > 0) {\n    current_node <- open_list$pop()\n    if (all(current_node == end)) {\n      path <- list()\n      node <- current_node\n      while (!is.null(came_from[[hash(node)]])) {\n        path <- append(path, list(node))\n        node <- came_from[[hash(node)]]\n      }\n      path <-\n        path |>\n        append(list(current)) |>\n        rev()\n      return(list('path' = path[-1], 'cost' = g_score[end[1], end[2]]))\n    }\n    for (neighbor in neighbors(current_node, mat)) {\n      move_cost <- cost(current_node, neighbor, mat)\n      if (is.na(move_cost) || move_cost == Inf) next\n      tentative_g_score <- g_score[current_node[1], current_node[2]] + move_cost\n      if (tentative_g_score < g_score[neighbor[1], neighbor[2]]) {\n        came_from[[hash(neighbor)]] <- current_node\n        g_score[neighbor[1], neighbor[2]] <- tentative_g_score\n        f_score[neighbor[1], neighbor[2]] <- tentative_g_score + dist(rbind(neighbor, end), method = 'manhattan')[1]\n        open_list$push(neighbor, -f_score[neighbor[1], neighbor[2]])\n      }\n    }\n  }\n  return(NULL)\n}\n\nmat |>\n  apply(c(1, 2), \\(x) {\n    if (x == tolower(x)) which(letters == x) else if (x == 'E') 27 else 0\n  }) |>\n  as.integer() |>\n  `dim<-`(dim(mat)) |>\n  find_path(which(mat == 'S', arr.ind = TRUE)[1,], which(mat == 'E', arr.ind = TRUE)[1,], cost = \\(x, y, mat) {\n    x <- mat[x[1], x[2]]; y <- mat[y[1], y[2]];\n    if ((y - x) > 1) NA else (y - x)\n  }) |>\n  purrr::pluck('path') |>\n  (\\(x) { print(length(x)); x; })() |>\n  unlist () |>\n  matrix(ncol = 2, byrow = TRUE) |>\n  tibble::as_tibble() |>\n  setNames(c('row', 'col')) |>\n  dplyr::mutate('rowId' = dplyr::row_number()) |>\n  ggplot2::ggplot(ggplot2::aes(x = col, y = -row)) +\n  ggplot2::geom_point(ggplot2::aes(color = rowId), size = 5, shape = 15)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 31\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\nâ„¹ Using compatibility `.name_repair`.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](2022-12_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n\n```{.r .cell-code}\n  # ggplot2::geom_text(ggplot2::aes(label = rowId))\n```\n:::\n\n\n\n\n440\n441\n436\n437\n\n\n\n\n::: {.cell}\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}