{
  "hash": "077b17c722e0c095b3f66b92fb446b4f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Supply Stacks\"\nformat: html\ndate: \"2022-12-05\"\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(data.table)\n```\n:::\n\n\n\n\nThis was a big mess. It took me forever to read in the input and I eventually stumbled upon `reaf_fwf` because I couldn't remember what a fixed-width file was. I kept looking for delimited readers and tried all sorts of crazy things.\n\n::: {.callout-note}\n\nThe `do_part` function was added after completion so that the code isn't too long when sharing since it's such a minor difference.\n\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfile_name <- \"input.txt\"\nmove <- function(piles, i, ins, part) {\n  moveN <- ins$X2[i]\n  fromN <- ins$X3[i]\n  toN <- ins$X4[i]\n  \n  from <- piles[[fromN]]\n  to <- piles[[toN]]\n  \n  if (part == 1) { to <- c(rev(from[1:moveN]), to) }\n  else if (part == 2) { to <- c(from[1:moveN], to) }\n  from <- tail(from, -moveN)\n  \n  piles[[fromN]] <- from[!is.na(from)]\n  piles[[toN]] <- to[!is.na(to)]\n  \n  return(piles)\n}\n\ndo_part <- function(part) {\n  dt <- readLines(file_name)\n  piles <- read_fwf(file = file_name, na = \"  \", n_max = which(dt == \"\") - 2)\n  \n  piles <- piles |> as.matrix()\n  piles <-\n    piles |>\n    ncol() |>\n    seq_len()\n    lapply(\\(i) piles[, i]) |>\n    lapply(\\(x) str_extract(x[x != \"\"], \"\\\\w\"))\n  \n  ins <-\n    readLines(file_name) |>\n    tail(-(which(dt == \"\") - 1)) |>\n    str_match_all(\"move (\\\\d*) from (\\\\d*) to (\\\\d*)\") |>\n    do.call(rbind, args = _) |>\n    data.frame() |>\n    lapply(as.numeric) |>\n    data.frame()\n  \n  for (i in 1:nrow(ins)) {\n    piles <- move(piles, i, ins, part = part)\n  }\n  piles |>\n    lapply(\\(x) head(x, 1)) |>\n    unlist() |>\n    paste(collapse = \"\")\n}\n```\n:::\n\n\n\n\n## Part 1\n\nOnce I had the input in, it was relatively smooth sailing. I missed the part in part 1 where the boxes move one by one (oh part 2, how I wish I knew you then...) but once I had that fixed, I was looking pretty good. I got the test input working but then the real input wasn't working. I eventually realized that my regex `\\\\d` was missing any numbers greater than 9 once that was fixed, everything else was pretty easy.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndo_part(1)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 8 Columns: 9\n── Column specification ────────────────────────────────────────────────────────\n\nchr (9): X1, X2, X3, X4, X5, X6, X7, X8, X9\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in lapply(data.frame(str_match_all(tail(readLines(file_name),\n-(which(dt == : NAs introduced by coercion\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"ZBDRNPMVH\"\n```\n\n\n:::\n:::\n\n\n\n\n## Part 2\n\nAfter firing off a celebratory text message, I read part 2, deleted my `rev` and was done in 52 seconds!\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndo_part(2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 8 Columns: 9\n── Column specification ────────────────────────────────────────────────────────\n\nchr (9): X1, X2, X3, X4, X5, X6, X7, X8, X9\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in lapply(data.frame(str_match_all(tail(readLines(file_name),\n-(which(dt == : NAs introduced by coercion\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"WDLPFNNNB\"\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}