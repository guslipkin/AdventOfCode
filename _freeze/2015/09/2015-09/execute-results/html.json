{
  "hash": "4256e807c116c7c551f8538362edaadf",
  "result": {
    "markdown": "---\ntitle: \"09: All in a Single Night\"\n---\n\n::: {.cell hash='2015-09_cache/html/unnamed-chunk-1_356a089bf3db6672046f772cd4c8fdc7'}\n\n```{.r .cell-code}\nlibrary(mistlecode)\ndt <- \n  fread(\"input.txt\") |>\n  `colnames<-`(c(\"start\", \"to\", \"end\", \"eq\", \"dist\")) |>\n  select(start, end, dist) |>\n  arrange(start, end)\nstops <- \n  unique(c(dt$start, dt$end)) |>\n  sort()\n```\n:::\n\n\nOh no! It's the traveling salesman!\n\n\n::: {.cell hash='2015-09_cache/html/unnamed-chunk-2_eec3f5bf949a91158639be36d4bb6066'}\n\n```{.r .cell-code}\nget_stops <- function(m) {\n  m |>\n    TSP::as.TSP() |>\n    TSP::insert_dummy(label = \"dummy\") |>\n    TSP::solve_TSP(method = \"nn\", control = list(rep = 1000)) |>\n    TSP::cut_tour('dummy') |>\n    names() |>\n    data.frame() |>\n    `colnames<-`(c(\"start\")) |>\n    mutate(\"end\" = lead(start)) |>\n    filter(!is.na(end))\n}\n\nget_dist <- function(m, stops) {\n  m |>\n    data.frame() |>\n    rownames_to_column() |>\n    pivot_longer(!c(\"rowname\")) |>\n    `colnames<-`(c(\"start\", \"end\", \"dist\")) |>\n    right_join(stops, by = c(\"start\", \"end\")) |>\n    pull(dist) |>\n    sum()\n}\n```\n:::\n\n\n## Part 1\n\nI figured with R the way it is, there had to be a package that can solve it. Sure enough, `TSP` exists. Creating the symmetric matrix was a bit of a pain, but then I was getting solutions for the test input but not the real input. Ugh. I slept on the problem then tried replacing the diagonal with `NA`, rather than zeroes. That seemed to do the trick.\n\n\n::: {.cell hash='2015-09_cache/html/unnamed-chunk-3_56083a06bafbef33885f59df75166fd3'}\n\n```{.r .cell-code}\nm <-\n  expand.grid(stops, stops) |>\n  data.table() |>\n  `colnames<-`(c(\"start\", \"end\")) |>\n  left_join(dt, by = c(\"start\", \"end\")) |>\n  mutate(dist = ifelse(start == end, NA_integer_, dist)) |>\n  dcast(start ~ end, value.var = \"dist\") |>\n  data.frame() |>\n  `rownames<-`(stops) |>\n  select(-start) |>\n  as.matrix()\n\nm <-\n  map2_dbl(m, t(m), \\(x, y) {\n    if(is.na(x) & !is.na(y)) return(y) else return(x)\n  }) |>\n  matrix(length(stops), length(stops)) |>\n  `colnames<-`(stops) |>\n  `rownames<-`(stops) |>\n  as.matrix() \n\nstops <- get_stops(m)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: executing %dopar% sequentially: no parallel backend registered\n```\n:::\n\n```{.r .cell-code}\nget_dist(m, stops)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 251\n```\n:::\n:::\n\n\n## Part 2\n\nOh boy. I think I have an easy solution for this! If I can re-scale the values so that the smallest numbers are biggest and the biggest numbers are smallest, I can just re-run to get the cities in order, then use the original distances. A quick `apply` with $\\frac{1}{x}$ and I'm on my way. Just need to throw everything into functions and there we go!\n\n\n::: {.cell hash='2015-09_cache/html/unnamed-chunk-4_3db50529b1e205e7920dd3d8548e3d9a'}\n\n```{.r .cell-code}\nstops <-\n  m |>\n  apply(c(1, 2), \\(x) 1 / x) |>\n  get_stops()\nget_dist(m, stops)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 898\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}