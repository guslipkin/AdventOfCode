{
  "hash": "eabd8411c63de21ca5b3023f6ea8223d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"23: Opening the Turing Lock\"\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(mistlecode)\n\ninstructions <- function(instruction) {\n  force(instruction)\n  function(dt_i) {\n    dt <- dt_i[[1]]; i <- dt_i[[2]]; a <- dt_i[[3]]; b <- dt_i[[4]];\n    if (!is.na(dt[[i]]$register)) {\n      x <- if (dt[[i]]$register == \"a\") a else b\n      x <- case_match(\n        instruction,\n        \"hlf\" ~ x / 2,\n        \"tpl\" ~ x * 3,\n        \"inc\" ~ x + 1,\n        .default = x\n      )\n      if (dt[[i]]$register == \"a\") a <- x else b <- x\n    } else { x <- NA }\n    \n    if (instruction == \"jmp\" | \n        (instruction == \"jio\" & x == 1) |\n        (instruction == \"jie\" & x %% 2 == 0)) {\n      i <- i + dt[[i]]$offset\n    } else {\n      i <- i + 1\n    }\n    \n    if (i > length(dt)) { return(list(a, b)) }\n    return(list(dt, i, a, b))\n  }\n}\n\ndt <-\n  readLines(\"input.txt\") |>\n  str_split(\"[, \\\\+]+\") |>\n  map(\\(x) {\n    if (x[1] == \"jmp\") {\n      x <- list(x[1], NA, x[2])\n    } else if (length(x) == 2) {\n      x <- list(x[1], x[2], NA)\n    } else {\n      x <- as.list(x)\n    }\n    names(x) <- c(\"instruction\", \"register\", \"offset\")\n    x$instruction <- instructions(x$instruction)\n    x$offset <- as.integer(x$offset)\n    return(x)\n  })\n```\n:::\n\n\n\n\n## Part 1\n\nThis was very annoying. I'm happy I got to use function factories, but I really do need to find a better way to write these \"follow instructions\" style programs. Maybe something with S4 or S7 so I can self reference?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt_i <- dt[[1]]$instruction(list(dt, 1, 0, 0))\nrepeat {\n  dt_i <- dt_i[[1]][[dt_i[[2]]]]$instruction(dt_i)\n  if (length(dt_i) == 2) { break }\n}\ndt_i[[2]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 255\n```\n\n\n:::\n:::\n\n\n\n\n## Part 2\n\nOh jeez. A super easy copy/paste part 2!\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndt_i <- dt[[1]]$instruction(list(dt, 1, 1, 0))\nrepeat {\n  dt_i <- dt_i[[1]][[dt_i[[2]]]]$instruction(dt_i)\n  if (length(dt_i) == 2) { break }\n}\ndt_i[[2]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 334\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}