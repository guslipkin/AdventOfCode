{
  "hash": "8f78086bcb03746f73be538240f59f51",
  "result": {
    "markdown": "---\ntitle: \"20: Infinite Elves and Infinite Houses\"\n---\n\n::: {.cell hash='2015-20_cache/html/unnamed-chunk-1_e2dc44832943c879b31e59242d70373e'}\n\n```{.r .cell-code}\nlibrary(mistlecode)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTo install `mistlecode` yourself, run `devtools::install_github('guslipkin/mistlecode')`.\n\n Also loading:  cipheR data.table dplyr purrr slider stringr tidyverse glue\n```\n:::\n\n```{.r .cell-code}\nlibrary(Rcpp)\nlibrary(RcppArmadillo)\n```\n:::\n\n\n## Part 1\n\nThere's something I can do with prime factorization, I just can't figure it out. Ugh. Took me a fat minute but I was able to work with my idea about how if you divide a number `x` by `1:x` then round down, you get the total number of times each elf would have stopped at a house before `x`. Just had to get that set up right and we're good to go. Not the fastest, but it works. Maybe another chance for `Rcpp` if I'm up for it later.\n\nSpoiler alert. I wasn't happy with the plain R version and re-wrote it in `Rcpp`. At this point I've been through so many versions, I think my working `R` solution is lost...\n\nDouble spoiler... I did it again, but way better this time.\n\n::: {.panel-tabset}\n\n### `R` (Best)\n\n\n::: {.cell hash='2015-20_cache/html/unnamed-chunk-2_a9ac6ca3f41af7bd14c978dcb960e966'}\n\n```{.r .cell-code}\ntarget <- 36e6\ni <- 0\nrepeat {\n  i <- i + 1\n  n <- sum(RcppBigIntAlgos::divisorsBig(i))\n  if (n >= target / 10) break\n}\ni\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 831600\n```\n:::\n:::\n\n\n\n### `Rcpp`\n\n\n::: {.cell hash='2015-20_cache/html/unnamed-chunk-3_ee08a1a907f55ceb431b2e7bfd2e0960'}\n\n```{.r .cell-code}\ncppFunction('\nIntegerVector part1(int target, int total_l) {\n  IntegerVector m_vec, sum_vec(total_l, 0.0), v;\n  IntegerMatrix m_mat;\n  int idx = 0;\n  while (idx <= total_l) {\n    idx++;\n    if (idx % 1000 == 0) { std::cout << \"\\\\r\" << idx; }\n    v = rep_len(IntegerVector::create(idx), total_l / idx);\n    m_mat = IntegerMatrix(idx, v.size());\n    m_mat(idx - 1, _) = v * 10;\n    m_vec = IntegerVector(m_mat);\n    m_vec.attr(\"dim\") = R_NilValue;\n    m_vec = rep_len(m_vec, total_l);\n    sum_vec = sum_vec + m_vec;\n    for (int i = 0; i < sum_vec.size(); i++) {\n      if (i <= idx & sum_vec[i] >= target) {\n        if (idx > 1000) { std::cout.clear(); }\n        return IntegerVector::create(i) + 1;\n      }\n    }\n  }\n  if (idx > 1000) { std::cout.clear(); }\n  return sum_vec;\n}\n')\npart1(36e6, 1e6)\n```\n:::\n\n\n### `R`\n\n\n::: {.cell hash='2015-20_cache/html/unnamed-chunk-4_8e643095a507da64dbe918efb0b3ca08'}\n\n```{.r .cell-code}\ntarget <- 36e6 / 10\nidx <- 1\ns <- 0\nd <- seq_len(target)\ndenominator <- d\nrepeat {\n  denominator <- d[seq_len(idx)]\n  s <- sum(denominator[idx %% denominator == 0])\n  if (s < target) idx <- idx + 1 else break\n}\nidx\n```\n:::\n\n\n:::\n\n## Part 2\n\nFinally. Remembering the logic for the last fifty divisors took longer than it should've. At least it's over now...\n\n\n::: {.cell hash='2015-20_cache/html/unnamed-chunk-5_823b97991256004bd7b05980e0b36146'}\n\n```{.r .cell-code}\ntarget <- 36e6\ni <- 0\nrepeat {\n  i <- i + 1\n  d <- \n    i |>\n    RcppBigIntAlgos::divisorsBig() |>\n    as.integer()\n  n <- sum(d[i %/% d <= 50] * 11)\n  if (n >= target) break\n}\ni\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 884520\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}