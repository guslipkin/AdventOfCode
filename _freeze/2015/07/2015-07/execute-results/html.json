{
  "hash": "867fa36202bf7307cb5622572021d701",
  "result": {
    "markdown": "---\ntitle: \"2015-07: Some Assembly Required\"\nformat: html\n---\n\n::: {.cell hash='2015-07_cache/html/unnamed-chunk-1_395252b03559c7a07d37c0f94606bd7c'}\n\n```{.r .cell-code}\nlibrary(mistlecode)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: cipheR\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: dplyr\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:data.table':\n\n    between, first, last\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: pacman\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: purrr\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'purrr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:data.table':\n\n    transpose\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: slider\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: stringr\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: tidyverse\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.4.0     ✔ readr   2.1.3\n✔ tibble  3.1.8     ✔ forcats 0.5.2\n✔ tidyr   1.2.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::between()   masks data.table::between()\n✖ dplyr::filter()    masks stats::filter()\n✖ dplyr::first()     masks data.table::first()\n✖ dplyr::lag()       masks stats::lag()\n✖ dplyr::last()      masks data.table::last()\n✖ purrr::transpose() masks data.table::transpose()\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nTo install `mistlecode` yourself, run `devtools::install_github('guslipkin/mistlecode')`.\n\n Also loading:  cipheR data.table dplyr purrr slider stringr tidyverse\n```\n:::\n\n```{.r .cell-code}\ndt <- readLines(\"input.txt\")\n```\n:::\n\n\nI've looked at this one before and it's a bit messy. I had a few false starts, especially in regards to parsing the input, but eventually settled on using function factories to build the bitwise function calls and some gross regex to get the rest of it in line for that to happen.\n\n\n::: {.cell hash='2015-07_cache/html/unnamed-chunk-2_6c7307849e559d4e60bfc42310c5c7b8'}\n\n```{.r .cell-code}\ngate <-   c(\"AND\",      \"OR\",     \"NOT\",     \"LSHIFT\",     \"RSHIFT\")\ngate_r <- c(\"bitwAnd\",  \"bitwOr\", \"bitwNot\", \"bitwShiftL\", \"bitwShiftR\")\n\noperation <- function(op) {\n  if (is.na(op)) {\n    function(x, y) { glue::glue(\"{x} -> {y}\") }\n  }\n  else {\n    function(x, y, z) {\n      op <- which(gate == op)\n      if (gate[op] == \"NOT\") { glue::glue(\"{gate_r[op]}({y}) -> {z}\") } \n      else { glue::glue(\"{gate_r[op]}({x}, {y}) -> {z}\") }\n    }\n  }\n}\n\nprocess <- function(x) {\n  x <- str_replace(x, \"NOT\", \"zzz NOT\")\n  op <- lapply(str_match(x, \"[A-Z]+\"), operation)\n  \n  x |>\n    str_replace_all(\"([a-z]+)\", \"x\\\\1\") |>\n    str_match_all(\n      \"(([a-z0-9]+) [A-Z]+ ([a-z0-9]+) -> ([a-z]+))|(([a-z0-9]+) -> ([a-z]+))\"\n    ) |>\n    map2_chr(op, \\(y, o) {\n      y <- as.vector(y)\n      is_not_gate <- sum(is.na(y)) == 4\n      y <- \n        y |>\n        na.omit() |>\n        as.vector()\n      if (is_not_gate) {\n        y <- tail(y, 2) \n        o(y[1], y[2])\n      } else {\n        y <- tail(y, 3)\n        o(y[1], y[2], y[3])\n      }\n    })\n}\n```\n:::\n\n\nThis was originally the solution to part 1, but since it's reusable for part 2, I put it into a function.\n\n\n::: {.cell hash='2015-07_cache/html/unnamed-chunk-3_bbcfde542896d4b97f37f1b40d1a8cd5'}\n\n```{.r .cell-code}\nrun <- function(dt) {\n  dt2 <- process(dt)\n  len_dt2 <<- length(dt2)\n  env <- new.env()\n  while(len_dt2 > 0) {\n    for (i in seq_len(len_dt2)) {\n      tryCatch({\n        eval(parse(text = dt2[i]), envir = env)\n        dt2 <- dt2[-i]\n      }, error = function(e) {} )\n    }\n    len_dt2 <<- length(dt2)\n  }\n  a <- get(\"xa\", envir = env)\n  rm(list = grep(\"x[a-z]+\", ls(), value = TRUE), envir = env)\n  a\n}\n```\n:::\n\n\n\n## Part 1\n\nI initially tried just writing to a file then sourcing it, but quickly discovered that my statements were out of order. I figured a loop would be fast enough, then I can use a `tryCatch` to skip over any errors, paring down the statements until they all run. I had a bit of trouble with my eval statement until I remembered I have to parse the dang thing first.\n\n\n::: {.cell hash='2015-07_cache/html/unnamed-chunk-4_7c3725af5f5253f3a157547ac13633fc'}\n\n```{.r .cell-code}\n(a <- run(dt))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3176\n```\n:::\n:::\n\n\n## Part 2\n\nThis bit was easy. Just had to copy to a new object for some reason then it was a simple replacement with the value from part 1.\n\n\n::: {.cell hash='2015-07_cache/html/unnamed-chunk-5_32b6288f287a3088d03074bc25e9c30e'}\n\n```{.r .cell-code}\ndt2 <- dt\ndt2[str_detect(dt2, \"-> b$\")] <- glue::glue(\"{a} -> b\")\nrun(dt2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 14710\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}