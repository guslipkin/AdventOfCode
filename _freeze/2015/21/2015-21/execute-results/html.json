{
  "hash": "5dc53a22f0b599a952e958e0710c9d26",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"21: RPG Simulator 20XX\"\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(mistlecode)\n\nshop <- \n  c(0, which(readLines(\"item_shop.txt\") == \"\")) |>\n  map(\\(sk) {\n    dt <- \n      fread(\"item_shop.txt\", skip = sk) |>\n      t() |>\n      as.data.frame() |>\n      janitor::row_to_names(1) |>\n      as.list() |>\n      map(\\(x) { \n        x <- as.numeric(x)\n        if (length(x) == 3) {\n          names(x) <- c(\"cost\", \"damage\", \"armor\")\n        } else {\n          names(x) <- c(\"modifier\", \"cost\", \"damage\", \"armor\")\n        }\n        x \n      })\n  }) |>\n  `names<-`(c(\"weapons\", \"armor\", \"rings\"))\n\nboss <-\n  readLines(\"input.txt\") |>\n  str_split(\": \") |>\n  map(\\(x) {\n    y <- as.numeric(x[2])\n    names(y) <- x[1]\n    as.list(y)\n  }) |>\n  unlist(recursive = FALSE) |>\n  `names<-`(c(\"hp\", \"damage\", \"armor\"))\n```\n:::\n\n\n\n\n## Part 1\n\nUghhh. Not that difficult but I swapped the order of who goes first in my brain then suffered for a long time. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncombinations <- function(shop, n) {\n  n |>\n    map(\\(n) {\n      if (n == 0) return(list(\"V0\" = 0))\n      shop |>\n        length() |>\n        combn(n) |>\n        as.data.frame() |>\n        as.list()\n    }) |>\n    unlist(recursive = FALSE)\n}\nweapons <- combinations(shop$weapons, 1)\narmor <- combinations(shop$armor, 0:1)\nrings <- combinations(shop$rings, 0:2)\n\nexpand.grid(\n  \"w\" = seq_along(weapons),\n  \"a\" = seq_along(armor),\n  \"r\" = seq_along(rings)\n)|>\n  pmap(\\(w, a, r) {\n    w <- as.list(shop$weapons[[weapons[[w]]]])\n    a <- if (armor[[a]] == 0) list(\"cost\" = 0, \"armor\" = 0) else as.list(shop$armor[[armor[[a]]]])\n    r <- if (any(rings[[r]] == 0)) list(list(\"modifier\" = 0, \"cost\" = 0, \"damage\" = 0, \"armor\" = 0)) else map(rings[[r]], ~ as.list(shop$rings[[.x]]))\n    damage <- w$damage + sum(map_dbl(r, ~ .x$damage), na.rm = TRUE)\n    armor <- a$armor + sum(map_dbl(r, ~ .x$armor), na.rm = TRUE)\n    hp <- 100\n    boss_hp <- boss$hp\n    repeat {\n      my_damage <- damage - boss$armor\n      boss_hp <- if (my_damage <= 0) { boss_hp - 1 } else { boss_hp - my_damage }\n      if (boss_hp <= 0) { break }\n      boss_damage <- boss$damage - armor\n      hp <- if (boss_damage <= 0) { hp - 1 } else { hp - boss_damage }\n      if (hp <= 0) { break }\n    }\n    if (hp > 0 & boss_hp <= 0) {\n      return(w$cost + a$cost + sum(map_int(r, ~ .x$cost)))\n    } else {\n      return(NA_integer_)\n    }\n  }) |>\n  unlist() |>\n  min(na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 78\n```\n\n\n:::\n:::\n\n\n\n\n## Part 2\n\nClassic Advent. smh. But super easy.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexpand.grid(\n  \"w\" = seq_along(weapons),\n  \"a\" = seq_along(armor),\n  \"r\" = seq_along(rings)\n)|>\n  pmap(\\(w, a, r) {\n    w <- as.list(shop$weapons[[weapons[[w]]]])\n    a <- if (armor[[a]] == 0) list(\"cost\" = 0, \"armor\" = 0) else as.list(shop$armor[[armor[[a]]]])\n    r <- if (any(rings[[r]] == 0)) list(list(\"modifier\" = 0, \"cost\" = 0, \"damage\" = 0, \"armor\" = 0)) else map(rings[[r]], ~ as.list(shop$rings[[.x]]))\n    damage <- w$damage + sum(map_dbl(r, ~ .x$damage), na.rm = TRUE)\n    armor <- a$armor + sum(map_dbl(r, ~ .x$armor), na.rm = TRUE)\n    hp <- 100\n    boss_hp <- boss$hp\n    repeat {\n      my_damage <- damage - boss$armor\n      boss_hp <- if (my_damage <= 0) { boss_hp - 1 } else { boss_hp - my_damage }\n      if (boss_hp <= 0) { break }\n      boss_damage <- boss$damage - armor\n      hp <- if (boss_damage <= 0) { hp - 1 } else { hp - boss_damage }\n      if (hp <= 0) { break }\n    }\n    if (hp <= 0 & boss_hp > 0) {\n      return(w$cost + a$cost + sum(map_int(r, ~ .x$cost)))\n    } else {\n      return(NA_integer_)\n    }\n  }) |>\n  unlist() |>\n  max(na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 148\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}