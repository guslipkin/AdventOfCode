{
  "hash": "caffa97931780caa99a6de0e22bab755",
  "result": {
    "markdown": "---\ntitle: \"18: Like a GIF For Your Yard\"\n---\n\n::: {.cell hash='2015-18_cache/html/unnamed-chunk-1_d9e37f4a0d6a0e49c943768714d56aa9'}\n\n```{.r .cell-code}\nlibrary(mistlecode)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTo install `mistlecode` yourself, run `devtools::install_github('guslipkin/mistlecode')`.\n\n Also loading:  cipheR data.table dplyr purrr slider stringr tidyverse glue\n```\n:::\n\n```{.r .cell-code}\ndt <-\n  readLines(\"input.txt\") |>\n  str_split(\"\") |>\n  map(\\(x) {\n    x |>\n      matrix(nrow = 1) |>\n      data.frame() \n  }) |>\n  bind_rows() |>\n  as.matrix()\n```\n:::\n\n\n## Part 1\n\nI've got a plan this time...\n\nUgh. I need to find a way to make this faster.\n\n\n::: {.cell hash='2015-18_cache/html/unnamed-chunk-2_0544d7b9669e68bf5d2e9ddc30ecb487'}\n\n```{.r .cell-code}\nprocess_light <- function(y, x, m) {\n  state <- m[y,x]\n  m[y,x] <- \"\"\n  val <- get_adjacent_values(y, x, m)\n  if (state == \"#\") {\n    if (sum(val == \"#\") %in% 2:3) {\n      return(\"#\")\n    } else {\n      return(\".\")\n    }\n  } else if (state == \".\") {\n    if (sum(val == \"#\") == 3) {\n      return(\"#\")\n    } else {\n      return(\".\")\n    }\n  }\n}\n\ndo_flash <- function(dt, flash, i) {\n  while (i > 0) {\n    p()\n    dt <- \n      expand.grid(\n        \"y\" = seq_len(nrow(dt)),\n        \"x\" = seq_len(ncol(dt))\n      ) |>\n      furrr::future_pmap_chr(\\(y, x) {\n        rlang::exec(quote(flash), y, x, dt)\n      }) |>\n      matrix(nrow = nrow(dt), byrow = FALSE)\n    i <- i - 1\n  }\n  return(dt)\n}\n\nfuture::plan(future::multicore, workers = future::availableCores())\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in supportsMulticoreAndRStudio(...): [ONE-TIME WARNING] Forked\nprocessing ('multicore') is not supported when running R from RStudio because\nit is considered unstable. For more details, how to control forked processing\nor not, and how to silence this warning in future R sessions, see\n?parallelly::supportsMulticore\n```\n:::\n\n```{.r .cell-code}\nprogressr::with_progress({\n  i <- 100\n  p <- progressr::progressor(steps = i)\n  do_flash(dt, process_light, i) |>\n    map_int( ~ .x == \"#\") |>\n    sum()\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 814\n```\n:::\n\n```{.r .cell-code}\nfuture::plan(future::sequential)\n```\n:::\n\n\n## Part 2\n\nAt least it's not like 1000 iterations. Just some small changes and a long wait and we're good to go.\n\n\n::: {.cell hash='2015-18_cache/html/unnamed-chunk-3_4c719258501d265e6ec0a8b72af9682b'}\n\n```{.r .cell-code}\nprocess_light <- function(y, x, m) {\n  m[1,1] <- m[nrow(m),1] <- m[1,ncol(m)] <- m[nrow(m), ncol(m)] <- \"#\"\n  state <- m[y,x]\n  m[y,x] <- \"\"\n  val <- get_adjacent_values(y, x, m)\n  if (state == \"#\") {\n    if (sum(val == \"#\") %in% 2:3) {\n      return(\"#\")\n    } else {\n      return(\".\")\n    }\n  } else if (state == \".\") {\n    if (sum(val == \"#\") == 3) {\n      return(\"#\")\n    } else {\n      return(\".\")\n    }\n  }\n}\n\ndo_flash <- function(dt, flash, i) {\n  while (i > 0) {\n    p()\n    dt <- \n      expand.grid(\n        \"y\" = seq_len(nrow(dt)),\n        \"x\" = seq_len(ncol(dt))\n      ) |>\n      furrr::future_pmap_chr(\\(y, x) {\n        rlang::exec(quote(flash), y, x, dt)\n      }) |>\n      matrix(nrow = nrow(dt), byrow = FALSE)\n    i <- i - 1\n  }\n  dt[1,1] <- dt[nrow(dt),1] <- dt[1,ncol(dt)] <- dt[nrow(dt), ncol(dt)] <- \"#\"\n  return(dt)\n}\n\nfuture::plan(future::multicore, workers = future::availableCores())\nprogressr::with_progress({\n  i <- 100\n  p <- progressr::progressor(steps = i)\n  do_flash(dt, process_light, i) |>\n    map_int( ~ .x == \"#\") |>\n    sum()\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 924\n```\n:::\n\n```{.r .cell-code}\nfuture::plan(future::sequential)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}