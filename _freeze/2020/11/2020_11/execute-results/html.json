{
  "hash": "8c7b0ca1f2d2a36ffbe32521b0451bbd",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Seating System\"\nformat: html\ndate: \"2020-12-11\"\ndraft: true\neval: false\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(mistlecode)\n\noptions(scipen = 999)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndt <-\n  readLines(\"input2.txt\") |>\n  str_split(\"\") |>\n  as_tibble(.name_repair = 'universal') |>\n  suppressMessages() |>\n  as.matrix() |>\n  t()\n```\n:::\n\n\n\n\n\n## Part 1\n\nThis wasn't so bad once I fixed `flash`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndo_flash <- function(dt) {\n  flash(\n    dt,\n    \\(y, x, m) { \n      val <- m[y, x]\n      m[y, x] <- NA\n      adj <- \n        mistlecode::get_adjacent_values(y, x, m) |>\n        as.vector() |>\n        purrr::discard(is.na)\n      if (val == 'L' & all(adj[adj != '.'] == 'L')) { \n        return('#')\n      } else if (val == '#' & sum(adj == '#') >= 4) {\n        return('L')\n      } else {\n        return(val)\n      }\n    },\n    i = 1,\n    grid = expand.grid(\"y\" = seq_len(nrow(dt)), \"x\" = seq_len(ncol(dt)))\n  )\n}\n\nold <- dt\nfuture::plan(future::multisession, workers = future::availableCores() - 1)\nprogressr::with_progress({\n  repeat {\n    p <- progressr::progressor(steps = ncol(dt) * nrow(dt))\n    new <- do_flash(old)\n    if (all(new == old)) break else old <- new\n  }\n})\nfuture::plan(future::sequential)\nsum(old == '#')\n```\n:::\n\n\n\n\n## Part 2\n\nOh no. It's that treetops one again! (That's probably in a year or two chronologically...)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflash <- function(m, .fn, i = 1, grid = NULL) {\n  if (is.null(grid)) {\n    grid <- expand.grid(\"y\" = seq_len(nrow(m)), \"x\" = seq_len(ncol(m)))\n  }\n  while (i > 0) {\n    m <-\n      grid |>\n      furrr::future_pmap(\\(y, x) {\n        p()\n        .fn(y = y, x = x, m = m)\n      }) |>\n      unlist() |>\n      matrix(nrow = nrow(m), byrow = FALSE)\n    i <- i - 1\n  }\n  return(m)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nflash2 <- function(m, .fn_run, i = 1, .fn_check = NULL, grid = NULL, ...) {\n  if (is.null(grid)) {\n    grid <- expand.grid(\"y\" = seq_len(nrow(m)), \"x\" = seq_len(ncol(m)))\n  }\n  # if (!is.null(.fn_check)) {\n  #   grid <-\n  #     grid |>\n  #     furrr::future_pmap_dfr(\\(y, x) {\n  #       p()\n  #       .fn_check(y, x, m = m)\n  #     }) |>\n  #     unique()\n  # }\n  oldM <- m\n  while (i > 0) {\n    m <- \n      grid |>\n      # furrr::future_pwalk(\\(y, x) {\n      purrr::pmap(\\(y, x) {\n        p()\n        m[y,x] <<- .fn_run(y, x, m = m)\n      }) |>\n      unlist() |>\n      matrix(nrow = nrow(m), byrow = FALSE)\n    i <- i - 1\n  }\n  print(all(oldM == m))\n  return(m)\n}\n\nget_cardinals_at <- function(m, y, x) {\n  g <- expand.grid(\n    'y' = seq_len(nrow(m)),\n    'x' = seq_len(ncol(m))\n    )\n  not_diagonal <- round(sqrt(abs(y - g$y)^2 + abs(x - g$x)^2) %% sqrt(2), 6) %in% round(c(0, sqrt(2)), 6)\n  north_south <- g$x != x\n  east_west <- g$y != y\n  m[!not_diagonal & north_south & east_west] <- NA\n  d <-\n    m |>\n    mistlecode::matrix_to_coords() |>\n    dplyr::filter(!is.na(.data$data))\n  dplyr::bind_rows(\n    'n'  = d[d$row <  y & d$col == x,],\n    's'  = d[d$row >  y & d$col == x,],\n    'e'  = d[d$row == y & d$col >  x,],\n    'w'  = d[d$row == y & d$col <  x,],\n    'ne' = d[d$row <  y & d$col >  x,],\n    'nw' = d[d$row <  y & d$col <  x,],\n    'se' = d[d$row >  y & d$col >  x,],\n    'sw' = d[d$row >  y & d$col <  x,],\n    .id = 'dir'\n  ) |>\n    dplyr::mutate(\n      'dist' = sqrt(abs(row - y)^2 + abs(col - x)^2)\n    ) |>\n    dplyr::arrange(.data$dir, .data$dist)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndo_flash <- function(mm) {\n  flash2(\n    mm,\n    \\(y, x, m) {\n      val <- m[y, x]\n      m[y, x] <- NA\n      \n      adj <- \n        m |>\n        get_cardinals_at(y, x) |>\n        dplyr::filter(data != '.') |>\n        dplyr::filter(dist == min(dist), .by = 'dir') |>\n        dplyr::pull(data) |>\n        purrr::discard(is.na) |>\n        unname()\n      \n      adj <- if (length(adj) == 0) '' else adj\n      \n      if (val == 'L' & all(adj == 'L')) { \n        return('#')\n      } else if (val == '#' & sum(adj == '#') >= 5) {\n        return('L')\n      } else {\n        return(val)\n      }\n    }\n    # i = 1,\n    # \\(y, x, m) {\n    #   if (length(y) * length(x) == length(m)) return(data.frame('y' = y, 'x' = x))\n    #   m |>\n    #     get_cardinals_at(y, x) |>\n    #     dplyr::filter(data != '.') |>\n    #     dplyr::select(y = row, x = col)\n    # },\n    # grid = grid\n  )\n}\n\nold <- dt\n# new <- dt\n# grid <- expand.grid(\"y\" = seq_len(nrow(dt)), \"x\" = seq_len(ncol(dt)))\nprogressr::with_progress({\n  repeat {\n    p <- progressr::progressor(steps = ncol(dt) * nrow(dt) * 2)\n    new <- do_flash(old)\n    if (all(new == old)) break\n    # grid <-\n    #   which(new != old, arr.ind = TRUE) |>\n    #   data.frame() |>\n    #   dplyr::rename('y' = 'row', 'x' = 'col')\n    old <- new\n  }\n})\nsum(old == '#')\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}