{
  "hash": "e935453b33b1a8879f64021f5423bb32",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Handy Haversacks\"\nformat: html\ndate: \"2020-12-07\"\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(mistlecode)\noptions(scipen = 999)\n\ndf <- \n  read.csv(\"input.csv\") |>\n  dplyr::mutate(dplyr::across(\n      tidyselect::matches('child[2-4]C'), \n      \\(x) ifelse(as.character(x) == \" \", NA, x)\n  ))\n\ndf$child2C[as.character(df$child2C) == \" \"] <- NA\ndf$child3C[as.character(df$child3C) == \" \"] <- NA\ndf$child4C[as.character(df$child4C) == \" \"] <- NA\n```\n:::\n\n\n\n\n## Part 1\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlongerDF <- data.frame(parent = \"\", nChild = 0, cChild = \"\")\n\nfor(col in seq(3, 9, by = 2)) {\n  for(r in 1:nrow(df)) {\n    if(!is.na(df[r,col-1]))\n      for(i in 1:df[r,col-1]) {\n        longerDF <- rbind(longerDF, data.frame(parent = df[r,1], \n                                               nChild = df[r,col-1], \n                                               cChild = df[r,col]))\n    }\n  }\n}\nlongerDF <- longerDF[-1,]\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nshinygoldDF <- \n  longerDF[longerDF$cChild == \"shiny gold\" | longerDF$parent == \"shiny gold\",]\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlevel <- c(\"shiny gold\")\noldRows <- 0\n\nwhile(oldRows != nrow(shinygoldDF)) {\n  oldRows <- nrow(shinygoldDF)\n  level <- unlist(shinygoldDF$parent)\n  shinygoldDF <-\n    df[as.character(df$parent) %in% level |\n         as.character(df$child1C) %in% level |\n         as.character(df$child2C) %in% level |\n         as.character(df$child3C) %in% level |\n         as.character(df$child4C) %in% level, ]\n}\nnrow(shinygoldDF) - 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 164\n```\n\n\n:::\n:::\n\n\n\n\n## Part 2\n\nHoly crap. I actually did it. I had some help from ChatGPT because I really struggle with recursion like this where it can't just be a for loop (and even with the help it took four years...). I think the key point for me here is that I really like to do early returns, and you can't. The return must be at the bottom and explicit. I also tried really hard not to use a `for` loop, but that makes it a lot harder and more confusing to iterate through everything. I'm hoping I can learn from this and apply it to future recursion problems.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <-\n  'input.txt' |>\n  readLines() |> \n  stringr::str_replace_all(' bags contain ', ',') |>\n  stringr::str_remove_all('(bags?[\\\\. ]?)') |>\n  stringr::str_split(' ?, ?') |>\n  purrr::map(\\(x) {\n    x <-\n      x |>\n      stringr::str_match('([0-9]*) ?([a-z]+ [a-z]+)') |>\n      tibble::as_tibble() |>\n      dplyr::select(-1) |>\n      dplyr::mutate('V2' = as.integer(.data$V2))\n    x |>\n      dplyr::filter(!is.na(.data$V2)) |>\n      tidyr::uncount(weights = .data$V2) |>\n      dplyr::pull(.data$V3) |>\n      list() |>\n      setNames(x$V3[1])\n  }) |>\n  unlist(recursive = FALSE)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\nâ„¹ Using compatibility `.name_repair`.\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndig <- function(df, bag, bags = c()) {\n  contents <- \n    df[bag] |>\n    unlist() |>\n    unname()\n  bags <- c(bags, bag)\n  if (length(contents) == 0) return(bags)\n  for (bag in contents) {\n    bags <- dig(df, bag, bags)\n  }\n  return(bags)\n}\ndf |>\n  dig('shiny gold') |>\n  tail(-1) |>\n  length()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7872\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}