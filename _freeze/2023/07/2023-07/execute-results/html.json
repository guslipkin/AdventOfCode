{
  "hash": "35e45bca26a134952a74a91c26df37d2",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"07: Camel Cards\"\nformat: html\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(mistlecode)\n\noptions(scipen = 999)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndt <-\n  readLines('input.txt') |>\n  stringr::str_split(' ') |>\n  unlist() |>\n  matrix(ncol = 2, byrow = TRUE) |>\n  `colnames<-`(c('cards', 'bet')) |>\n  tibble::as_tibble()\n```\n:::\n\n\n\n\n## Part 1\n\nThis wasn't too bad, but I originally used a `dplyr::case_when` instead of my `if...else` chain and because `dplyr::case_when` is vectorized, that wouldn't work. However, when I swapped to my `if...else` chain, I accidentally marked three of a kind as the same value as a full house. Quite annoying, but an easy fix.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrank <- c('A', 'K', 'Q', 'J', 'T', 9:2) |> rev()\ndt |>\n  dplyr::mutate(\n    '.nest' = purrr::map(.data$cards, \\(x) {\n      # x <- 'QJJQ2'\n      h <-\n        x |>\n        stringr::str_split_1('') |>\n        table() |>\n        sort(decreasing = TRUE)\n      hand <-\n        if (length(h) == 1 && all(h %in% 5)) 7\n        else if (length(h) == 2 && all(h %in% c(4, 1))) 6\n        else if (length(h) == 2 && all(h %in% c(3, 2))) 5\n        else if (length(h) == 3 && max(h) == 3) 4\n        else if (length(h[h == 2]) == 2 && max(h) == 2) 3\n        else if (length(h[h == 2]) == 1 && max(h) == 2) 2\n        else 1\n      high <-\n        x |> \n        stringr::str_split_1('') |>\n        purrr::map_int(\\(y) which(rank == y)) |>\n        stringr::str_pad(2, pad = '0') |>\n        paste0(collapse = '') |>\n        as.integer()\n      list('hand' = hand, 'high' = high)\n    })\n  ) |>\n  tidyr::unnest_wider('.nest') |>\n  dplyr::arrange(.data$hand, .data$high) |>\n  dplyr::mutate('bid' = as.integer(.data$bet) * dplyr::row_number()) |>\n  dplyr::pull(.data$bid) |>\n  sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 250120186\n```\n\n\n:::\n:::\n\n\n\n\n## Part 2\n\nThis took longer than it should've. I had the concept down quick, but was assigning the `Joker` to the highest available card rather than the card with the most occurrences. This is quickly apparent with the example `KTJJT` which with my original method would've become `KTKKT`, a full house, instead of `KTTTT`, four of a kind.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrank <- c('A', 'K', 'Q', 'T', 9:2, 'J') |> rev()\ndt |>\n  dplyr::mutate(\n    '.nest' = purrr::map(.data$cards, \\(x) {\n      # x <- 'KTJJT'\n      x <- stringr::str_split_1(x, '')\n      h <-\n        x |>\n        table() |>\n        sort(decreasing = TRUE)\n      if (any(names(h) == 'J') & !all(names(h) == 'J')) {\n        r <- which(rank == names(h[names(h) != 'J'])[1])\n        h[rank[r]] <- h[rank[r]] + h['J']\n      } else if (length(h) == 1 & all(names(h) == 'J')) {\n        h <- c('A' = 5)\n      }\n      h <- h[names(h) != 'J']\n      hand <- {\n        if (length(h) == 1 && all(h %in% 5)) 7\n        else if (length(h) == 2 && all(h %in% c(4, 1))) 6\n        else if (length(h) == 2 && all(h %in% c(3, 2))) 5\n        else if (length(h) == 3 && max(h) == 3) 4\n        else if (length(h[h == 2]) == 2 && max(h) == 2) 3\n        else if (length(h[h == 2]) == 1 && max(h) == 2) 2\n        else 1\n      }\n      high <-\n        x |> \n        purrr::map_int(\\(y) which(rank == y)) |>\n        stringr::str_pad(2, pad = '0') |>\n        paste0(collapse = '') |>\n        as.integer()\n      list('hand' = hand, 'high' = high)\n    })\n  ) |>\n  tidyr::unnest_wider('.nest') |>\n  dplyr::arrange(.data$hand, .data$high) |>\n  dplyr::mutate('bid' = as.integer(.data$bet) * dplyr::row_number()) |>\n  dplyr::pull(.data$bid) |>\n  sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 250665248\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}