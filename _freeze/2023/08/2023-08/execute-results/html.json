{
  "hash": "1da3144817b0d9bf5591c648631f2125",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"08: Haunted Wasteland\"\nformat: html\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(mistlecode)\n\noptions(scipen = 999)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfile <- 'input.txt'\n\ndir <- \n  file |>\n  readLines(n = 1) |>\n  stringr::str_split_1('')\n  \ndt <-\n  file |>\n  readr::read_csv(skip = 2, trim_ws = TRUE, col_names = FALSE) |>\n  tidyr::separate(X1, into = c('start', 'L'), sep = ' = \\\\(') |>\n  dplyr::mutate('R' = stringr::str_remove_all(.data$X2, '\\\\)')) |>\n  dplyr::select(-'X2')\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRegistered S3 methods overwritten by 'bit64':\n  method               from  \n  as.double.integer64  cheapr\n  as.integer.integer64 cheapr\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 718 Columns: 2\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (2): X1, X2\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n\n\n\n## Part 1\n\nI have evidence that I struggled some other time, but I have no recollection. This was pretty easy, just had an off-by-one to deal with to get around the modulo of length sometimes being zero.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstart <- function(end, dir) {\n  dt[[dir]][dt$start == end]\n}\n\ncount <- 0\nend <- 'AAA'\nrepeat {\n  end <- start(end, dir[(count %% length(dir)) + 1])\n  if (end == 'ZZZ') break else count <- count + 1\n}\ncount + 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 17141\n```\n\n\n:::\n:::\n\n\n\n\n## Part 2\n\nI hate when there's a fancy math way. It's just least common multiples this time and I'm super dumb for not thinking of this sooner. I did have to be careful with `match` instead of `%in%` because that would return the indices in the incorrect order and cause everything to fail.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstart <- function(end, dir) {\n  dt[[dir]][match(end, dt$start)]\n}\n\ncount <- 0\nend <-\n  dt |>\n    dplyr::filter(grepl('A$', .data$start)) |>\n    dplyr::pull(.data$start)\ntargets <-\n  dt |>\n    dplyr::filter(grepl('Z$', .data$start)) |>\n    dplyr::pull(.data$start)\ntarget_pos <- integer(length(end))\nrepeat {\n  end <- start(end, dir[(count %% length(dir)) + 1])\n  if (any(end %in% targets)) {\n    target_pos[end %in% targets] <- count\n    if (!any(target_pos == 0)) break\n  }\n  count <- count + 1\n}\ncheapr::scm(target_pos + 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10818234074807\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}