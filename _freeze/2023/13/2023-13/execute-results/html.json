{
  "hash": "b041ca533bad0d40d3a020fcd7f8a8af",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Point of Incidence\"\nformat: html\ndate: \"2023-12-13\"\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(mistlecode)\n\noptions(scipen = 999)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndt <-\n  readLines(\"input.txt\") |>\n  tibble::as_tibble() |>\n  dplyr::mutate(group = cumsum(value == \"\")) |>\n  dplyr::filter(value != \"\") |>\n  dplyr::group_split(group) |>\n  purrr::map(\\(x) {\n    x |>\n      dplyr::pull(value) |>\n      stringr::str_split(\"\", simplify = TRUE)\n  })\n```\n:::\n\n\n\n\n## Part 1\n\nOkay okay. Not too bad. Just need to make sure I get the line of reflection right.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_up_down <- function(up, down) {\n  l <- min(c(length(up), length(down)))\n  up <- rev(rev(up)[seq_len(l)]); down <- down[rev(seq_len(l))];\n  list('up' = up, 'down' = down)\n}\nget_seq <- function(s) { s |> seq_len() |> head(-1) }\ncheck_row <- function(x) {\n  x |>\n    nrow() |>\n    get_seq() |>\n    purrr::map_int(\\(r) {\n      up <- seq_len(r); down <- min(c(r+1,nrow(x))):nrow(x)\n      updown <- get_up_down(up, down)\n      up <- x[updown$up,]; down <- x[updown$down,];\n      if (all(up == down)) r * 100 else 0\n    })\n}\ncheck_col <- function(x) {\n  x |>\n    ncol() |>\n    get_seq() |>\n    purrr::map_int(\\(r) {\n      up <- seq_len(r); down <- min(c(r+1,ncol(x))):ncol(x)\n      updown <- get_up_down(up, down)\n      up <- x[,updown$up]; down <- x[,updown$down];\n      if (all(up == down)) r else 0\n    })\n}\ndt |>\n  purrr::map(\\(x) {\n    c(check_row(x), check_col(x))\n  }) |>\n  unlist() |>\n  sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 37718\n```\n\n\n:::\n:::\n\n\n\n\n## Part 2\n\nomg. This is gonna be easy. I just need to check if all but one are equal instead of all. I got this in well under two minutes!\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncheck_row <- function(x) {\n  x |>\n    nrow() |>\n    get_seq() |>\n    purrr::map_int(\\(r) {\n      up <- seq_len(r); down <- min(c(r+1,nrow(x))):nrow(x)\n      updown <- get_up_down(up, down)\n      up <- x[updown$up,]; down <- x[updown$down,];\n      if (sum(up == down) == length(up) - 1) r * 100 else 0\n    })\n}\ncheck_col <- function(x) {\n  x |>\n    ncol() |>\n    get_seq() |>\n    purrr::map_int(\\(r) {\n      up <- seq_len(r); down <- min(c(r+1,ncol(x))):ncol(x)\n      updown <- get_up_down(up, down)\n      up <- x[,updown$up]; down <- x[,updown$down];\n      if (sum(up == down) == length(up) - 1) r else 0\n    })\n}\ndt |>\n  purrr::map(\\(x) {\n    c(check_row(x), check_col(x))\n  }) |>\n  unlist() |>\n  sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 40995\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}