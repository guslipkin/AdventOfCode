{
  "hash": "3717615e9f92d6bfdc4ab10592529abb",
  "result": {
    "markdown": "---\ntitle: \"2022-11: Monkey in the Middle\"\nformat: html\n---\n\n::: {.cell hash='2022-11_cache/html/unnamed-chunk-1_843487bebce8a189d2ed974579e5131d'}\n\n```{.r .cell-code}\nlibrary(mistlecode)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTo install `mistlecode` yourself, run `devtools::install_github('guslipkin/mistlecode')`.\n\n Also loading:  cipheR data.table dplyr purrr slider stringr tidyverse\n```\n:::\n:::\n\n::: {.cell hash='2022-11_cache/html/unnamed-chunk-2_566e5b9dfc2e35e378dbff985214c12a'}\n\n```{.r .cell-code}\ndt <- readLines(\"input.txt\")\n\ndt <- \n  data.frame(dt) |>\n  mutate(monkey = cumsum(grepl(\"Monkey \\\\d+:\", dt)) - 1) |>\n  filter(dt != \"\")\n```\n:::\n\n\nOh no. I'm going to bed.\n\n## Part 1\n\nThis was so much fun! I dipped my toes into S3 classes, made a useful function\nfactory, and did some recursion. I had a bit of trouble making sure my list of\nmonkeys was getting passed around properly and returned because loops can't\nchange objects in the global environment. That said, I have a bad feeling about\npart 2.\n\n\n::: {.cell hash='2022-11_cache/html/unnamed-chunk-3_1afd072ca2188ec353beb693ba68f4f5'}\n\n```{.r .cell-code}\noperation <- function(op, val) {\n  function(old) {\n    if (val == \"old\") { val <- as.integer(old) } \n    else { val <- as.integer(val) }\n    \n    if (op == \"*\") { val <- old * val }\n    else if (op == \"+\") { val <- old + val }\n    \n    return(val)\n  }\n}\n\nnew_monkey <- function(dt, x) {\n  name <- str_extract(dt[1,\"dt\"], \"\\\\d+\")\n  starting_items <- \n    str_split(dt[2,\"dt\"], \":|,\", simplify = TRUE)[1,-1] |> as.integer()\n  opp <- \n    str_split(dt[3, \"dt\"], \"=\", simplify = TRUE)[1,2] |>\n    str_match(\" (new|old) (\\\\+|\\\\-|\\\\*|\\\\/) (old|\\\\d+)\")\n  op <- operation(op = opp[1,3], val = opp[1,4])\n  test <- str_extract(dt[4,\"dt\"], \"\\\\d+\") |> as.integer()\n  case_true <- str_extract(dt[5,\"dt\"], \"\\\\d+\")\n  case_false <- str_extract(dt[6,\"dt\"], \"\\\\d+\")\n  x <- list(\n    \"name\" = name,\n    \"starting_items\" = starting_items,\n    \"operation\" = op,\n    \"test\" = test,\n    \"case_true\" = case_true,\n    \"case_false\" = case_false,\n    \"inspections\" = 0\n  )\n  structure(x, class = \"monkey\")\n}\n\nmonkeys <- \n  lapply(unique(dt$monkey), \\(m) { \n    new_monkey(dt[dt$monkey == m,], m) \n  })\nnames(monkeys) <- sapply(monkeys, \\(m) m$name)\n\nprocess_items <- function(item, monkey, these_monkeys) {\n  if (is.na(monkey$starting_items[item]) | \n      item > length(monkey$starting_items)) { return(these_monkeys) }\n  worry_level <- monkey$operation(monkey$starting_items[item])\n  worry_level <- floor(worry_level / divide)\n  if (worry_level %% monkey$test == 0) {\n    case_true <- these_monkeys[[monkey$case_true]]$starting_items\n    case_true <- c(case_true, worry_level)\n    case_true <- case_true[!is.na(case_true)]\n    these_monkeys[[monkey$case_true]]$starting_items <- case_true\n  } else {\n    case_false <- these_monkeys[[monkey$case_false]]$starting_items\n    case_false <- c(case_false, worry_level)\n    case_false <- case_false[!is.na(case_false)]\n    these_monkeys[[monkey$case_false]]$starting_items <- case_false\n  }\n  process_items(item + 1, monkey, these_monkeys)\n}\n\nprocess_monkey <- function(i, these_monkeys) {\n  if (i == length(monkeys) + 1) { return(these_monkeys) }\n  monkey <- these_monkeys[[i]]\n  these_monkeys <- process_items(1, monkey, these_monkeys)\n  monkey$inspections <- \n    monkey$inspections + length(monkey$starting_items)\n  monkey$starting_items <- NA_integer_\n  these_monkeys[[i]] <- monkey\n  process_monkey(i + 1, these_monkeys)\n}\n\nround <- function(these_monkeys, round) {\n  if (round == round_max + 1) { return(these_monkeys) }\n  these_monkeys <- process_monkey(1, these_monkeys)\n  round(these_monkeys, round + 1)\n}\n```\n:::\n\n::: {.cell hash='2022-11_cache/html/unnamed-chunk-4_b1077981d965d1b4ae23673501fb359b'}\n\n```{.r .cell-code}\ndivide <- 3\nround_max <- 20\nm <- round(monkeys, 1)\nsapply(m, \\(m) m$inspections) |>\n  sort(decreasing = TRUE) |>\n  head(2) |>\n  prod()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 316888\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}